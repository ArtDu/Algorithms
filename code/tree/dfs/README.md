#### Dfs

Тот же самый обход, что и в графе, только без visited, так как дереве - ациклический граф.  
Вместо него, параметр parent, который гарантирует, попадание в непосещенные вершины.
```c++
void dfs(ll u, ll p) {
    for (auto &v : aList[u]) {
        if (v != p) {
            dfs(v, u);
        }
    }
}
```

#### Проверка, является ли одна вершина дерева предком другой:
```
В начале и в конце итерации поиска в глубину будет запоминать "время" захода и выхода в каждой вершине.
Теперь за O(1) можно найти ответ: вершина p является предком вершины c тогда и только тогда, когда p_in < c_in and c_out < p_out.
```
