<?xml version="1.0" encoding="UTF-8"?>
<FictionBook xmlns:l="http://www.w3.org/1999/xlink" xmlns="http://www.gribuser.ru/xml/fictionbook/2.0"><description> <title-info> <genre>comp_programming</genre> <author><first-name>Скотт</first-name><last-name>Майерс</last-name><id>41df634b-2a82-102a-9ae1-2dfe723fe7c7</id></author><book-title>Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ</book-title> <annotation><p>Эта книга представляет собой перевод третьего издания американского бестселлера Effective C++ и является руководством по грамотному использованию языка C++. Она поможет сделать ваши программы более понятными, простыми в сопровождении и эффективными. Помимо материала, описывающего общую стратегию проектирования, книга включает в себя главы по программированию с применением шаблонов и по управлению ресурсами, а также множество советов, которые позволят усовершенствовать ваши программы и сделать работу более интересной и творческой. Книга также включает новый материал по принципам обработки исключений, паттернам проектирования и библиотечным средствам.</p>
<p>Издание ориентировано на программистов, знакомых с основами C++ и имеющих навыки его практического применения.</p>
</annotation><date>2006</date> <coverpage><image l:href="#cover.jpg"/></coverpage><lang>ru</lang><src-lang>en</src-lang> <translator><first-name>Н.</first-name><middle-name>А.</middle-name><last-name>Мухин</last-name><id>bbfd18e0-72a5-102d-9ab1-2309c0a91052</id></translator></title-info> <document-info> <author> <nickname>Kuznetch</nickname> </author> <program-used>doc2fb, FB Editor v2.0</program-used> <date value="2010-11-28">28 Nov 2010</date> <src-url>http://litres.ru/</src-url> <src-ocr>Текст предоставлен издательством</src-ocr> <id>3bad977e-f80e-11df-8c7e-ec5afce481d9</id> <version>1.0</version> <history><p>2010-11-28: Создание fb2 (Kuznetch)</p>
</history> <publisher><first-name/><last-name>Литагент «ДМК»</last-name><id>233a80b4-1212-102e-b479-a360f6b39df7</id></publisher></document-info> <publish-info> <book-name>Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ</book-name> <publisher>ДМК Пресс</publisher> <city>Москва</city> <year>2006</year> <isbn>5-94074-304-8</isbn> </publish-info> </description><body><title><p>Скотт Мэйерс</p>
<p>Эффективное использование C++. 55 верных способов улучшить структуру и код ваших программ</p>
</title><section><subtitle><strong>Отзывы о третьей редакции</strong></subtitle><subtitle><emphasis>Эффективного использования C++</emphasis> </subtitle><cite><p>Книга Скотта Мейерса <emphasis>«Эффективное использование C++», третья редакция</emphasis> – это концентрация опыта программирования – того опыта, который без нее достался бы вам дорогой ценой. Эта книга – великолепный источник, который я рекомендую всем, кто пишет на C++ профессионально.</p>
<text-author><emphasis>Питер Дулимов, ME, инженер, подразделение оценки и исследований NAVSYSCOM, Австралия</emphasis></text-author></cite><cite><p>Третья редакция остается лучшей книгой, посвященной тому, как сложить вместе все части C++ для создания эффективных и внутренне целостных программ. Если вы претендуете на то, чтобы быть программистом C++, то должны ее прочитать.</p>
<text-author><emphasis>Эрик Наглер, консультант, преподаватель и автор «Изучая C++»</emphasis></text-author></cite><cite><p>Первая редакция этой книги была одной из небольшого (весьма небольшого) числа книг, благодаря которым я ощутимо повысил свой уровень как профессионального разработчика программного обеспечения. Как и другие книги из этого ряда, она оказалась практичной и легкой для чтения, но при этом содержала множество важных советов. <emphasis>«Эффективное использование</emphasis> C++», <emphasis>третья редакция,</emphasis> продолжает эту традицию. C++ – очень мощный язык программирования. Если C дает веревку, по которой можно забраться на вершину горы, то C++ – это целый магазин, в котором самые разные люди готовы помочь вам завязать на этой веревке узлы. Овладение материалом, приведенным в этой книге, определенно повысит вашу способность эффективно использовать C++ и не умереть при этом от напряжения.</p>
<text-author><emphasis>Джек В. Ривес, исполнительный директор Bleading Edge Software Technologies</emphasis></text-author></cite><cite><p>Каждый новый разработчик, который приходит в мою команду, сразу получает задание – прочесть эту книгу.</p>
<text-author><emphasis>Майкл Ланцетта, ведущий инженер по программному обеспечению</emphasis></text-author></cite><cite><p>Я прочитал первую редакцию «Эффективного использования C++» около 9 лет назад, и эта книга сразу стала одной из моих любимых книг по C++. На мой взгляд, третье издание «Эффективного использования C++» остается обязательным к прочтению для всех, кто желает эффективно программировать на C++. Мы будем жить в лучшем мире, если программисты C++ прочтут эту книгу прежде, чем написать первую строку профессионального кода.</p>
<text-author><emphasis>Дэнни Раббани, инженер по программному обеспечению</emphasis></text-author></cite><cite><p>Первое издание «Эффективного использования C++» Скотта Мейерса попалось мне, когда я был рядовым программистом и напряженно старался как можно лучше выполнить порученную работу. И это было спасением! Я обнаружил, что советы Мейерса практически полезны и эффективны, что они на 100 % реализуют то, что обещают. Третья редакция помогает в практическом применении C++ при работе над современными серьезными программными проектами, предоставляя информацию о самых новых средствах и возможностях языка. Я с удовольствием обнаружил, что могу найти много нового и интересного для себя в третьем издании книги, которую, как мне казалось, знаю очень хорошо.</p>
<text-author><emphasis>Майкл Топик, технический программный менеджер</emphasis></text-author></cite><cite><p>Это авторитетное руководство от Скотта Мейерса, гуру C++, предназначенное для каждого, кто хочет применять C++ безопасно и эффективно, или же переходит к C++ от любого другого объектно-ориентированного языка. Эта книга содержит ценную информацию, изложенную в ясном, сжатом, занимательном и проницательном стиле.</p>
<text-author><emphasis>Сиддхартха Каран Сингх, разработчик программного обеспечения</emphasis></text-author></cite></section><section><title><p>Благодарности</p>
</title><p>Книга «Эффективное использование C++» существует уже 15 лет, а изучать C++ я начал примерно за 5 лет до того, как написал ее. Таким образом, работа над этим проектом ведется около 20 лет. За это время я получал пожелания, замечания, исправления, а иногда и ошеломляющие наблюдения от сотен (тысяч?) людей. Каждый из них помог развитию «Эффективного использования C++». Я благодарен им всем.</p>
<p>Я давно уже отказался от попыток запомнить, где и чему я научился сам, но один источник не могу не упомянуть, поскольку пользуюсь им постоянно. Это группы новостей Usenet, в особенности comp.lang.c++.moderated и comp.std.c++. Многие правила, приведенные в этой книге (возможно, большинство), появились как результат осмысления технических идей, обсуждавшихся в этих группах.</p>
<p>В отборе нового материала, вошедшего в третье издание книги, мне помогал Стив Дьюхэрст (Steve Dewhurst). В правиле 11 идея реализации оператора operator= путем копирования и обмена почерпнута из заметок Герба Саттера (Herb Sutter), а именно из задачи 13 его книги «Exceptional C++» (Addison-Wesley, 2000)<a type="note" l:href="#n_1">[1]</a>. Идея о захвате ресурса как инициализации (правило 13) заимствована из книги «Язык программирования C++» («The C++ Programming Language», Addison– Wesley, 2002) Бьярна Страуструпа. Идея правила 17 взята из раздела «Передовые методы» («Best practices») на сайте «Boost shared_ptr» (http:// boost.org/libs/ smart_ptr/shared_ptr.htm#BestPractices) и уточнена на основе материала задачи 21 из книги Herb Sutter «More exceptional C++» (Addison-Wesley, 2002). На правило 29 меня вдохновило развернутое исследование этой темы, предпринятое Гербом Саттером, в задачах 8-19 из книги «Exceptional C++», а также в задачах 17–23 из «More exceptional C++» и задачах 11–13 из его же книги Exceptional C++ Style» (Addison-Wesley, 2005). Дэвид Абрахамс (David Abrahams) помог мне лучше понять три принципа гарантирования безопасности исключений. Идиома невиртуального интерфейса (NVI) в правиле 35 взята из колонки Герба Саттера «Виртуальность» (Virtuality) в сентябрьском номере 2001 г. журнала «C/C++ Users Journal». Упомянутые в том же правиле паттерны проектирования «Шаблонный метод» (Template Method) и «Стратегия» взяты из книги «Design Patterns»<a type="note" l:href="#n_2">[2]</a> (Addison-Wesley, 1995) Эриха Гамма (Erich Gamma), Ричарда Хелма (Richard Helm), Ральфа Джонсона (Ralf Johnson) и Джона Влиссидеса (John Vlissides). Идею применения идиомы NVI в правиле 37 подсказал Хендрик Шобер (Hendrik Schober). Вклад Дэвида Смаллберга (David Smallberg) – реализация множества, описанная в правиле 38. Сделанное в правиле 39 наблюдение о том, что оптимизация пустого базового класса в принципе невозможна при множественном наследовании, заимствовано из книги Дэвида Вандевурде (David Vandevoorde) и Николая М. Джоссутиса (Nickolai M. Josuttis) «Templates C++» («Шаблоны в языке C++») (Addison-Wesley, 2003). Изложенное в правиле 42 мое первоначальное представление о том, для чего нужно ключевое слово typename, основано на документе «Часто задаваемые вопросы о C++ и C» («C++ and C FAQ») (<a l:href="http://www.comeaucomputing.com/techtalk/#typename">http://www.comeaucomputing.com/techtalk/#typename</a>), который поддерживает Грег Комо (Greg Comeau), а Леор Золман (Leor Zolman) помог мне осознать, что это представление ошибочно (моя вина, а не Грега). Тема правила 46 возникла из речи Дэна Сакса (Dan Saks) «Как заводить новых друзей». Высказанная в конце правила 52 идея о том, что если вы объявляете одну версию оператора new, то должны объявлять и все остальные, изложена в задаче 22 книги «Exceptional C++» Герба Саттера. Мое понимание процесса рецензирования Boost (суммированное в правиле 55) было уточнено Дэвидом Абрахамсом.</p>
<p>Все вышесказанное касается того, где и от кого чему-то научился именно я, независимо от того, кто первым опубликовал материал на соответствующую тему.</p>
<p>В моих заметках также сказано, что я использовал информацию, полученную от Стива Клемеджа (Steve Clamage), Антона Тракса (Antoine Trux), Тимоти Кнокса (Timothy Knox) и Майка Коэлблинга (Mike Kaelbling), хотя, к сожалению, не уточняется – где и как.</p>
<p>Черновики первого издания просматривали Том Карджилл (Tom Cargill), Гленн Каролл (Glenn Caroll), Тони Дэвис (Tony Davis), Брайн Керниган (Brian Kernigan), Жак Кирман (Jak Kirman), Дуг Ли (Doug Lea), Моисей Лежтер (Moises Lejter), Юджин Сантос мл. (Eugene Santos, Jr), Джон Шевчук (John Shewchuk), Джон Стаско (John Stasko), Бьерн Страуструп (Bjarne Stroustrup), Барбара Тилли (Barbara Tilly) и Нэнси Л. Урбано (Nancy L. Urbano). Кроме того, пожелания относительно улучшений, которые были включены в более поздние переиздания, высказывали Нэнси Л. Урбано, Крис Трейчел (Chris Treichel), Дэвид Корбин (David Corbin), Пол Гибсон (Paul Gibson), Стив Виноски (Steve Vinoski), Том Карджилл (Tom Cargill), Нейл Родес (Neil Rhodes), Дэвид Берн (David Bern), Расс Вильямс (Russ Williams), Роберт Бразил (Robert Brazile), Дуг Морган (Doug Morgan), Уве Штейнмюллер (Uwe Steinmuller), Марк Сомер (Mark Somer), Дуг Мур (Doug Moore), Дэвид Смаллберг, Сейт Мельтцер (Seith Meltzer), Олег Штейнбук (Oleg Steinbuk), Давид Папурт (David Papurt), Тони Хэнсен (Tony Hansen), Питер Мак-Клуски (Peter McCluskey), Стефан Кухлинс (Stefan Kuhlins), Дэвид Браунегг (David Braunegg), Поль Чисхолм (Paul Chisholm), Адам Зелл (Adam Zell), Кловис Тондо, Майк Коэлблинг, Натраж Кини (Natraj Kini), Ларс Ньюман (Lars Numan), Грег Лутц (Greg Lutz), Тим Джонсон, Джон Лакос (John Lakos), Роджер Скотт (Roger Scott), Скотт Фроман (Scott Frohman), Алан Рукс (Alan Rooks), Роберт Пур (Robert Poor), Эрик Наглер (Eric Nagler), Антон Тракс, Кад Роукс (Cade Roux), Чандрика Гокул (Chandrika Gokul), Рэнди Мангоба (Randy Mangoba) и Гленн Тейтельбаум (Glenn Teitelbaum).</p>
<p>Черновики второго издания проверяли: Дерек Босх (Derek Bosch), Тим Джонсон (Tim Johnson), Брайн Керниган, Юничи Кимура (Junichi Kimura), Скотт Левандовски (Scott Lewandowski), Лаура Михаелс (Laura Michaels), Дэвид Смаллберг (David Smallberg), Кловис Тонадо (Clovis Tonado), Крис Ван Вик (Chris Van Wyk) и Олег Заблуда (Oleg Zabluda). Более поздние тиражи выиграли от комментариев Дэниела Штейнберга (Daniel Steinberg), Арунпрасад Марате (Arunprasad Marathe), Дуга Стаппа (Doug Stapp), Роберта Халла (Robert Hall), Черилла Фергюссона (Cheryl Ferguson), Гари Бартлетта (Gary Bartlett), Майкла Тамма (Michael Tamm), Кендалла Бимана (Kendall Beaman), Эрика Наглера, Макса Хайлперина (Max Hailperin), Джо Готтмана (Joe Gottman), Ричарда Викса (Richard Weeks), Валентина Боннарда (Valentin Bonnard), Юн Хи (Jun He), Тима Кинга (Tim King), Дона Майлера (Don Mailer), Теда Хилла (Ted Hill), Марка Харрисона (Marc Harrison), Майкла Рубинштейна (Michael Rubinstein), Марка Роджерса (Marc Rodgers), Дэвида Го (David Goh), Брентона Купера (Brenton Cooper), Энди Томаса-Крамера (Andy Thomas-Cramer), Антона Тракса, Джона Вальта (John Walt), Брайана Шарона (Brian Sharon), Лиам Фитцпатрик (Liam Fitzpatric), Бернда Мора (Bernd Mohr), Гарри Йи (Gary Yee), Джона О'Ханли (John O'Hanley), Бреди Патресона (Brady Paterson), Кристофера Петерсона (Christopher Peterson), Феликса Клузняка (Feliks Kluzniak, Изи Даниетц (Isi Dunetz), Кристофера Креутци (Christopher Creutzi), Яна Купера (Ian Cooper), Карла Харриса (Carl Harris), Марка Стикеля (Marc Stickel), Клея Будина (Clay Budin), Панайотиса Мацинопулоса (Panayotis Matsinopulos), Дэвида Смаллберга, Херба Саттера, Пажо Мисленцевича (Pajo Misljencevic), Джулио Агостини (Giulio Agostini), Фредерика Бломквиста (Fredrik Blonqvist), Джимми Снайдера (Jimmy Snyder), Бириал Дженсен (Byrial Jensen), Витольда Кузьминского (Witold Kuzminski), Казунобу Курияма (Kazunobu Kuriyama), Майкла Кристенсена (Michael Christensen), Йорга Янеза Теруела (Jorge Yanez Teruel), Марка Дэвиса (Mark Davis), Марти Рабиновича (Marty Rabinowitz), Арес Лага (Ares Lagae) и Александра Медведева.</p>
<p>Ранние частичные черновики настоящего издания просматривали: Брайан Керниган, Анжелика Ланджер, Джесси Лачли, Роджер П. Педерсен, Крис Ван Вик, Николас Страуструп и Хендрик Шобер. Просмотр полного текста черновика осуществляли: Леор Золман, Майк Тсао, Эрик Наглер, Жене Гутник, Дэвид Абрахамс, Герхард Креузер, Дросос Коуронис, Брайан Керниган, Эндрю Кримс, Балог Пал, Эмили Джагдхар, Евгений Каленкович, Майк Роз, Энрико Каррара, Бенджамен Берк, Джек Ривз, Стив Шириппа, Мартин Фалленстедт, Тимоти Кнокс, Юн Баи, Майкл Ланцетта, Филип Джанерт, Джудо Бартолуччи, Майкл Топик, Джефф Шерпельтц, Крис Наурот, Нишант Миттал, Джефф Соммерс, Хал Морофф, Винсент Манис, Брендон Чанг, Грег Ли, Джим Михан, Алан Геллер, Сиддхартха Сингх, Сэм Ли, Сасан Даштинежад, Алекс Мартин, Стив Каи, Томас Фручтерман, Кори Хикс, Дэвид Смаллберг, Гунавардан Какулапати, Дэнни Раббани, Джейк Кохен, Хендрик Шубер, Пако Вициана, Гленн Кеннеди, Джефри Д. Олдхам, Николас Страуструп, Мэтью Вильсон, Андрей Александреску, Тим Джонсон, Леон Мэтьюс, Питер Дулимов и Кевлин Хенни. Черновики некоторых отдельных параграфов, кроме того, просматривали Херб Саттер и Аттила Ф. Фехер.</p>
<p>Просмотр сырой (и, возможно, неполной) рукописи – это трудная работа, а наличие жестких сроков только делает ее еще труднее. Я благодарен всем, кто выразил желание помочь мне в этом.</p>
<p>Просмотр рукописи тем более труден, если вы не имеете представления о материале, но не должны пропустить <emphasis>ни одной</emphasis> неточности, которая могла бы вкрасться в текст. Поразительно, что находятся люди, согласные редактировать тексты. Криста Медоубрук была редактором этой книги и сумела выявить немало ошибок, которые пропустили все остальные.</p>
<p>Леор Золман в ходе рецензирования рукописи проверил все примеры кода на различных компиляторах, а затем сделал это еще раз, после того как я внес изменения. Если какие-то ошибки остались, за них несу ответственность я, а не Леор.</p>
<p>Карл Вигерс и особенно Тим Джонсон написали краткий, но полезный текст для обложки.</p>
<p>Джон Вэйт, редактор первых двух изданий этой книги, неосмотрительно согласился снова поработать в этом качестве. Его помощница, Дениз Микельсен, неизменно отвечала приятной улыбкой на мои частые и докучливые замечания (по крайней мере, мне так кажется, хотя лично я никогда с ней не встречался). Джулия Нахил «вытащила короткую соломинку», ей пришлось отвечать за производство этой книги. В течение шести недель она сидела ночами, чтобы выдержать график, не теряя при этом хладнокровия. Джон Фуллер (ее начальник) и Марти Рабинович (его начальница) также принимали непосредственное участие в процессе подготовки издания. Официальные обязанности Ванессы Мур заключались в макетировании книги в программе FrameMaker и создании текста в формате PDF, но она по своей инициативе внесла добавления в Приложение B и отформатировала его для печати на внутренней стороне обложки. Сольвейг Хьюгланд помогла с составлением указателя. Сандра Шройедер и Чути Прасерцит отвечали за дизайн обложки. Именно Чути приходилось переделывать обложку всякий раз, как я говорил «Как насчет того, чтобы поместить эту фотографию, но с полоской другого цвета?». Чанда Лери-Коути совершенно вымоталась, занимаясь маркетингом книги.</p>
<p>В течение нескольких месяцев, пока я работал над рукописью, телевизионный сериал «Баффи – убийца вампиров» помогал мне снять стресс в конце дня. Потребовалось немало усилий, чтобы изгнать говорок Баффи со страниц этой книги.</p>
<p>Кэти Рид учила меня программированию в 1971 году, и я рад, что мы остаемся друзьями по сей день. Дональд Френч нанял меня и Моисея Лежтера для разработки учебных материалов по C++ в 1989 году (что заставило меня <emphasis>действительно</emphasis> изучить C++), а в 1991 году он привлек меня к презентации их на компьютере Stratus. Тогда студенты подвигли меня написать то, что впоследствии стало первой редакцией этой книги. Дон также познакомил меня с Джоном Вайтом, который согласился опубликовать ее.</p>
<p>Моя жена, Нэнси Л. Урбано, продолжает поощрять мое писательство, даже после семи изданных книг, адаптации их для CD и диссертации. Она обладает невероятным терпением. Без нее я бы никогда не смог сделать то, что сделал.</p>
<p>От начала до конца наша собака Персефона была моим бескорыстным компаньоном. К сожалению, в большей части проекта она участвовала, уже находясь в погребальной урне. Нам ее очень не хватает.</p>
</section><section><title><p>Предисловие</p>
</title><p>Я написал первый вариант книги «Эффективное использование C++» в 1991 г. Когда в 1997 г. настало время для второго издания, я существенно обновил материал, но, не желая смутить читателей, знакомых с первым изданием, постарался сохранить существующую структуру: 48 из оригинальных 50 правил остались по сути неизменными. Если сравнивать книгу с домом, то второе издание было похоже на косметический ремонт – переклейку обоев, окраску в другие цвета и замену осветительных приборов.</p>
<p>В третьем издании я решился на гораздо большее. (Был момент, когда хотелось перестроить заново все, начиная с фундамента.) Язык C++ с 1991 года изменился очень сильно, и цели этой книги – выявить все наиболее важное и представить в виде компактного сборника рекомендаций – уже не отвечал набору правил, сформулированных 15 лет назад. В 1991 году было резонно предполагать, что на язык С++ переходят программисты, имеющие опыт работы с С. Теперь же к ним с равной вероятностью можно отнести и тех, кто раньше писал на языках Java или C#. В 1991 году наследование и объектно-ориентированное программирование были чем-то новым для большинства программистов. Теперь же это – хорошо известные концепции, а областями, в разъяснении которых люди нуждаются в большей степени, стали исключения, шаблоны и обобщенное программирование теми. В 1991 году никто не слышал о паттернах проектирования. Теперь без их упоминания вообще трудно обсуждать программные системы. В 1991 году работа над формальным стандартом C++ только начиналась, теперь этому стандарту уже 8 лет, и ведется работа над следующей версией.</p>
<p>Чтобы учесть все эти изменения, я решил начать с чистого листа и спросил себя: «Какие советы стоит дать практикующим программистам C++ в 2005 году?» В результате и появился набор правил, включенных в новое издание. Эта книга включает новые главы по программированию с применением шаблонов и управлению ресурсами. Фактически шаблоны красной нитью проходят через весть текст, поскольку мало что в современном C++ обходится без них. В книгу включен также материал по программированию при наличии исключений, паттернам проектирования и новым библиотечным средствам, описанным в документе «Technical Report 1» (TR1) (этот документ рассматривается в правиле 54). Признается также тот факт, что подходы и методы, которые хорошо работают в однопоточных системах, могут быть неприменимы к многопоточным. Больше половины материалов этого издания – новые темы. Однако значительная часть основополагающей информации из второго издания остается актуальной, поэтому я нашел способ в той или иной форме повторить ее (соответствие между правилами второго и третьего изданий вы найдете в приложении B).</p>
<p>Я старался по мере сил сделать эту книгу максимально полезной, но, конечно, не считаю ее безупречной. Если вам покажется, что какие-то из приведенных правил нельзя считать универсально применимыми, что есть лучший способ решить сформулированную задачу либо что обсуждение некоторых технических вопросов недостаточно ясно, неполно, может ввести в заблуждение, пожалуйста, сообщите мне. Если вы обнаружите ошибки любого рода – технические, грамматические, типографские, – любые, – напишите мне и об этом. При выпуске следующего тиража я с удовольствием упомяну каждого, кто обратит мое внимание на какую-то проблему.</p>
<p>Несмотря на то что в новом издании количество правил увеличено до 55, конечно, нельзя сказать, что рассмотрены все и всяческие вопросы. Но сформулировать набор таких правил, которых следует придерживаться почти во всех приложениях почти всегда, труднее, чем может показаться на первый взгляд. Если у вас есть предложения по поводу того, что стоило бы включить еще, я с удовольствием их рассмотрю.</p>
<p>Начиная с момента выхода в свет первого издания этой книги, я вел перечень изменений, в котором отражены исправления ошибок, уточнения и технические обновления. Он доступен на Web-странице «Effective C++ Errata» по адресу <a l:href="http://aristeia.com/BookErrata/ec++3e-errata.html">http://aristeia.com/BookErrata/ec++3e-errata.html</a>. Если вы хотите получать уведомления при обновлении этого перечня, присоединяйтесь к моему списку рассылки. Я использую его для того, чтобы делать объявления, которые, вероятно, заинтересуют людей, следящих за моей профессиональной деятельностью. Подробности см. на <a l:href="http://aristeia.com/MailingList">http://aristeia.com/MailingList</a>.</p>
<empty-line/><p>Скотт Дуглас Мэйерс</p>
<p><a l:href="http://aristeia.com/">http://aristeia.com/</a></p>
<p>Стаффорд, Орегон, апрель 2005</p>
</section><section><title><p>Введение</p>
</title><section><p>Одно дело – изучать фундаментальные основы языка, и совсем другое – учиться проектировать и реализовывать эффективные программы. В особенности это касается C++, известного необычайно широкими возможностями и выразительностью. Работа на C++ при правильном его использовании способна доставить удовольствие. Самые разные проекты могут получить непосредственное выражение и эффективную реализацию. Тщательно выбранный и грамотно реализованный набор классов, функций и шаблонов поможет сделать программу простой, интуитивно понятной, эффективной и практически не содержащей ошибок. При наличии определенных навыков написание эффективных программ на C++ – совсем не трудное дело. Однако при неразумном использовании C++ может давать непонятный, сложный в сопровождении и попросту неправильный код.</p>
<p>Цель этой книги – показать вам, как применять C++ <emphasis>эффективно.</emphasis> Я исхожу из того, что вы уже знакомы с C++ как <emphasis>языком программирования,</emphasis> а также имеете некоторый опыт работы с ним. Я предлагаю вашему вниманию рекомендации по применению этого языка, следование которым позволит сделать ваши программы понятными, простыми в сопровождении, переносимыми, расширяемыми, эффективными и работающими в соответствии с ожиданиями.</p>
<p>Предлагаемые советы можно разделить на две категории: общая стратегия проектирования и практическое использование отдельных языковых конструкций. Обсуждение вопросов проектирования призвано помочь вам сделать выбор между различными подходами к решению той или иной задачи на C++. Что выбрать: наследование или шаблоны? Открытое или закрытое наследование? Закрытое наследование или композицию? Функции-члены или свободные функции? Передачу по значению или по ссылке? Важно принять правильное решение с самого начала, поскольку последствия неудачного выбора могут никак не проявляться, пока не станет слишком поздно, а переделывать будет трудно, долго и дорого.</p>
<p>Даже когда вы точно знаете, что хотите сделать, добиться желаемых результатов бывает нелегко. Значение какого типа должен возвращать оператор присваивания? Когда деструктор должен быть виртуальным? Как себя ведет оператор new, если не может найти достаточно памяти? Исключительно важно проработать подобные детали, поскольку иначе вы почти наверняка столкнетесь с неожиданным и даже необъяснимым поведением программы. Эта книга поможет вам избежать подобных ситуаций.</p>
<p>Конечно, эту книгу сложно назвать полным руководством по C++. Скорее, это коллекция их 55 советов (или правил), как улучшить ваши программы и проекты. Каждый параграф более или менее независим от остальных, но в большинстве есть перекрестные ссылки. Лучше всего читать эту книгу, начав с того правила, которое вас наиболее интересует, а затем следовать по ссылкам, чтобы посмотреть, куда они вас приведут.</p>
<p>Эта книга также не является введением в C++. В главе 2, например, я рассказываю о правильной реализации конструкторов, деструкторов и операторов присваивания, но при этом предполагаю, что вы уже знаете, что эти функции делают и как они объявляются. На эту тему существует множество книг по C++.</p>
<p>Цель <emphasis>этой</emphasis> книги – выделить те аспекты программирования на C++, которым часто не уделяют должного внимания. В других книгах описывают различные части языка. Здесь же рассказывается, как их комбинировать между собой для получения эффективных программ. В других изданиях говорится о том, как заставить программу откомпилироваться. А эта книга – о том, как избежать проблем, которых компилятор не в состоянии обнаружить.</p>
<p>В то же время настоящая книга ограничивается только <emphasis>стандартным</emphasis> C++. Здесь используются лишь те средства языка, которые описаны в официальном стандарте. Переносимость – ключевой вопрос для этой книги, поэтому если вы ищете платформенно-зависимые трюки, обратитесь к другим изданиям.</p>
<p>Не найдете вы в этой книге и «Евангелия от C++» – единственно верного пути к идеальной программе на C++. Каждое правило – это рекомендация по тому или иному аспекту: как отыскать более удачный дизайн, как избежать типичных ошибок, как достичь максимальной эффективности, но ни один из пунктов не является универсально применимым. Проектирование и разработка программного обеспечения – это сложная задача, на которую оказывают влияние ограничения аппаратного обеспечения, операционной системы и приложений, поэтому лучшее, что я могу сделать, – это представить <emphasis>рекомендации</emphasis> по повышению качества программ.</p>
<p>Если вы систематически будете следовать всем рекомендациям, то маловероятно, что столкнетесь с наиболее частыми ловушками, подстерегающими вас в С++, но из любого правила есть исключения. Вот почему в каждом правиле приводятся пояснения. Они-то и составляют самую важную часть книги. Только поняв, что лежит в основе того или иного правила, вы сможете решить, насколько оно соответствует вашей программе с присущими только ей ограничениями.</p>
<p>Лучший способ использования этой книги – постичь тайны поведения C++, понять, почему он ведет себя именно так, а не иначе, и использовать его поведение в своих целях. Слепое применение на практике всех приведенных правил совершенно неуместно, но в то же время не стоит без особых на то причин поступать вопреки этим советам.</p>
</section><section><title><p>Терминология</p>
</title><p>Существует небольшой словарик C++, которым должен владеть каждый программист. Следующие термины достаточно важны, поэтому имеет смысл убедиться, что мы понимаем их одинаково.</p>
<p><strong>Объявление</strong> (declaration) сообщает компилятору имя и тип чего-либо, опуская некоторые детали. Объявления выглядят так:</p>
<empty-line/><p><code>extern int x; // объявление объекта</code></p>
<p><code>std::size_t numDigits(int number); // объявление функции</code></p>
<p><code>class Widget; // объявление класса</code></p>
<p><code>template&lt;typename T&gt; // объявление шаблона</code></p>
<p><code><code>class GraphNode; // (см. правило 42 о том, что такое «typename»</code></code></p>
<empty-line/><p>Заметьте, что я называю целое число x «объектом», несмотря на то что это переменная встроенного типа. Некоторые люди под «объектами» понимают только переменные пользовательских типов, но я не принадлежу к их числу. Также отметим, что функция numDigits() возвращает тип std::size_t, то есть тип size_t из пространства имен std. Это то пространство имен, в котором находится почти все из стандартной библиотеки C++. Однако, поскольку стандартная библиотека C (точнее говоря, С89) также может быть использована в программе на C++, символы, унаследованные от C (такие как size_t), могут существовать в глобальном контексте, внутри std, либо в обоих местах, в зависимости от того, какие заголовочные файлы были включены директивой #include. В этой книге я предполагаю, что с помощью #include включаются заголовочные файлы C++. Вот почему я употребляю std::size_t, а не просто size_t. Когда я упоминаю компоненты стандартной библиотеки вне текста программы, то обычно опускаю ссылку на std, полагая, что вы знаете, что такие вещи, как size_t, vector и cout, находятся в пространстве имен std. В примерах же программ я всегда включаю std, потому что в противном случае код не скомпилируется.</p>
<p>Кстати, size_t – это всего-навсего определенный директивой typedef синоним для некоторых беззнаковых типов, которые в C++ используются для разного рода счетчиков (например, количества символов в строках типа char*, количества элементов в контейнерах STL и т. п.). Это также тип, принимаемый функциями operator[] в векторах (vector), деках (deque) и строках (string). Этому соглашению мы будем следовать и при определении наших собственных функций operator[] в правиле 3.</p>
<p>В любом объявлении функции указывается ее <strong>сигнатура,</strong> то есть типы параметров и возвращаемого значения. Можно сказать, что сигнатура функции – это ее тип. Так, сигнатурой функции numDigits является std::size_t(int), иными словами, это «функция, принимающая int и возвращающая std::size_t». Официальное определение «сигнатуры» в C++ не включает тип возвращаемого функцией значения, но в этой книге нам будет удобно считать, что он все же является частью сигнатуры.</p>
<p><strong>Определение</strong> (definition) сообщает компилятору детали, которые опущены в объявлении. Для объекта определение – это то место, где компилятор выделяет для него память. Для функции или шаблона функции определение содержит тело функции. В определении класса или шаблона класса перечисляются его члены:</p>
<empty-line/><p><code>int x; // определение объекта</code></p>
<p><code>std::size_t numDigits(int number) // определение функции</code></p>
<p><code>{ // (эта функция возвращает количество</code></p>
<p><code>std::size_t digitsSoFar = 1; // десятичных знаков в своем параметре)</code></p>
<p><code>while((number /= 10) != 0) ++digitsSoFar;</code></p>
<p><code>return digitsSoFar;</code></p>
<p><code>}</code></p>
<p><code>class Widget { // определение класса</code></p>
<p><code>public:</code></p>
<p><code>Widget();</code></p>
<p><code>~Widget();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>template&lt;typename T&gt; // определение шаблона</code></p>
<p><code>class GraphNode {</code></p>
<p><code>public:</code></p>
<p><code>GraphNode();</code></p>
<p><code>~GraphNode();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p><strong>Инициализация</strong> (initialization) – это процесс присваивания объекту начального значения. Для объектов пользовательских типов инициализация выполняется конструкторами. <strong>Конструктор по умолчанию</strong> (default constructor) – это конструктор, который может быть вызван без аргументов. Такой конструктор либо не имеет параметров вовсе, либо имеет значение по умолчанию для каждого параметра:</p>
<empty-line/><p><code>class A {</code></p>
<p><code>public:</code></p>
<p><code>A(); // конструктор по умолчанию</code></p>
<p><code>};</code></p>
<p><code>class B {</code></p>
<p><code>public:</code></p>
<p><code>explicit B(int x = 0; bool b = true); // конструктор по умолчанию,</code></p>
<p><code>}; // см. далее объяснение</code></p>
<p><code>// ключевого слова “explicit”</code></p>
<p><code>class C {</code></p>
<p>public:</p>
<p><code>explicit C(int x); // это не конструктор по</code></p>
<p><code><code>// умолчанию</code></code></p>
<p><code>};</code></p>
<empty-line/><p>Конструкторы классов B и C объявлены в ключевым словом explicit (явный). Это предотвращает их использование для неявных преобразований типов, хотя не запрещает применения, если преобразование указано явно:</p>
<empty-line/><p><code>void doSomething(B bObject); // функция принимает объект типа B</code></p>
<p><code>B bObj1; // объект типа B</code></p>
<p><code>doSomething(bObj1); // нормально, B передается doSomething</code></p>
<p><code>B bObj(28); // нормально, создает B из целого 28</code></p>
<p><code>// (параметр bool по умолчанию true)</code></p>
<p><code>doSomething(28); // ошибка! doSomething принимает B,</code></p>
<p><code>// а не int, и не существует неявного</code></p>
<p><code>// преобразования из int в B</code></p>
<p><code>doSomething(B(28)); // нормально, используется конструктор</code></p>
<p><code>// B для явного преобразования (приведения)</code></p>
<p><code>// int в B (см. в правиле 27 информацию</code></p>
<p><code>// о приведении типов)</code></p>
<empty-line/><p>Конструкторы, объявленные как explicit, обычно более предпочтительны, потому что предотвращают выполнение компиляторами неявных преобразований типа (часто нежелательных). Если нет основательной причины для использования конструкторов в неявных преобразованиях типов, я всегда объявляю их explicit. Советую и вам придерживаться того же принципа.</p>
<p>Обратите внимание, что в предшествующем примере приведение выделено. Я и дальше буду использовать такое выделение, чтобы подчеркнуть важность излагаемого материала. (Также я выделяю номера глав, но это только потому, что мне кажется, это выглядит симпатично.)</p>
<p><strong>Конструктор копирования</strong> (copy constructor) используется для инициализации объекта значением другого объекта того же самого типа, а <strong>копирующий оператор присваивания</strong> (copy assignment operator) применяется для копирования значения одного объекта в другой – того же типа:</p>
<empty-line/><p><code>class Widget {</code></p>
<p><code>public:</code></p>
<p><code>Widget(); // конструктор по умолчанию</code></p>
<p><code>Widget(const Widget&amp; rhs); // конструктор копирования</code></p>
<p><code>Widget&amp; operator=(const Widget&amp; rhs); // копирующий оператор присваивания</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>Widget w1; // вызов конструктора по умолчанию</code></p>
<p><code>Widget w2(w1); // вызов конструктора копирования</code></p>
<p><code>w1 = w2; // вызов оператора присваивания</code></p>
<p><code>// копированием</code></p>
<empty-line/><p>Будьте внимательны, когда видите конструкцию, похожую на присваивание, потому что синтаксис «=» также может быть использован для вызова конструктора копирования:</p>
<empty-line/><p><code>Widget w3 = w2; // вызов конструктора копирования!</code></p>
<empty-line/><p>К счастью, конструктор копирования легко отличить от присваивания. Если новый объект определяется (как w3 в последнем предложении), то должен вызываться конструктор, это не может быть присваивание. Если же никакого нового объекта не создается (как в «w1=w2»), то конструктор не применяется и это – присваивание.</p>
<p>Конструктор копирования – особенно важная функция, потому что она определяет, как объект передается по значению. Например, рассмотрим следующий фрагмент:</p>
<empty-line/><p><code>bool hasAcceptableQuality(Widget w);</code></p>
<p><code>...</code></p>
<p><code>Widget aWidget;</code></p>
<p><code>if (hasAcceptableQuality(aWidget)) ...</code></p>
<empty-line/><p>Параметр w передается функции hasAcceptableQuality по значению, поэтому в приведенном примере вызова aWidget копируется в w. Копирование осуществляется конструктором копирования из класса Widget. Вообще передача по значению <emphasis>означает</emphasis> вызов конструктора копирования. (Но, строго говоря, передавать пользовательские типы по значению – плохая идея. Обычно лучший вариант – передача по ссылке на константу, подробности см. в правиле 20.)</p>
<p><strong>STL</strong> – стандартная библиотека шаблонов (Standard Template Library) – это часть стандартной библиотеки, касающаяся контейнеров (то есть vector, list, set, map и т. д.), итераторов (то есть vector&lt;int&gt;::iterator, set&lt;string&gt;::iterator и т. д.), алгоритмов (то есть for_each, find, sort и т. д.) и всей связанной с этим функциональности. В ней очень широко используются <strong>объекты-функции</strong> (function objects), то есть объекты, ведущие себя подобно функциям. Такие объекты представлены классами, в которых перегружен оператор вызова operator(). Если вы не знакомы с STL, вам понадобится, помимо настоящей книги, какое-нибудь достойное руководство, посвященное этой теме, ведь библиотека STL настолько удобна, что не воспользоваться ее преимуществами было бы непростительно. Стоит лишь начать работать с ней, и вы сами это почувствуете.</p>
<p>Программистам, пришедшим к C++ от языков вроде Java или C#, может показаться странным понятие <strong>неопределенного поведения.</strong> По различным причинам поведение некоторых конструкций в C++ действительно не определено: вы не можете уверенно предсказать, что произойдет во время исполнения. Вот два примера такого рода:</p>
<empty-line/><p><code>int *p = 0; // p – нулевой указатель</code></p>
<p><code>std::cout &lt;&lt; *p; // разыменование нулевого указателя</code></p>
<p><code>char name[] = “Daria” // name – массив длины 6 (не забудьте про</code></p>
<p><code>// завершающий нуль!)</code></p>
<p><code>char c = name[10]; // указание неправильного индекса массива</code></p>
<p><code>// порождает неопределенное поведение</code></p>
<empty-line/><p>Дабы подчеркнуть, что результаты неопределенного поведения невозможно предсказать и что они могут быть весьма неприятны, опытные программисты на C++ часто говорят, что программы с неопределенным поведением могут стереть содержимое жесткого диска. Это правда: такая программа <emphasis>может</emphasis> стереть ваш жесткий диск, но может этого и не сделать. Более вероятно, что она будет вести себя по-разному: иногда нормально, иногда аварийно завершаться, а иногда – просто выдавать неправильные результаты. Мудрые программисты на C++ придерживаются правила – избегать неопределенного поведения. В этой книге во многих местах я указываю, как это сделать.</p>
<p>Иной термин, который может смутить программистов, пришедших из других языков, – это <strong>интерфейс.</strong> В Java и. NET-совместимых языках интерфейсы являются частью языка, но в C++ ничего подобного нет, хотя в правиле 31 рассматривается некоторое приближение. Когда я использую термин «интерфейс», то обычно имею в виду сигнатуры функций, доступные члены класса («открытый интерфейс», «защищенный интерфейс», «закрытый интерфейс») или выражения, допустимые в качестве параметров типа для шаблонов (см. правило 41). То есть под интерфейсом я понимаю общую концепцию проектирования.</p>
<p>Понятие <strong>клиент</strong> – это нечто или некто, использующий написанный вами код (обычно через интерфейсы). Так, например, клиентами функции являются ее пользователи: части кода, которые вызывают функцию (или берут ее адрес), а также люди, которые пишут и сопровождают такой код. Клиентами класса или шаблона являются части программы, использующие этот класс или шаблон, а равно программисты, которые пишут или сопровождают эти части. Когда речь заходит о клиентах, я обычно имею в виду программистов, поскольку именно они могут быть введены в заблуждение или недовольство плохо разработанным интерфейсом. Коду, который они пишут, такие эмоции недоступны.</p>
<p>Возможно, вы не привыкли думать о клиентах, но я постараюсь убедить вас в необходимости облегчить им жизнь, насколько это возможно. В конце концов, вы сами – клиент программного обеспечения, которое разрабатывал кто-то другой. Ведь вы хотели бы, чтоб его авторы облегчили вам работу? Помимо того, рано или поздно вы окажетесь в положении, когда сами станете клиентом собственного кода (то есть будете использовать код, написанный вами), и тогда оцените, что при разработке интерфейсов нужно помнить об интересах клиентов.</p>
<p>В этой книге я часто обращаю внимание на различие между функциями и шаблонами функций, а также между классами и шаблонами классов. Это не случайно, ведь то, что справедливо для одного, часто справедливо и для другого. В ситуациях, когда это не так, я делаю различие между классами, функциями и шаблонами, из которых порождаются классы и функции.</p>
</section><section><title><p>Соглашения об именах</p>
</title><p>Я пытался выбирать осмысленные имена для объектов, классов, функций, шаблонов и т. п., но семантика некоторых придуманных мной имен может быть для вас неочевидна. Например, я часто использую для параметров имена lhs и rhs. Имеется в виду соответственно «левая часть» (left-hand side) и «правая часть» (right-hand side). Эти имена обычно употребляются в функциях, реализующих бинарные операторы, то есть operator== и operator*. Например, если a и b – объекты, представляющие рациональные числа, и если объекты класса Rational можно перемножать с помощью функции-нечлена operator*() (подобный случай описан в правиле 24), то выражение</p>
<empty-line/><p><code>a*b</code></p>
<empty-line/><p>эквивалентно вызову функции:</p>
<empty-line/><p><code>operator*(a, b);</code></p>
<empty-line/><p>В правиле 24 я объявляю operator* следующим образом:</p>
<empty-line/><p><code>const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs);</code></p>
<empty-line/><p>Как видите, левый операнд – a – внутри функции называется lhs, а правый – b – rhs.</p>
<p>Для функций-членов аргумент в левой части оператора представлен указателем this, а единственный оставшийся параметр я иногда называю rhs. Возможно, вы заметили это в объявлении некоторых функций-членов класса Widget в примерах выше. «Widget» не значит ничего. Это просто имя, которое я иногда использую для того, чтобы как-то назвать пример класса. Оно не имеет никакого отношения к элементам управления (виджетам), применяемым в графических интерфейсах (GUI).</p>
<p>Часто я именую указатели, следуя соглашению, с соответствии с которым указатель на объект типа T называется pt («pointer to T»). Вот некоторые примеры:</p>
<empty-line/><p><code>Widget *pw; // pw = указатель на Widget</code></p>
<p><code>class Airplane;</code></p>
<p><code>Airplane *pa; // pa = указатель на Airplane</code></p>
<p><code>class GameCharacter;</code></p>
<p><code>GameCharacter *pgc; // pgc = указатель на GameCharacter</code></p>
<empty-line/><p>Похожее соглашение применяется и для ссылок: rw может быть ссылкой на Widget, а ra – ссылкой на Airplane.</p>
<p>Иногда для именования функции-члена я использую имя mf.</p>
</section><section><title><p>Многопоточность</p>
</title><p>В самом языке C++ нет представления о потоках (threads), да и вообще о каких-либо механизмах параллельного исполнения. То же относится и к стандартной библиотеке C++. Иными словами, с точки зрения C++ многопоточных программ не существует.</p>
<p>Однако они есть. Хотя в этой книге я буду говорить преимущественно о стандартном, переносимом C++, но невозможно игнорировать тот факт, что безопасность относительно потоков – требование, с которым сталкиваются многие программисты. Признавая этот конфликт между стандартным C++ и реальностью, я буду отмечать те случаи, когда рассматриваемые конструкции могут вызвать проблемы при работе в многопоточной среде. Не надо думать, что эта книга научит вас многопоточному программированию на C++. Вовсе нет. Я рассматривал главным образом однопоточные приложения, но не игнорировал существование многопоточности и старался отмечать те случаи, когда программисты, пишущие многопоточные программы, должны следовать моим советам с осторожностью.</p>
<p>Если вы не знакомы с концепцией многопоточности и не интересуетесь этой темой, то можете не обращать внимания на относящиеся к ней замечания. В противном случае имейте в виду, что мои комментарии – не более, чем скромный намек на то, что необходимо знать, если вы собираетесь использовать C++ для написания многопоточных программ.</p>
</section><section><title><p>Библиотеки TR1 и Boost</p>
</title><p>Ссылки на библиотеки TR1 и Boost вы будете встречать на протяжении всей этой книги. Каждой из них посвящено отдельное правило (54 – TR1 и 55 – Boost), но, к сожалению, они находятся в самом конце книги. При желании можете прочесть их прямо сейчас, но если вы предпочитаете читать книгу по порядку, а не с конца, то следующие замечания помогут понять, о чем идет речь:</p>
<p>• TR1 ("Technical Report 1") – это спецификация новой функциональности, добавленной в стандартную библиотеку C++. Она оформлена в виде новых шаблонов классов и функций, предназначенных для реализации хэш-таблиц, «интеллектуальных» указателей с подсчетом ссылок, регулярных выражений и многого другого. Все компоненты TR1 находятся в пространстве имен tr1, которое вложено в пространство имен std.</p>
<p>• Boost – это организация и Web-сайт (<a l:href="http://boost.org/">http://boost.org</a>), на котором предлагаются переносимые, тщательно проверенные библиотеки C++ с открытым исходным кодом. Большая часть TR1 базируется на работе, выполненной Boost, и до тех пор, пока поставщики компиляторов не включат TR1 в дистрибутивы C++, Web-сайт Boost будет оставаться для разработчиков главным источником реализаций TR1. Boost предоставляет больше, чем включено в TR1, однако в любом случае о нем полезно знать.</p>
</section></section><section><title><p>Глава 1</p>
<p>Приучайтесь к C++</p>
</title><section><p>Независимо от опыта программирования, для того чтобы освоиться с C++, потребуется некоторое время. Это мощный язык с очень широким диапазоном возможностей, но чтобы использовать их эффективно, нужно несколько изменить свой способ мышления. Книга как раз и призвана помочь вам в этом, но какие-то вопросы являются более важными, какие-то – менее, а эта глава посвящна самым важным вещам.</p>
</section><section><title><p>Правило 1: Относитесь к C++ как к конгломерату языков</p>
</title><p>Поначалу C++ был просто языком C с добавлением некоторых объектно-ориентированных средств. Даже первоначальное название C++ («C с классами») отражает эту связь.</p>
<p>По мере того как язык становился все более зрелым, он рос и развивался, в него включались идеи и стратегии программирования, выходящие за рамки C с классами. Исключения потребовали другого подхода к структурированию функций (см. правило 29). Шаблоны изменили наши представления о проектировании программ (см. правило 41), а библиотека STL определила подход к расширяемости, который никто ранее не мог себе представить.</p>
<p>Сегодня C++ – это язык <emphasis>программирования с несколькими парадигмами,</emphasis> поддерживающий процедурное, объектно-ориентированное, функциональное, обобщенное и метапрограммирование. Эти мощь и гибкость делают C++ несравненным инструментом, однако могут привести в замешательство. У любой рекомендации по «правильному применению» есть исключения. Как найти смысл в таком языке?</p>
<p>Лучше всего воспринимать C++ не как один язык, а как конгломерат взаимосвязанных языков. В пределах отдельного подъязыка правила достаточно просты, понятны и легко запоминаются. Однако когда вы переходите от одного подъязыка к другому, правила могут изменяться. Чтобы увидеть смысл в C++, вы должны распознавать его основные подъязыки. К счастью, их всего четыре:</p>
<p><strong>• C.</strong> В глубине своей C++ все еще основан на C. Блоки, предложения, препроцессор, встроенные типы данных, массивы, указатели и т. п. – все это пришло из C. Во многих случаях C++ предоставляет для решения тех или иных задач более развитые механизмы, чем C (пример см. в правиле 2 – альтернатива препроцессору и 13 – применение объектов для управления ресурсами), но когда вы начнете работать с той частью C++, которая имеет аналоги в C, то поймете, что правила эффективного программирования отражают более ограниченный характер языка C: никаких шаблонов, никаких исключений, никакой перегрузки и т. д.</p>
<p>• <strong>Объектно-ориентированный C++.</strong> Эта часть C++ представляет то, чем был «C с классами», включая конструкторы и деструкторы, инкапсуляцию, наследование, полиморфизм, виртуальные функции (динамическое связывание) и т. д. Это та часть C++, к которой в наибольшей степени применимы классические правила объектно-ориентированного проектирования.</p>
<p>• <strong>C++ с шаблонами.</strong> Эта часть C++ называется обобщенным программированием, о ней большинство программистов знают мало. Шаблоны теперь пронизывают C++ снизу доверху, и признаком хорошего тона в программировании уже стало включение конструкций, немыслимых без шаблонов (например, см. правило 46 о преобразовании типов при вызовах шаблонных функций). Фактически шаблоны, благодаря своей мощи, породили совершенно новую парадигму программирования: <emphasis>метапрограммирование шаблонов</emphasis> (template metaprogramming – TMP). В правиле 48 представлен обзор TMP, но если вы не являетесь убежденным фанатиком шаблонов, у вас нет причин чрезмерно задумываться об этом. TMP не отнесешь к самым распространенным приемам программирования на C++.</p>
<p>• <strong>STL.</strong> STL – это, конечно, библиотека шаблонов, но очень специализированная. Принятые в ней соглашения относительно контейнеров, итераторов, алгоритмов и функциональных объектов великолепно сочетаются между собой, но шаблоны и библиотеки можно строить и по-другому. Работая с библиотекой STL, вы обязаны следовать ее соглашениям.</p>
<p>Помните об этих четырех подъязыках и не удивляйтесь, если попадете в ситуацию, когда соображения эффективности программирования потребуют от вас менять стратегию при переключении с одного подъязыка на другой. Например, для встроенных типов (в стиле C) передача параметров по значению в общем случае более эффективна, чем передача по ссылке, но если вы программируете в объектно-ориентированном стиле, то из-за наличия определенных пользователем конструкторов и деструкторов передача по ссылке на константу обычно становится более эффективной. В особенности это относится к подъязыку «C++ с шаблонами», потому что там вы обычно даже не знаете заранее типа объектов, с которыми имеете дело. Но вот вы перешли к использованию STL, и опять старое правило C о передаче по значению становится актуальным, потому что итераторы и функциональные объекты смоделированы через указатели C. (Подробно о выборе способа передачи параметров см. правило 20.)</p>
<p>Таким образом, C++ не является однородным языком с единственным набором правил. Это – конгломерат подъязыков, каждый со своими собственными соглашениями. Если вы будете помнить об этих подъязыках, то обнаружите, что понять C++ намного проще.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Правила эффективного программирования меняются в зависимости от части C++, которую вы используете.</p>
</section><section><title><p>Правило 2: Предпочитайте const, enum и inline использованию #define</p>
</title><p>Это правило лучше было бы назвать «Компилятор предпочтительнее препроцессора», поскольку #define зачастую вообще не относят к языку C++. В этом и заключается проблема. Рассмотрим простой пример; попробуйте написать что-нибудь вроде:</p>
<empty-line/><p><code>#define ASPECT_RATIO 1.653</code></p>
<empty-line/><p>Символическое имя ASPECT_RATIO может так и остаться неизвестным компилятору или быть удалено препроцессором до того, как код поступит на обработку компилятору. Если это произойдет, то имя ASPECT_RATIO не попадет в таблицу символов. Поэтому в ходе компиляции вы получите ошибку (в сообщении о ней будет упомянуто значение 1.653, а не ASPECT_RATIO). Это вызовет путаницу. Если имя ASPECT_RATIO было определено в заголовочном файле, который писали не вы, то вы вообще не будете знать, откуда взялось значение 1.653, и на поиски ответа потратите много времени. Та же проблема может возникнуть и при отладке, поскольку выбранное вами имя будет отсутствовать в таблице символов.</p>
<p>Решение состоит в замене макроса константой:</p>
<empty-line/><p><code>const double AspectRatio = 1.653; // имена, записанные большими буквами,</code></p>
<p><code>// обычно применяются для макросов,</code></p>
<p><code>// поэтому мы решили его изменить</code></p>
<empty-line/><p>Будучи языковой константой, AspectRatio видима компилятору и, естественно, помещается в таблицу символов. К тому же в случае использования константы с плавающей точкой (как в этом примере) генерируется более компактный код, чем при использовании #define. Дело в том, что препроцессор, слепо подставляя вместо макроса ASPECT_RATIO величину 1.653, создает множество копий 1.653 в объектном коде, в то время как использование константы никогда не породит более одной копии этого значения.</p>
<p>При замене #define константами нужно помнить о двух особых случаях. Первый касается константных указателей. Поскольку определения констант обычно помещаются в заголовочные файлы (где к ним получает доступ множество различных исходных файлов), важно, чтобы сам <emphasis>указатель</emphasis> был объявлен с ключевым словом const, в дополнение к объявлению const того, на что он указывает. Например, чтобы объявить в заголовочном файле константную строку типа char*, слово const нужно написать <emphasis>дважды:</emphasis></p>
<empty-line/><p><code>const char * const authorName = “Scott Meyers”;</code></p>
<empty-line/><p>Более подробно о сущности и применений слова const, особенно в связке с указателями, см. в правиле 3. Но уже сейчас стоит напомнить, что объекты типа string обычно предпочтительнее своих прародителей – строк типа char *, поэтому authorName лучше определить так:</p>
<empty-line/><p><code>const std::string authorName(“Scott Meyers”);</code></p>
<empty-line/><p>Второе замечание касается констант, объявляемых в составе класса. Чтобы ограничить область действия константы классом, необходимо сделать ее членом класса, и чтобы гарантировать, что существует только одна копия константы, требуется сделать ее <emphasis>статическим</emphasis> членом:</p>
<empty-line/><p><code>class GamePlayer {</code></p>
<p><code>private:</code></p>
<p><code>static const int NumTurns = 5; // объявление константы</code></p>
<p><code>int scores[NumTurns]; // использование константы</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>То, что вы видите выше, – это <emphasis>объявление</emphasis> NumTurns, а не ее определение. Обычно C++ требует, чтобы вы представляли определение для всего, что используете, но объявленные в классе константы, которые являются статическими и имеют встроенный тип (то есть целые, символьные, булевские) – это исключение из правил. До тех пор пока вы не пытаетесь получить адрес такой константы, можете объявлять и использовать ее без предоставления определения. Если же вам нужно получить адрес либо если ваш компилятор настаивает на наличии определения, то можете написать что-то подобное:</p>
<empty-line/><p><code>const int GamePlayer::NumTurns; // определение NumTurns; см. ниже,</code></p>
<p><code>// почему не указывается значение</code></p>
<empty-line/><p>Поместите этот код в файл реализации, а не в заголовочный файл. Поскольку начальное значение константы класса представлено там, где она объявлена (то есть NumTurns инициализировано значением 5 при объявлении), то в точке определения задавать начальное значение не требуется.</p>
<p>Отметим, кстати, что нет возможности объявить в классе константу посредством #define, потому что #define не учитывает области действия. Как только макрос определен, он остается в силе для всей оставшейся части компилируемого кода (если только где-то ниже не встретится #undef). Это значит, что директива #define неприменима не только для объявления констант в классе, но вообще не может быть использована для обеспечения какой бы то ни было инкапсуляции, то есть придать смысл выражению «private #define» невозможно. В то же время константные данные-члены могут быть инкапсулированы, примером может служить NumTurns.</p>
<p>Старые компиляторы могут не поддерживать показанный выше синтаксис, так как в более ранних версиях языка было запрещено задавать значения статических членов класса во время объявления. Более того, инициализация в классе допускалась только для целых типов и для констант. Если вышеприведенный синтаксис не работает, то начальное значение следует задавать в определении:</p>
<empty-line/><p><code>class CostEstimate {</code></p>
<p><code>private:</code></p>
<p><code>static const double FudgeFactor; // объявление статической константы</code></p>
<p><code>... // класса – помещается в файл заголовка</code></p>
<p><code>};</code></p>
<p><code>const double // определение статической константы</code></p>
<p><code>CostEstimate::FudgeFactor = 1.35; // класса – помещается в файл реализации</code></p>
<empty-line/><p>Обычно ничего больше и не требуется. Единственное исключение обнаруживается тогда, когда для компиляции класса необходима константа. Например, при объявлении массива GamePlayer::scores компилятору нужно знать размер массива. Чтобы работать с компилятором, ошибочно запрещающим инициализировать статические целые константы внутри класса, можно воспользоваться способом, известным под названием «трюка с перечислением». Он основан на том, что переменные перечисляемого типа можно использовать там, где ожидаются значения типа int, поэтому GamePlayer можно определить так:</p>
<empty-line/><p><code>class GamePlayer {</code></p>
<p><code>private:</code></p>
<p><code>enum ( NumTurns = 5 }; // “трюк с перечислением” – делает из</code></p>
<p><code>// NumTurns символ со значением 5</code></p>
<p><code>int scores[NumTurns]; // нормально</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Этот прием стоит знать по нескольким причинам. Во-первых, поведение «трюка с перечислением» в некоторых отношениях более похоже на #define, чем на константу, а иногда это как раз то, что нужно. Например, можно получить адрес константы, но нельзя получить адрес перечисления, как нельзя получить и адрес #define. Если вы хотите запретить получать адрес или ссылку на какую-нибудь целую константу, то применение enum – хороший способ наложить такое ограничение. (Подробнее о поддержке проектных ограничений с помощью приемов кодирования можно узнать из правила 18). К тому же, хотя хорошие компиляторы не выделяют память для константных объектов целых типов (если только вы не создаете указателя или ссылки на объект), менее изощренные могут так поступать, а вам это, возможно, ни к чему. Как и #define, перечисления никогда не станут причиной подобного нежелательного распределения памяти.</p>
<p>Вторая причина знать о «трюке с перечислением» чисто прагматическая. Он используется в очень многих программах, поэтому нужно уметь распознавать этот трюк, когда вы с ним сталкиваетесь. Вообще говоря, этот прием – фундаментальная техника, применяемая при метапрограммировании шаблонов (см. правило 48).</p>
<p>Вернемся к препроцессору. Другой частый случай неправильного использования директивы #define – создание макросов, которые выглядят как функции, но не обременены накладными расходов, связанными с вызовом функций. Ниже представлен макрос, который вызывает некоторую функцию f c аргументом, равным максимальному из двух значений:</p>
<empty-line/><p><code>// вызвать f, передав ей максимум из a и b</code></p>
<p><code>#define CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</code></p>
<empty-line/><p>В этой строчке содержится так много недостатков, что даже не совсем понятно, с какого начать.</p>
<p>Всякий раз при написании подобного макроса вы должны помнить о том, что все аргументы следует заключать в скобки. В противном случае вы рискуете столкнуться с проблемой, когда кто-нибудь вызовет его с выражением в качестве аргумента. Но даже если вы сделаете все правильно, посмотрите, какие странные вещи могут произойти:</p>
<empty-line/><p><code>int a = 5, b = 0;</code></p>
<p><code>CALL_WITH_MAX(++a, b); // a увеличивается дважды</code></p>
<p><code>CALL_WITH_MAX(++a, b+10); // a увеличивается один раз</code></p>
<empty-line/><p>Происходящее внутри max зависит от того, с чем она сравнивается!</p>
<p>К счастью, вы нет нужды мириться с поведением, так сильно противоречащим привычной логике. Существует метод, позволяющий добиться такой же эффективности, как при использовании препроцессора. Но при этом обеспечивается как предсказуемость поведения, так и контроль типов аргументов (что характерно для обычных функций). Этот результат достигается применением шаблона встроенной (inline) функции (см. правило 30):</p>
<empty-line/><p><code>template &lt;typename T&gt;</code></p>
<p><code>inline void callWithMax(const T&amp; a, const T&amp; b) // Поскольку мы не знаем,</code></p>
<p><code>{ // что есть T, то передаем</code></p>
<p><code>f(a &gt; b ? a : b); // его по ссылке на const -</code></p>
<p><code>} // см. параграф 20</code></p>
<empty-line/><p>Этот шаблон генерирует целое семейство функций, каждая из которых принимает два аргумента одного и того же типа и вызывает f с наибольшим из них. Нет необходимости заключать параметры в скобки внутри тела функции, не нужно заботиться о многократном вычислении параметров и т. д. Более того, поскольку callWithMax – настоящая функция, на нее распространяются правила областей действия и контроля доступа. Например, можно говорить о встроенной функции, являющейся закрытым членом класса. Описать нечто подобное с помощью макроса невозможно.</p>
<p>Наличие const, enum и inline резко снижает потребность в препроцессоре (особенно это относится к #define), но не устраняет ее полностью. Директива #include остается существенной, а #ifdef/#ifndef продолжают играть важную роль в управлении компиляцией. Пока еще не время отказываться от препроцессора, но определенно стоит задуматься, как избавиться от него в дальнейшем.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Для простых констант директиве #define следует предпочесть константные объекты и перечисления (enum).</p>
<p>• Вместо имитирующих функции макросов, определенных через #define, лучше применять встроенные функции.</p>
</section><section><title><p>Правило 3: Везде, где только можно используйте const</p>
</title><section><p>Замечательное свойство модификатора const состоит в том, что он накладывает определенное семантическое ограничение: данный объект не должен модифицироваться, – и компилятор будет проводить это ограничение в жизнь. const позволяет указать компилятору и программистам, что определенная величина должна оставаться неизменной. Во всех подобных случаях вы должны обозначить это явным образом, призывая себе на помощь компилятор и гарантируя тем самым, что ограничение не будет нарушено.</p>
<p>Ключевое слово const удивительно многосторонне. Вне классов вы можете использовать его для определения констант в глобальной области или в пространстве имен (см. правило 2), а также для статических объектов (внутри файла, функции или блока). Внутри классов допустимо применять его как для статических, так и для нестатических данных-членов. Для указателей можно специфицировать, должен ли быть константным сам указатель, данные, на которые он указывает, либо и то, и другое (или ни то, ни другое):</p>
<empty-line/><p><code>char greeting[] = “Hello”;</code></p>
<p><code>char *p = greeting; // неконстантный указатель,</code></p>
<p><code>// неконстантные данные</code></p>
<p><code>const char *p = greeting; // неконстантный указатель,</code></p>
<p><code>// константные данные</code></p>
<p><code>char * const p = greeting; // константный указатель,</code></p>
<p><code>// неконстантные данные</code></p>
<p><code>const char * const p = greeting; // константный указатель,</code></p>
<p><code>// константные данные</code></p>
<empty-line/><p>Этот синтаксис не так страшен, как может показаться. Если слово const появляется слева от звездочки, константным является то, на что указывает указатель; если справа, то сам указатель является константным. Наконец, если же слово const появляется с обеих сторон, то константно и то, и другое.</p>
<p>Когда то, на что указывается, – константа, некоторые программисты ставят const перед идентификатором типа. Другие – после идентификатора типа, но перед звездочкой. Семантической разницы здесь нет, поэтому следующие функции принимают параметр одного и того же типа:</p>
<empty-line/><p><code>void f1(const Widget *pw); // f1 принимает указатель на</code></p>
<p><code>// константный объект Widget</code></p>
<p><code>void f1(Widget const *pw); // то же самое делает f2</code></p>
<empty-line/><p>Поскольку в реальном коде встречаются обе формы, следует привыкать и к той, и к другой.</p>
<p>Итераторы STL смоделированы на основе указателей, поэтому iterator ведет себя почти как указатель T*. Объявление const-итератора подобно объявлению const-указателя (то есть записи T* const): итератор не может начать указывать на что-то другое, но то, на что он указывает, может быть модифицировано. Если вы хотите иметь итератор, который указывал бы на нечто, что запрещено модифицировать (то есть STL-аналог указателя const T*), то вам понадобится константный итератор:</p>
<empty-line/><p><code>std::vector&lt;int&gt; vec;</code></p>
<p><code>...</code></p>
<p><code>const std::vector&lt;int&gt;::iterator iter = // iter работает как T* const</code></p>
<p><code>vec.begin();</code></p>
<p><code>*iter = 10; // Ok, изменяется то, на что</code></p>
<p><code>// указывает iter</code></p>
<p><code>++iter; // ошибка! iter константный</code></p>
<p><code>std::vector&lt;int&gt;::const_iterator citer = // citer работает как const T*</code></p>
<p><code>vec.begin();</code></p>
<p><code>*citer = 10; // ошибка! *citer константный</code></p>
<p><code>++citer; // нормально, citer изменяется</code></p>
<empty-line/><p>Некоторые из наиболее интересных применений const связаны с объявлениями функций. В этом случае const может относиться к возвращаемому функцией значению, к отдельным параметрам, а для функций-членов – еще и к функции в целом.</p>
<p>Если указать в объявлении функции, что она возвращает константное значение, то можно уменьшить количество ошибок в клиентских программах, не снижая уровня безопасности и эффективности. Например, рассмотрим объявление функции operator* для рациональных чисел, введенное в правиле 24:</p>
<empty-line/><p><code>class Rational {…}</code></p>
<p><code>const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs);</code></p>
<empty-line/><p>Многие программисты удивятся, впервые увидев такое объявление. Почему результат функции operator* должен быть константным объектом? Потому что в противном случае пользователь получил бы возможность делать вещи, которые иначе как надругательством над здравым смыслом не назовешь:</p>
<empty-line/><p><code>Rational a, b, c;</code></p>
<p><code>…</code></p>
<p><code>(a*b)=c; // присваивание произведению a*b!</code></p>
<empty-line/><p>Я не знаю, с какой стати программисту пришло бы в голову присваивать значение произведению двух чисел, но могу точно сказать, что иногда такое может случиться по недосмотру. Достаточно простой опечатки (при условии, что тип может быть преобразован к bool):</p>
<empty-line/><p><code>if (a*b = c)... // имелось в виду сравнение!</code></p>
<empty-line/><p>Такой код был бы совершенно некорректным, если бы a и b имели встроенный тип. Одним из критериев качества пользовательских типов является совместимость со встроенными (см. также правило 18), а возможность присваивания значения результату произведения двух объектов представляется мне весьма далекой от совместимости. Если же объявить, что operator* возвращает константное значение, то такая ситуация станет невозможной. Вот почему Так Следует Поступать.</p>
<p>В отношении аргументов с модификатором const трудно сказать что-то новое; они ведут себя как локальные константные const-объекты. Всюду, где возможно, добавляйте этот модификатор. Если модифицировать аргумент или локальный объект нет необходимости, объявите его как const. Вам всего-то придется набрать шесть символов, зато это предотвратит досадные ошибки типа «хотел напечатать ==, а нечаянно напечатал =» (к чему это приводит, мы только что видели).</p>
</section><section><title><p>Константные функции-члены</p>
</title><p>Назначение модификатора const в объявлении функций-членов – определить, какие из них можно вызывать для константных объектов. Такие функции-члены важны по двум причинам. Во-первых, они облегчают понимание интерфейса класса, ведь полезно сразу видеть, какие функции могут модифицировать объект, а какие нет. Во-вторых, они обеспечивают возможность работать с константными объектами. Это очень важно для написания эффективного кода, потому что, как объясняется в правиле 20, один из основных способов повысить производительность программ на C++ – передавать объекты по ссылке на константу. Но эта техника будет работать только в случае, когда функции-члены для манипулирования константными объектами объявлены с модификатором const.</p>
<p>Многие упускают из виду, что функции, отличающиеся только наличием const в объявлении, могут быть перегружены. Это, однако, важное свойство C++. Рассмотрим класс, представляющий блок текста:</p>
<empty-line/><p><code>class TextBlock {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>const char&amp; operator[](std::size_t position) const // operator[] для</code></p>
<p><code>{return text[position];} // константных объектов</code></p>
<p><code>char&amp; operator[](std::size_t position) // operator[] для</code></p>
<p><code>{return text[position];} // неконстантных объектов</code></p>
<p><code>private:</code></p>
<p><code>std::string text;</code></p>
<p><code>};</code></p>
<empty-line/><p>Функцию operator[] в классе TextBlock можно использовать следующим образом:</p>
<empty-line/><p><code>TextBlock tb(“Hello”);</code></p>
<p><code>Std::cout &lt;&lt; tb[0]; // вызов неконстантного</code></p>
<p><code>// оператора TextBlock::operator[]</code></p>
<p><code>const TextBlock ctb(“World”);</code></p>
<p><code>Std::cout &lt;&lt; ctb[0]; // вызов константного</code></p>
<p><code>// оператора TextBlock::operator[]</code></p>
<empty-line/><p>Кстати, константные объекты чаще всего встречаются в реальных программах в результате передачи по указателю или ссылке на константу. Приведенный выше пример ctb является довольно искусственным. Но вот вам более реалистичный:</p>
<empty-line/><p><code>void print(const TextBlock&amp; ctb) // в этой функции ctb – ссылка</code></p>
<p><code>// на константный объект</code></p>
<p><code>{</code></p>
<p><code>std::cout &lt;&lt; ctb[0]; // вызов const TextBlock::operator[]</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>Перегружая operator[] и создавая различные версии с разными возвращаемыми типами, вы можете по-разному обрабатывать константные и неконстантные объекты TextBlock:</p>
<empty-line/><p><code>std::cout &lt;&lt; tb[0]; // нормально – читается</code></p>
<p><code>// неконстантный TextBlock</code></p>
<p><code>tb[0] = ‘x’; // нормально – пишется</code></p>
<p><code>// неконстантный TextBlock</code></p>
<p><code>std::cout &lt;&lt; ctb[0]; // нормально – читается</code></p>
<p><code>// константный TextBlock</code></p>
<p><code>ctb[0] = ‘x’; // ошибка! – запись</code></p>
<p><code>// константного TextBlock</code></p>
<empty-line/><p>Отметим, что ошибка здесь связана только с типом значения, возвращаемого operator[]; сам вызов operator[] проходит нормально. Причина ошибки – в попытке присвоить значение объекту типа const char&amp;, потому что это именно такой тип возвращается константной версией operator[].</p>
<p>Отметим также, что тип, возвращаемый неконстантной версией operator[], – это ссылка на char, а не сам char. Если бы operator[] возвращал просто char, то следующее предложение не скомпилировалось бы:</p>
<empty-line/><p><code>tb[0] = ‘x’;</code></p>
<empty-line/><p>Это объясняется тем, что возвращаемое функцией значение встроенного типа модифицировать некорректно. Даже если бы это было допустимо, тот факт, что C++ возвращает объекты по значению (см. правило 20), означал бы следующее: модифицировалась <emphasis>копия</emphasis> tb.text[0], а не само значение tb.text[0]. Вряд ли это то, чего вы ожидаете.</p>
<p>Давайте немного передохнем и пофилософствуем. Что означает для функции-члена быть константной? Существует два широко распространенных понятия: <emphasis>побитовая константность</emphasis> (также известная как <emphasis>физическая константность)</emphasis> и <emphasis>логическая константность.</emphasis></p>
<p>Сторонники побитовой константности полагают, что функция-член константна тогда и только тогда, когда она не модифицирует никакие данные-члены объекта (за исключением статических), то есть не модифицирует ни одного бита внутри объекта. Определение побитовой константности хорошо тем, что ее нарушение легко обнаружить: компилятор просто ищет присваивания членам класса. Фактически, побитовая константность – это константность, определенная в C++: функция-член с модификатором const не может модифицировать нестатические данные-члены объекта, для которого она вызвана.</p>
<p>К сожалению, многие функции-члены, которые ведут себя далеко не константно, проходят побитовый тест. В частности, функция-член, которая модифицирует то, на что указывает указатель, часто не ведет себя как константная. Но если объекту принадлежит только указатель, то функция формально является побитово константной, и компилятор не станет возражать. Это может привести к неожиданному поведению. Например, предположим, что есть класс подобный Text-Block, где данные хранятся в строках типа char * вместо string, поскольку это необходимо для передачи в функции, написанные на языке C, который не понимает, что такое объекты типа string.</p>
<empty-line/><p><code>class CtextBlock {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>char&amp; operator[](std::size_t position) const // неудачное (но побитово</code></p>
<p><code>{ return pText[position]} // константное)</code></p>
<p><code>// объявление operator[]</code></p>
<p><code>private:</code></p>
<p><code>char *pText;</code></p>
<p><code>};</code></p>
<empty-line/><p>В этом классе функция operator[] (неправильно!) объявлена как константная функция-член, хотя она возвращает ссылку на внутренние данные объекта (эта тема обсуждается в правиле 28). Оставим это пока в стороне и отметим, что реализация operator[] никак не модифицирует pText. В результате компилятор спокойно сгенерирует код для функции operator[]. Ведь она действительно является побитово константной, а это все, что компилятор может проверить. Но посмотрите, что происходит:</p>
<empty-line/><p><code>const CtextBlock cctb(“Hello”); // объявление константного объекта</code></p>
<p><code>char &amp;pc = &amp;cctb[0]; // вызов const operator[] для получения</code></p>
<p><code>// указателя на данные cctb</code></p>
<p><code>*pc = ‘j’; // cctb теперь имеет значение “Jello”</code></p>
<empty-line/><p>Несомненно, есть что-то некорректное в том, что вы создаете константный объект с определенным значением, вызываете для него только константную функцию-член и тем не менее изменяете его значение!</p>
<p>Это приводит нас к понятию логической константности. Сторонники этой философии утверждают, что функции-члены с const могут модифицировать некоторые биты вызвавшего их объекта, но только так, чтобы пользователь не мог этого обнаружить. Например, ваш класс CTextBlock мог бы кэшировать длину текстового блока при каждом запросе:</p>
<empty-line/><p><code>Class CtextBlock {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>std::size_t length() const;</code></p>
<p><code>private:</code></p>
<p><code>char *pText;</code></p>
<p><code>std::size_t textLength; // последнее вычисленное значение длины</code></p>
<p><code>// текстового блока</code></p>
<p><code>bool lengthIsValid; // корректна ли длина в данный момент</code></p>
<p><code>};</code></p>
<p><code>std::size_t CtextBlock::length() const</code></p>
<p><code>{</code></p>
<p><code>if(!lengthIsValid) {</code></p>
<p><code>textLength = std::strlen(pText); // ошибка! Нельзя присваивать</code></p>
<p><code>lengthIsValid = true; // значение textLength и</code></p>
<p><code>} // lengthIsValid в константной</code></p>
<p><code>// функции-члене</code></p>
<p><code>return textLength;</code></p>
<p><code>}</code></p>
<empty-line/><p>Эта реализация length(), конечно же, не является побитово константной, поскольку может модифицировать значения членов textLength и lengthlsValid. Но в то же время со стороны кажется, что константности объектов CTextBlock это не угрожает. Однако компилятор не согласен. Он настаивает на побитовой константности. Что делать?</p>
<p>Решение простое: используйте модификатор mutable. Он освобождает нестатические данные-члены от ограничений побитовой константности:</p>
<empty-line/><p><code>Class CtextBlock {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>std::size_t length() const;</code></p>
<p><code>private:</code></p>
<p><code>char *pText;</code></p>
<p><code>mutable std::size_t textLength; // Эти данные-члены всегда могут быть</code></p>
<p><code>mutable bool lengthIsValid; // модифицированы, даже в константных</code></p>
<p><code>}; // функциях-членах</code></p>
<p><code>std::size_t CtextBlock::length() const</code></p>
<p><code>{</code></p>
<p><code>if(!lengthIsValid) {</code></p>
<p><code>textLength = std::strlen(pText); // теперь порядок</code></p>
<p><code>lengthIsValid = true; // здесь то же</code></p>
<p><code>}</code></p>
<p><code>return textLength;</code></p>
<p><code>}</code></p>
</section><section><title><p>Как избежать дублирования в константных и неконстантных функциях-членах</p>
</title><p>Использование mutable – замечательное решение проблемы, когда побитовая константность вас не вполне устраивает, но оно не устраняет всех трудностей, связанных с const. Например, представьте, что operator[] в классе TextBlock (и CTextBlock) не только возвращает ссылку на соответствующий символ, но также проверяет выход за пределы массива, протоколирует информацию о доступе и, возможно, даже проверяет целостность данных. Помещение всей этой логики в обе версии функции operator[] – константную и неконстантную (даже если забыть, что теперь мы имеем необычно длинные встроенные функции – см. правило 30) – приводит к такому вот неуклюжему коду:</p>
<empty-line/><p><code>class TextBlock {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>const char&amp; operator[](std::size_t position) const</code></p>
<p><code>{</code></p>
<p><code>... // выполнить проверку границ массива</code></p>
<p><code>... // протоколировать доступ к данным</code></p>
<p><code>... // проверить целостность данных</code></p>
<p><code>return text[position];</code></p>
<p><code>}</code></p>
<p><code>char&amp; operator[](std::size_t position) const</code></p>
<p><code>{</code></p>
<p><code>... // выполнить проверку границ массива</code></p>
<p><code>... // протоколировать доступ к данным</code></p>
<p><code>... // проверить целостность данных</code></p>
<p><code>return text[position];</code></p>
<p><code>}</code></p>
<p><code>private:</code></p>
<p><code>std:string text;</code></p>
<p><code>};</code></p>
<empty-line/><p>Ох! Налицо все неприятности, связанные с дублированием кода: увеличение времени компиляции, размера программы и неудобство сопровождения. Конечно, можно переместить весь код для проверки выхода за границы массива и прочего в отдельную функцию-член (естественно, закрытую), которую будут вызывать обе версии operator[], но обращения к этой функции все же будут дублироваться.</p>
<p>В действительности было бы желательно реализовать функциональность operator[] один раз, а использовать в двух местах. То есть одна версия operator[] должна вызывать другую. И это подводит нас к вопросу об отбрасывании константности.</p>
<p>С самого начала отметим, отбрасывать константность нехорошо. Я посвятил целое правило 27 тому, чтобы убедить вас не делать этого, но дублирование кода – тоже не сахар. В данном случае константная версия operator[] делает в точности то же самое, что неконстантная, и отличие между ними – лишь в присутствии модификатора const. В этой ситуации отбрасывать const безопасно, поскольку пользователь, вызывающий неконстантный operator[], так или иначе должен получить неконстантный объект. Ведь в противном случае он не стал бы вызывать неконстантную функцию. Поэтому реализация неконстантного operator[] путем вызова константной версии – это безопасный способ избежать дублирования кода, даже пусть даже для этого требуется воспользоваться оператором const_cast. Ниже приведен получающийся в результате код, но он станет яснее после того, как вы прочитаете следующие далее объяснения:</p>
<empty-line/><p><code>class TextBlock {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>const char&amp; operator[](std::size_t position) const // то же, что и раньше</code></p>
<p><code>{</code></p>
<p><code>...</code></p>
<p><code>...</code></p>
<p><code>...</code></p>
<p><code>return text[position];</code></p>
<p><code>}</code></p>
<p><code>char&amp; operator[](std::size_t position) const // теперь просто</code></p>
<p><code>// вызываем const op[]</code></p>
<p><code>{</code></p>
<p><code>return</code></p>
<p><code>const_cast&lt;char&amp;&gt;( // из возвращаемого типа</code></p>
<p><code>// op[] исключить const</code></p>
<p><code>static_cast&lt;const TextBlock&amp;&gt;(*this) // добавить const типу</code></p>
<p><code>// *this</code></p>
<p><code>[position] // вызвать константную</code></p>
<p><code>); // версию op[]</code></p>
<p><code>}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Как видите, код включает два приведения, а не одно. Мы хотим, чтобы неконстантный operator[] вызывал константный, но если внутри неконстантного оператора [] просто вызовем operator[], то получится рекурсивный вызов. Во избежание бесконечной рекурсии нужно указать, что мы хотим вызвать const operator[], но прямого способа сделать это не существует. Поэтому мы приводим *this от типа TextBlock&amp; к const TextBlock&amp;. Да, мы выполняем приведение, чтобы <emphasis>добавить</emphasis> константность! Таким образом, мы имеем два приведения: одно добавляет константность *this (чтобы был вызван const operator[]), а второе – исключает const из типа возвращаемого значения.</p>
<p>Приведение, которое добавляет const, выполняет безопасное преобразование (от неконстантного объекта к константному), поэтому мы используем для этой цели static_cast. Приведение же, которое отбрасывает const, может быть выполнено только с помощью const_cast, поэтому у нас здесь нет выбора. (Строго говоря, выбор есть. Приведение в стиле C также работает, но, как я объясняю в правиле 27, такие приведения редко являются правильным рещением. Если вы не знакомы с операторами static_cast или const_cast, прочитайте о них в правиле 27.)</p>
<p>Помимо всего прочего, в этом примере мы вызываем оператор, поэтому синтаксис выглядит немного странно. Возможно, этот код не займет приз на конкурсе красоты, зато позволяет достичь нужного эффекта – избежать дублирования посредством реализации неконстантной версии operator[] в терминах константной. И хотя для достижения цели пришлось воспользоваться неуклюжим синтаксисом, который сможете понять только вы сами, однако техника реализации неконстантных функций-членов через неконстантные определенно заслуживает того, чтобы ее знать.</p>
<p>А еще нужно иметь в виду, что решать эту задачу наоборот – путем вызова неконстантной версии из константной – неправильно. Помните, что константная функция-член обещает никогда не изменять логическое состояние объекта, а неконстантная не дает таких гарантий. Если вы вызовете неконстантную функцию из константной, то рискуете получить ситуацию, когда объект, который не должен модифицироваться, будет изменен. Вот почему этого не следует делать: чтобы объект не изменился. Фактически, чтобы получить компилируемый код, вам пришлось бы использовать const_cast для отбрасывания константности *this, а это явный признак неудачного решения. Обратная последовательность вызовов – такая, как описана выше, – безопасна. Неконстантная функция-член может делать все, что захочет с объектом, поэтому вызов из нее константной функции-члена ничем не грозит. Потому-то мы и применяем к *this оператор static_cast, отбрасывания константности при этом не происходит.</p>
<p>Как я уже упоминал в начале этого правила, модификатор const – чудесная вещь. Для указателей и итераторов; для объектов, на которые ссылаются указатели, итераторы и ссылки; для параметров функций и возвращаемых ими значений; для локальных переменных, для функций-членов – всюду const ваш мощный союзник. Используйте его, где только возможно. Вам понравится!</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Объявление чего-либо с модификатором const помогает компиляторам обнаруживать ошибки. const можно использовать с объектами в любой области действия, с параметрами функций и возвращаемых значений, а также с функциями-членами в целом.</p>
<p>• Компиляторы проверяют побитовую константность, но вы должны программировать, применяя логическую константность.</p>
<p>• Когда константные и неконстантные функции-члены имеют, по сути, одинаковую реализацию, то дублирования кода можно избежать, заставив неконстантную версию вызывать константную.</p>
</section></section><section><title><p>Правило 4: Прежде чем использовать объекты, убедитесь, что они инициализированы</p>
</title><p>Отношение C++ к инициализации значений объектов может показаться странным. Например, если вы пишете:</p>
<empty-line/><p><code>int x;</code></p>
<empty-line/><p>то в некоторых контекстах переменная x будет гарантированно инициализирована нулем, а в других – нет. Если вы пишете:</p>
<empty-line/><p><code>class Point {</code></p>
<p><code>int x, y;</code></p>
<p><code>};</code></p>
<p><code>...</code></p>
<p><code>Point p;</code></p>
<empty-line/><p>то члены-данные объекта p иногда будут инициализированы (нулями), а иногда – нет. Если вы перешли к C++ от языка, где неинициализированные объекты не могут существовать, обратите на это внимание.</p>
<p>Чтение неинициализированных значений может быть причиной неопределенного поведения. На некоторых платформах такое простое действие, как доступ к неинициированному значению для чтения, может вызвать аварийную остановку программы. Но чаще вы получите случайный набор битов, который испортит внутреннее состояние объекта, в который они записываются, и в конечном итоге это приведет к необъяснимому поведению программы и длительному поиску ошибки в отладчике.</p>
<p>Сформулируем правила, которые описывают, когда инициализация объекта гарантируется, а когда нет. К сожалению, эти правила достаточно сложны – на мой взгляд, слишком сложны, чтобы их стоило запоминать. Вообще, если вы работаете с C-частью C++ (см. правило 1) и инициализация может стоить определенных затрат во время исполнения, то не гарантируется, что она произойдет. Это объясняет, почему содержимое массивов (в C-части C++) не обязательно инициализируется, а содержимое вектора (из STL-части C++) инициализируется всегда.</p>
<p>По-видимому, лучший способ поведения в такой неопределенной ситуации – <emphasis>всегда</emphasis> инициализировать объекты, прежде чем их использовать. Для объектов встроенных типов, не являющихся членами классов, это нужно делать вручную. Например:</p>
<empty-line/><p><code>int x = 0; // ручная инициализация int</code></p>
<p><code>const char * text = “Строка в стиле C”; // ручная инициализация указателя</code></p>
<p><code>// (см. также правило 3)</code></p>
<p><code>double d; // «инициализация» чтением</code></p>
<p><code>std::cin &gt;&gt; d; // из входного потока</code></p>
<empty-line/><p>Почти во всех остальных случаях ответственность за инициализацию ложится на конструкторы. Правило простое: убедитесь, что все конструкторы инициализируют в объекте всё.</p>
<p>Этому правилу легко следовать, но важно не путать присваивание с инициализацией. Рассмотрим конструктор класса, представляющего записи в адресной книге:</p>
<empty-line/><p><code>class PhoneNumber {…}</code></p>
<p><code>class ABEntry { // ABEntry = “Address Book Entry”</code></p>
<p><code>public:</code></p>
<p><code>ABEntry(const std::string&amp; name, const std::string&amp; address,</code></p>
<p><code>const std::list&lt;PhoneNumber&gt;&amp; phones);</code></p>
<p><code>private:</code></p>
<p><code>std::string theName;</code></p>
<p><code>std::string theAddress;</code></p>
<p><code>std::list&lt;PhoneNumber&gt; thePhones;</code></p>
<p><code>int numTimesConsulted;</code></p>
<p><code>};</code></p>
<p><code>ABEntry(const std::string&amp; name, const std::string&amp; address,</code></p>
<p><code>const std::list&lt;PhoneNumber&gt;&amp; phones)</code></p>
<p><code>{</code></p>
<p><code>theName = name; // все это <emphasis>присваивание</emphasis>, а не инициализация</code></p>
<p><code>theAddress = address;</code></p>
<p><code>thePhones = phones;</code></p>
<p><code>numTimesConsulted = 0;</code></p>
<p><code>}</code></p>
<empty-line/><p>Да, в результате порождаются объекты ABEntry со значениями, которых вы ожидаете, но это все же не лучший подход. Правила C++ оговаривают, что члены объекта инициируются <emphasis>перед</emphasis> входом в тело конструктора. То есть внутри конструктора ABEntry члены theName, theAddress и thePhones не инициализируются, а им <emphasis>присваиваются</emphasis> значения. Инициализация происходит ранее: когда автоматически вызываются их конструкторы перед входом в тело конструктора ABEntry. Это не касается numTimesConsulted, поскольку этот член относится к встроенному типу. Для него нет никаких гарантий того, что он вообще будет инициализирован перед присваиванием.</p>
<p>Лучший способ написания конструктора ABEntry – использовать список инициализации членов вместо присваивания:</p>
<empty-line/><p><code>ABEntry(const std::string&amp; name, const std::string&amp; address,</code></p>
<p><code>const std::list&lt;PhoneNumber&gt;&amp; phones)</code></p>
<p><code>:theName(name), // теперь это все – <emphasis>инициализации</emphasis></code></p>
<p><code>:theAddress(address),</code></p>
<p><code>thePhones(phones),</code></p>
<p><code>:numTimesConsulted(0)</code></p>
<p><code>{} // тело конструктора теперь пусто</code></p>
<empty-line/><p>Этот конструктор дает тот же самый конечный результат, что и предыдущий, но часто оказывается более эффективным. Версия, основанная на присваиваниях, сначала вызывает конструкторы по умолчанию для инициализации theName, theAddress и thePhones, а затем сразу присваивает им новые значения, затирая те, что уже были присвоены в конструкторах по умолчанию. Таким образом, вся работа конструкторов по умолчанию тратится впустую. Подход со списком инициализации членов позволяет избежать этой проблемы, поскольку аргументы в списке инициализации используются в качестве аргументов конструкторов для различных членов-данных. В этом случае theName создается конструктором копирования из name, theAddress – из address, thePhones – из phones. Для большинства типов единственный вызов конструктора копирования более эффективен – иногда <emphasis>намного</emphasis> более эффективен, чем вызов конструкторов по умолчанию с последующим вызовом операторов присваивания.</p>
<p>Для объектов встроенных типов вроде numTimesConsulted нет разницы по затратам между инициализацией и присваиванием, но для единообразия часто лучше инициировать все посредством списка инициализации членов. Такие списки можно применять даже тогда, когда данные-члены инициализируются конструкторами по умолчанию: просто не передавайте никаких аргументов соответствующему конструктору. Например, если у ABEntry есть конструктор, не принимающий параметров, то он может быть реализован примерно так:</p>
<empty-line/><p><code>ABEntry()</code></p>
<p><code>:theName(), // вызвать конструктор по умолчанию для theName</code></p>
<p><code>:theAddress(), // сделать то же для theAddress и для thePhones;</code></p>
<p><code>thePhones(), // но явно инициализировать нулем numTimesConsulted</code></p>
<p><code>:numTimesConsulted(0)</code></p>
<p><code>{}</code></p>
<empty-line/><p>Поскольку компилятор автоматически вызывает конструкторы по умолчанию для данных-членов пользовательских типов, когда для них отсутствуют инициализаторы в списке инициализации членов, некоторые программисты считают приведенный выше код избыточным. Это понятно, но, придерживаясь политики всегда перечислять все данные-члены в списках инициализации, вы избавляете себя от необходимости помнить, какие члены будут инициализированы, если их пропустить, а какие – нет. Например, поскольку numTimesConsulted относится к встроенному типу, то исключение его из списка инициализации может открыть двери неопределенному поведению.</p>
<p>Иногда список инициализации просто <emphasis>необходимо</emphasis> использовать, даже для встроенных типов. Например, данные-члены, которые являются константами либо ссылками, обязаны быть инициализированы, так как они не могут получить значения посредством присваивания (см. также правило 5). Чтобы избежать необходимости помнить, когда данные-члены должны быть инициализированы в списке инициализации, а когда это не обязательно, проще делать это <emphasis>всегда.</emphasis> Иногда это обязательно, а часто – более эффективно, чем присваивание.</p>
<p>Во многих классах есть несколько конструкторов, и каждый конструктор имеет свой собственный список инициализации. Если у класса много данных-членов или базовых классов, то наличие большого числа списков инициализации порождает нежелательное дублирование кода (в списках) и тоску (у программистов). В таких случаях имеет смысл опустить в списках инициализации те данные-члены, для которых присваивание работает так же, как настоящая инициализация, переместив инициализацию в одну (обычно закрытую) функцию, которую вызывают все конструкторы. Этот подход может быть особенно полезен, если начальные значения должны быть загружены из файла или базы данных. Однако, вообще говоря, инициализация членов посредством списков инициализации более предпочтительна, чем псевдоинициализация присваиванием.</p>
<p>Один из аспектов C++, на который можно положиться, – это порядок, в котором инициализируются данные объектов. Этот порядок всегда один и тот же: базовые классы инициализируются раньше производных (см. также правило 12), а внутри класса члены-данные инициализируются в том порядке, в котором объявлены. Например, в классе ABEntry член theName всегда будет инициализирован первым, theAddress – вторым, thePhones – третьим, а numTimesConsulted – последним. Это верно даже в случае, если в списке инициализации членов они перечислены в другом порядке (что, к сожалению, не запрещено). Чтобы не вводить в заблуждение человека, читающего вашу программу, и во избежание ошибок непонятного происхождения, всегда перечисляйте данные-члены в списке инициализации в том порядке, в котором они объявлены в классе.</p>
<p>Позаботившись о явной инициализации объектов встроенных типов, которые не являются членами классов, и обеспечив правильную инициализацию базовых классов и их данных-членов посредством списков инициализации, у вас останется только одна вещь, о чем нужно будет подумать. Речь идет о порядке инициализации нелокальных статических объектов, объявленных в разных единицах трансляции.</p>
<p>Отнесемся к этой фразе со всем вниманием.</p>
<p><emphasis>Статический объект</emphasis> существует от момента, когда был сконструирован, и до конца работы программы. Объекты, размещенные в стеке и в «куче», к статическим не относятся. Статическими являются глобальные объекты, объекты, объявленные в области действия пространства имен, объекты, объявленные с ключевым словом static внутри классов и функций, а также в области действия отдельного файла с исходным текстом. Статические объекты, объявленные внутри функций, известны как <emphasis>локальные статические объекты</emphasis> (поскольку они локальны по отношению к функции), а все прочие называют <emphasis>нелокальными статическими объектами.</emphasis> Статические объекты автоматически уничтожаются при завершении программы, то есть при выходе из функции main() автоматически вызываются их деструкторы.</p>
<p><emphasis>Единица трансляции (translation unit)</emphasis> – это исходный код, который порождает отдельный объектный файл. Обычно это один исходный файл плюс все файлы, включенные в него директивой #include.</p>
<p>Проблема возникает, когда есть, по крайней мере, два отдельно компилируемых исходных файла, каждый из которых содержит, по крайней мере, один нелокальный статический объект (то есть глобальный объект либо объявленный в области действия пространства имен, класса или файла). Суть ее в том, что если инициализация нелокального статического объекта происходит в одной единице трансляции, а используется он в другой, то такой объект может оказаться неинициализированным в момент использования, поскольку <emphasis>относительный порядок инициализации нестатических локальных объектов, определенных в разных единицах трансляции, не определен.</emphasis></p>
<p>Рассмотрим пример. Предположим, у вас есть класс FileSystem, который делает файлы из Internet неотличимыми от локальных. Поскольку ваш класс представляет мир как единую файловую систему, вы могли бы создать в глобальной области действия или в пространстве имен соответствующий ей специальный объект:</p>
<empty-line/><p><code>class FileSystem { // из вашей библиотеки</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>std::size_t numDisks() const; // одна из многих функций-членов</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>extern FileSystem tfs; // объект для использования клиентами</code></p>
<p><code>// “tfs” = “the file system”</code></p>
<empty-line/><p>Класс FileSystem определенно не тривиален, поэтому использование объекта theFileSystem до того, как он будет сконструирован, приведет к катастрофическим последствиям.</p>
<p>Теперь предположим, что некий пользователь создает класс, описывающий каталоги файловой системы. Естественно, его класс будет использовать объект theFileSystem:</p>
<empty-line/><p><code>class Directory { // создан пользователем</code></p>
<p><code>public:</code></p>
<p><code>Directory( params );</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>Directory::Directory( params )</code></p>
<p><code>{</code></p>
<p><code>...</code></p>
<p><code>std::size_t disks = tfs.numDisks(); // использование объекта tfs</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>Далее предположим, что пользователь решает создать отдельный глобальный объект класса Directory, представляющий каталог для временных файлов:</p>
<empty-line/><p><code>Directory tempDir( params ); // каталог для временных файлов</code></p>
<empty-line/><p>Теперь проблема порядка инициализации становится очевидной: если объект tfs не инициализирован раньше, чем tempDir, то конструктор tempDir попытается использовать tfs до его инициализации. Но tfs и tempDir были созданы разными людьми в разное время и находятся в разных исходных файлах – это нелокальные статические объекты, определенные в разных единицах трансляции. Как вы можете быть уверены, что tfs будет инициализирован раньше, чем tempDir?</p>
<p>Да никак! Еще раз повторю: <emphasis>относительный порядок инициализации нестатических локальных объектов, определенных в разных единицах трансляции, не определен.</emphasis> На то есть своя причина. Определить «правильный» порядок инициализации нелокальных статических объектов трудно. Очень трудно. Неразрешимо трудно. В наиболее общем случае – при наличии многих единиц трансляции и нелокальных статических объектов, сгенерированных путем неявной конкретизации шаблонов (которые и сами могут быть результатом неявной конкретизации других шаблонов) – не только невозможно определить правильный порядок инициализации, но обычно даже не стоит искать частные случаи, когда этот порядок в принципе определить можно.</p>
<p>К счастью, небольшое изменение в проекте программы позволяет полностью устранить эту проблему. Нужно лишь переместить каждый нелокальный статический объект в отдельную функцию, в которой он будет объявлен статическим. Эти функции возвращают ссылки на объекты, которые в них содержатся. Клиенты затем вызывают функции вместо непосредственного обращения к объектам. Другими словами, нелокальные статические объекты заменяются <emphasis>локальными</emphasis> статическими объектами (знакомые с паттернами проектирования легко узнают в этом описании типичную реализацию паттерна Singleton).</p>
<p>Этот подход основан на том, что C++ гарантирует: локальные статические объекты инициализируются в первый раз, когда определение объекта встречается при вызове этой функции. Поэтому если вы замените прямой доступ к нелокальным статическим объектам вызовом функций, возвращающих ссылки на расположенные внутри них локальные статические объекты, то можете быть уверены, что ссылки, возвращаемые из функций, будут ссылаться на инициализированные объекты. Дополнительное преимущество заключается в том, что если вы никогда не вызываете функцию, эмулирующую нелокальный статический объект, то и не придется платить за создание и уничтожение объекта, чего не скажешь о реальных нелокальных статических объектах.</p>
<p>Вот как этот прием применяется к объектам tfs и tempDir:</p>
<empty-line/><p><code>class FileSystem {...}; // как раньше</code></p>
<p><code>FileSystem&amp; tfs() // эта функция заменяет объект tfs, она может</code></p>
<p><code>{ // быть статической в классе FileSystem</code></p>
<p><code>static FileSystem fs; // определение и инициализация локального</code></p>
<p><code>// статического объекта</code></p>
<p><code>return fs; // возврат ссылки на него</code></p>
<p><code>}</code></p>
<p><code>class Directory {...}; // как раньше</code></p>
<p><code>Directory::Directory( <emphasis>params </emphasis>) // как раньше, но вместо ссылки на tfs</code></p>
<p><code>{ // вызов tfs()</code></p>
<p><code>...</code></p>
<p><code>std::size_t disks = tfs().numDisks();</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<p><code>Directory&amp; tempDir() // эта функция заменяет объект tempDir,</code></p>
<p><code>{ // может быть статической в классе Directory</code></p>
<p><code>static Directory td; // определение/инициализация локального</code></p>
<p><code>// статического объекта</code></p>
<p><code>return td; // возврат ссылки на него</code></p>
<p><code>}</code></p>
<empty-line/><p>Клиенты работают с этой модифицированной программой так же, как раньше, за исключением того, что вместо tfs и tempDir они теперь обращаются к tfs() и tempDir(). Иными словами, используют ссылки на объекты, возвращенные функциями, вместо использования самих объектов.</p>
<p>Функции, которые в соответствии с данной схемой возвращают ссылки, всегда просты: определить и инициализировать локальный статический объект в строке 1 и вернуть его в строке 2. В связи с этим у вас может возникнуть искушение объявить их встроенными, особенно, если они часто вызываются (см. правило 30). С другой стороны, тот факт, что эти функции содержат в себе статические объекты, усложняет их применение в многопоточных системах. Но тут никуда не деться: неконстантные статические объекты любого рода – локальные или нелокальные – представляют проблему в случае наличия в программе нескольких потоков. Решить ее можно, например, вызвав самостоятельно все функции, возвращающие ссылки, на этапе запуска программы, когда еще работает только один поток. Это исключит неопределенность в ходе инициализации.</p>
<p>Конечно, применимость идеи функций, возвращающих ссылки, для предотвращения проблем, связанных с порядком инициализации, зависит от того, существует ли в принципе разумный порядок инициализации ваших объектов. Если вы напишете код, в котором объект A должен быть инициализирован прежде, чем объект B, и одновременно сделаете инициализацию A зависимой от инициализации B, то вас ждут проблемы – и поделом! Если, однако, вы будете избегать таких патологических ситуаций, то описанная схема сослужит вам добрую службу, по крайней мере, в однопоточных приложениях.</p>
<p>Таким образом, чтобы избежать использования объектов до их инициализации, вам следует сделать три вещи. Первое: вручную инициализировать не являющиеся членами объекты встроенных типов. Второе: использовать списки инициализации членов для всех частей объекта. И наконец, третье: обойти за счет правильного проектирования проблему негарантированного порядка инициализации нелокальных статических объектов, определенных в разных единицах трансляции.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Всегда вручную инициализировать объекты встроенных типов, поскольку C++ делает это, только не всегда.</p>
<p>• В конструкторе отдавать предпочтение применению списков инициализации членов перед прямым присваиванием значений в теле конструктора. Перечисляйте данные-члены в списке инициализации в том же порядке, в каком они объявлены в классе.</p>
<p>• Избегайте проблем с порядком инициализации в разных единицах трансляции, заменяя нелокальные статические объекты локальными статическими объектами.</p>
</section></section><section><title><p>Глава 2</p>
<p>Конструкторы, деструкторы и операторы присваивания</p>
</title><section><p>Почти во всех ваших классах будут определены один или несколько конструкторов, деструктор и оператор присваивания. Это функции, которые отвечают за операции создания и инициализации объекта, его уничтожения, а также присваивания ему нового значения. Ошибки в этих функциях приводят к далеко идущим и неприятным последствиям и отражаются на всех ваших классах, поэтому они должны быть написаны правильно. В настоящей главе изложены правила по программированию функций, составляющих основу классов.</p>
</section><section><title><p>Правило 5: Какие функции C++ создает и вызывает молча</p>
</title><p>Когда пустой класс перестает быть пустым? Когда за него берется C++. Если вы не объявите конструктор копирования, оператор присваивания или деструктор самостоятельно, то компилятор сделает это за вас. Более того, если вы не объявите вообще никакого конструктора, то компилятор автоматически создаст конструктор по умолчанию. Все эти функции будут открытыми и встроенными (см. правило 30). Например, такое объявление:</p>
<empty-line/><p><code>class Empty {};</code></p>
<empty-line/><p>эквиваленто следующему:</p>
<empty-line/><p><code>class Empty {</code></p>
<p><code>public:</code></p>
<p><code>Empty() {...} // конструктор по умолчанию</code></p>
<p><code>Empty(const Empty&amp; rhs) {...} // конструктор копирования</code></p>
<p><code>~Empty() {...} // деструктор – см. ниже</code></p>
<p><code>// о виртуальных деструкторах</code></p>
<p><code>Empty&amp; operator=(const Empty&amp; rhs) {...} // оператор присваивания</code></p>
<p><code>};</code></p>
<empty-line/><p>Эти функции генерируются, только если они нужны, но мало найдется случаев, когда без них можно обойтись. Так, следующий код приведет к их автоматической генерации компилятором:</p>
<empty-line/><p><code>Empty e1; // конструктор по умолчанию;</code></p>
<p><code>// деструктор</code></p>
<p><code>Empty e2(e1); // конструктор копирования</code></p>
<p><code>e2 = e1; // оператор присваивания</code></p>
<empty-line/><p>Итак, компилятор пишет эти функции для вас, но что они делают? Конструктор по умолчанию и деструктор – это места, в которые компилятор помещает служебный код, например вызов конструкторов и деструкторов базовых классов и нестатических данных-членов. Отметим, что сгенерированный деструктор не является виртуальным (см. правило 7), если только речь не идет о классе, наследующем классу, у которого есть виртуальный деструктор (в этом случае виртуальность наследуется от базового класса).</p>
<p>Что касается конструктора копирования и оператора присваивания, то сгенерированные компилятором версии просто копируют каждый нестатический член данных исходного объекта в целевой. Например, рассмотрим шаблон NamedObject, который позволяет ассоциировать имена с объектами типа T:</p>
<empty-line/><p><code>Template&lt;typename T&gt;</code></p>
<p><code>class NamedObject {</code></p>
<p><code>public:</code></p>
<p><code>NamedObject(const char *name, const T&amp; value);</code></p>
<p><code>NamedObject(const std::string&amp; name, const T&amp; value);</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>std:string nameValue;</code></p>
<p><code>T objectValue;</code></p>
<p><code>};</code></p>
<empty-line/><p>Поскольку в классе NamedObject объявлен конструктор, компилятор не станет генерировать конструктор по умолчанию. Это важно. Значит, если вы спроектировали класс так, что его конструктору обязательно должны быть переданы какие-то аргументы, то вам не нужно беспокоиться, что компилятор проигнорирует ваше решение и по собственной инициативе добавит еще и конструктор без аргументов.</p>
<p>В классе NamedObject нет ни конструктора копирования, ни оператора присваивания, поэтому компилятор сгенерирует их (при необходимости). Посмотрите на следующее употребление конструктора копирования:</p>
<empty-line/><p><code>NamedObject&lt;int&gt;no1(“Smallest Prime Number”, 2);</code></p>
<p><code>NamedObject&lt;int&gt;no2(no1); // вызывается конструктор копирования</code></p>
<empty-line/><p>Конструктор копирования, сгенерированный компилятором, должен инициализировать no2.nameValue и no2.objectValue, используя nol.nameValue и nol.objectValue соответственно. Член nameValue имеет тип string, а в стандартном классе string объявлен конструктор копирования, поэтому no2. nameValue будет инициализирован вызовом конструктора копирования string с аргументов nol.nameValue. С другой стороны, член NameObject&lt;int&gt;::objectValue имеет тип int (поскольку T есть int в данной конкретизации шаблона), а int – встроенный тип, поэтому no2.objectValue будет инициализирован побитовым копированием nol.objectValue.</p>
<p>Сгенерированный компилятором оператор присваивания для класса Named-Object&lt;int&gt; будет вести себя аналогичным образом, но, вообще говоря, сгенерированная компилятором версия оператора присваивания ведет себя так, как я описал, только в том случае, когда в результате получается корректный и осмысленный код. В противном случае компилятор не сгенерирует operator=.</p>
<p>Например, предположим, что класс NamedObject определен, как показано ниже. Обратите внимание, что nameValue – ссылка на string, а objectValue имеет тип const T:</p>
<empty-line/><p><code>template&lt;class T&gt;</code></p>
<p><code>class NamedObject {</code></p>
<p><code>public:</code></p>
<p><code>// этот конструктор более не принимает const name, поскольку nameValue –</code></p>
<p><code>// теперь ссылка на неконстантную строку. Конструктор с аргументом типа</code></p>
<p><code>// char* исключен, поскольку нам нужна строка, на которую можно сослаться</code></p>
<p><code>NamedObject(std::string&amp; name, const T&amp; value);</code></p>
<p><code>... // как и ранее, предполагаем,</code></p>
<p><code>// что operator= не объявлен</code></p>
<p><code>private:</code></p>
<p><code>std::string&amp; nameValue; // теперь это ссылка</code></p>
<p><code>const T objectValue; // теперь const</code></p>
<p><code>};</code></p>
<empty-line/><p>Посмотрим, что произойдет в приведенном ниже коде:</p>
<empty-line/><p><code>std::string newDog(“Persephone”);</code></p>
<p><code>std::string oldDog(“Satch”);</code></p>
<p><code>NamedObject&lt;int&gt; p(newDog, 2); // Когда я впервые написал это,</code></p>
<p><code>// наша собака Персефона собиралась</code></p>
<p><code>// встретить свой второй день рождения</code></p>
<p><code>NamedObject&lt;int&gt; s(oldDog, 36); // Семейному псу Сатчу (из моего</code></p>
<p><code>// детства) было бы теперь 36 лет</code></p>
<p><code>p = s; // Что должно произойти</code></p>
<p><code>// с данными-членами p?</code></p>
<empty-line/><p>Перед присваиванием и p.nameValue, и s.nameValue ссылались на объекты string, хотя и на разные. Что должно произойти с членом p.nameValue в результате присваивания? Должен ли он ссылаться на ту же строку, что и s.nameValue, то есть должна ли модифицироваться ссылка? Если да, это подрывает основы, потому что C++ не позволяет изменить объект, на который указывает ссылка. Но, быть может, должна модифицироваться строка, на которую ссылается член p.nameValue, и тогда будут затронуты другие объекты, содержащие указатели или ссылки на эту строку, хотя они и не участвовали непосредственно в присваивании? Это ли должен делать сгенерированный компилятором оператор присваивания?</p>
<p>Сталкиваясь с подобной головоломкой, C++ просто отказывается компилировать этот код. Если вы хотите поддерживать присваивание в классе, включающем в себя член-ссылку, то должны определить оператор присваивания самостоятельно. Аналогичным образом компилятор ведет себя с классами, содержащими константные члены (такие как objectValue во втором варианте класса NamedObject выше). Модифицировать константные члены запрещено, поэтому компилятор не знает, как поступать при неявной генерации оператора присваивания. Кроме того, компилятор не станет неявно генерировать оператор присваивания в производном классе, если в его базовом объявлен закрытый оператор присваивания. И наконец, предполагается, что сгенерированные компилятором операторы присваивания для производных классов должны обрабатывать части базовых классов (см. правило 12), но при этом они конечно же не могут вызывать функции-члены, доступ к которым для них запрещен.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Компилятор может неявно генерировать для класса конструктор по умолчанию, конструктор копирования, оператор присваивания и деструктор.</p>
</section><section><title><p>Правило 6: Явно запрещайте компилятору генерировать функции, которые вам не нужны</p>
</title><p>Агенты по продаже недвижимости и программные системы, обслуживающие их деятельность, могут нуждаться в классе, представляющем дома, выставленные на продажу:</p>
<empty-line/><p><code>class HomeForSale {...};</code></p>
<empty-line/><p>Любой агент по продаже недвижимости скажет вам, что каждый объект уникален – не бывает двух, в точности одинаковых. Вот почему идея создания копии объекта HomeForSale бессмысленна. Как можно скопировать нечто, по определению, уникальное? Поэтому хотелось бы, чтобы попытки скопировать объекты HomeForSale не компилировались:</p>
<empty-line/><p><code>HomeForSale h1;</code></p>
<p><code>HomeForSale h2;</code></p>
<p><code>HomeForSale h3(h1); // попытка скопировать h1 –</code></p>
<p><code>// не должно компилироваться!</code></p>
<p><code>h1 = h2; // попытка скопировать h2 –</code></p>
<p><code>// не должно компилироваться!</code></p>
<empty-line/><p>Увы, предотвратить такую компиляцию не так-то просто. Обычно, если вы не хотите, чтобы класс поддерживал определенного рода функциональность, вы просто не объявляете функций, которые ее реализуют. Но с конструктором копирования и оператором присваивания эта стратегия не работает, поскольку, как следует из правила 5, если вы их не объявляете, а где-то в программе производится попытка их вызвать, то компилятор сгенерирует их автоматически.</p>
<p>Похоже на безвыходное положение. Если вы сами не объявите конструктор копирования или оператор присваивания, то их сгенерирует компилятор. И ваш класс будет поддерживать копирование. Но то же самое произойдет, если вы объявите эти функции самостоятельно. Однако наша цель – <emphasis>предотвратить</emphasis> копирование!</p>
<p>Ключ к решению в том, что все сгенерированные компилятором функции являются открытыми. Чтобы предотвратить автоматическое генерирование, вы должны объявить их самостоятельно, но никто не требует, чтобы они были открытыми. Ну так и объявите конструктор копирования и оператор присваивания <emphasis>закрытыми.</emphasis> Объявляя явно функцию-член, вы предотвращаете генерирование ее компилятором, а сделав ее закрытой, не позволяете кому-либо вызывать ее.</p>
<p>Схема не идеальна, потому что другие члены класса и функции-друзья по-прежнему могут вызывать закрытые функции. <emphasis>Если только</emphasis> вы не включите лишь объявление, опустив определение. Тогда если кто-то случайно вызовет такую функцию, то получит сообщение об ошибке на этапе компоновки. Этот трюк – объявление функций-членов закрытыми и сознательный отказ от их реализации – как раз и используется для предотвращения копирования в некоторых классах библиотеки iostreams. Взгляните, например, на объявления классов ios_base, basic_ios и sentry в вашей реализации стандартной библиотеки. Вы обнаружите, что в каждом случае как конструктор копирования, так и оператор присваивания объявлены закрытыми и нигде не определены.</p>
<p>Применить эту уловку в классе HomeForSale несложно:</p>
<empty-line/><p><code>class HomeForSale {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>HomeForSale(const HomeForSale&amp;); // только объявления</code></p>
<p><code>HomeForSale&amp; oparetor=( const HomeForSale&amp;);</code></p>
<p><code>};</code></p>
<empty-line/><p>Заметьте, что я не указал имена параметров функций. Это необязательно, просто таково общее соглашение. Ведь раз эти функции никогда не будут реализовываться и использоваться, то какой смысл задавать имена их параметров?</p>
<p>При таком определении компилятор будет блокировать любые попытки клиентов копировать объекты HomeForSale, а если вы случайно попытаетесь сделать это в функции-члене или функции-друге класса, то об ошибке сообщит компоновщик.</p>
<p>Существует возможность переместить ошибку с этапа компоновки на этап компиляции (это всегда полезно – лучше обнаружить ошибку как можно раньше), если объявить конструктор копирования и оператор присваивания закрытыми не в самом классе HomeForSale, а в его базовом классе, специально созданном для предотвращения копирования. Такой базовый класс очень прост:</p>
<empty-line/><p><code>class Uncopyable {</code></p>
<p><code>protected:</code></p>
<p><code>Uncopyable() {} // разрешить конструирование</code></p>
<p><code>~Uncopyable() {} // и уничтожение</code></p>
<p><code>// объектов производных классов</code></p>
<p><code>private:</code></p>
<p><code>Uncopyable(const Uncopyable&amp;); // но предотвратить копирование</code></p>
<p><code>Uncopyable&amp; operator=(const Uncopyable&amp;);</code></p>
<p><code>};</code></p>
<empty-line/><p>Чтобы предотвратить копирование объектов HomeForSale, нужно лишь унаследовать его от Uncopyable:</p>
<empty-line/><p><code>class HomeForSale : private Uncopyable { // в этом класс больше нет ни</code></p>
<p><code>... // конструктора копирования, ни</code></p>
<p><code>} // оператора присваивания</code></p>
<empty-line/><p>Такое решение работает, потому что компилятор пытается генерировать конструктор копирования и оператор присваивания, если где-то – пусть даже в функции-члене или дружественной функции – производится попытка скопировать объект HomeForSale. Как объясняется в правиле 12, сгенерированные компилятором версии будут вызывать соответствующие функции из базового класса. Но это не получится, так как в базовом классе они объявлены закрытыми.</p>
<p>Реализация и использование класса Uncopyable сопряжена с некоторыми тонкостями. Например, наследование от Uncopyable не должно быть открытым (см. правила 32 и 39), а деструктор Uncopyable не должен быть виртуальным (см. правило 7). Поскольку Uncopyable не имеет данных-членов, то компилятор может прибегнуть к оптимизации пустых базовых классов, описанной в правиле 39, но коль скоро этот класс базовый, то возможно возникновение множественного наследования (см. правило 40). А множественное наследование в некоторых случаях не дает возможности провести оптимизацию пустых базовых классов (см. правило 39). Вообще говоря, вы можете игнорировать эти тонкости и просто использовать Uncopyable, как показано выше. Можете также воспользоваться версией из билиотеки Boost (см. правило 55). В ней этот класс называется noncopyable. Это хороший класс, но мне просто показалось, что его название немного, скажем так, неестественное.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Чтобы отключить функциональность, автоматически предоставляемую компилятором, объявите соответствующую функцию-член закрытой и не включайте ее реализацию. Наследование базовому классу типа Uncopyable – один из способов сделать это.</p>
</section><section><title><p>Правило 7: Объявляйте деструкторы виртуальными в полиморфном базовом классе</p>
</title><p>Существует много способов отслеживать время, поэтому имеет смысл создать базовый класс TimeKeeper и производные от него классы, которые реализуют разные подходы к хронометражу:</p>
<empty-line/><p><code>class TimeKeeper {</code></p>
<p><code>public:</code></p>
<p><code>TimeKeeper();</code></p>
<p><code>~TimeKeeper();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class AtomicClock: public TimeKeeper {…};</code></p>
<p><code>class WaterClock: public TimeKeeper {….};</code></p>
<p><code>class WristWatch: public TimeKeeper {…};</code></p>
<empty-line/><p>Многие клиенты захотят иметь доступ к данным о времени, не заботясь о деталях того, как они получаются, поэтому мы можем воспользоваться <emphasis>фабричной функцией (factory function),</emphasis> которая возвращает указатель на базовый класс созданного ей объекта производного класса:</p>
<empty-line/><p><code>TimeKeeper *getTimeKeeper(); // возвращает указатель на динамически</code></p>
<p><code>// выделенный объект класса,</code></p>
<p><code>// производного от TimeKeeper</code></p>
<empty-line/><p>В соответствии с соглашением о фабричных функциях объекты, возвращаемые getTimeKeeper, выделяются из кучи, поэтому для того, чтобы избежать утечек памяти и других ресурсов, важно, чтобы каждый полученный объект был рано или поздно уничтожен:</p>
<empty-line/><p><code>TomeKeeper *ptk = getTimeKeeper(); // получить динамически выделенный</code></p>
<p><code>// объект из иерархии TimeKeeper</code></p>
<p><code>... // использовать его</code></p>
<p><code>delete ptk; // уничтожить, чтобы избежать утечки</code></p>
<p><code>// ресурсов</code></p>
<empty-line/><p>Как объясняется в правиле 13, полагаться на то, что объект уничтожит клиент, чревато ошибками, а в правиле 18 говорится, как можно модифицировать фабричную функцию для предотвращения наиболее частых ошибок в клиентской программе. Здесь же мы обсудим более серьезный недостаток приведенного выше кода: даже если клиент все делает правильно, мы не можем узнать, как будет вести себя программа.</p>
<p>Проблема в том, что getTimeKeeper возвращает указатель на объект производного класса (например, AtomicClock), а удалять этот объект нужно через указатель на базовый класс (то есть на TimeKeeper), при этом в базовом классе (TimeKeeper) объявлен невиртуальный деструктор. Это прямой путь к неприятностям, потому что в спецификации C++ постулируется, что когда объект производного класса уничтожается через указатель на базовый класс с невиртуальным деструктором, то результат не определен. Во время исполнения это обычно приводит к тому, что часть объекта, принадлежащая производному классу, никогда не будет уничтожена. Если getTimeKeeper() возвращает указатель на объект класс AtomicClock, то часть объекта, принадлежащая AtomicClock (то есть данные-члены, объявленные в этом классе), вероятно, не будут уничтожены, так как не будет вызван деструктор AtomicClock. Те же члены, что относятся к базовому классу (то есть TimeKeeper), будут уничтожены, что приведет к появлению так называемых «частично разрушенных» объектов. Это верный путь к утечке ресурсов, повреждению структур данных и проведению изрядного времени в обществе отладчика.</p>
<p>Решить эту проблему легко: нужно объявить в базовом классе виртуальный деструктор. Тогда при удалении объектов производных классов будет происходить именно то, что нужно. Объект будет разрушен целиком, включая все его части:</p>
<empty-line/><p><code>class TimeKeeper {</code></p>
<p><code>public:</code></p>
<p><code>TimeKeeper();</code></p>
<p><code>virtual ~TimeKeeper();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>TimeKeeper *ptk = get TimeKeeper();</code></p>
<p><code>...</code></p>
<p><code>delete ptk; // теперь работает правильно</code></p>
<empty-line/><p>Обычно базовые классы вроде TimeKeeper содержат и другие виртуальные функции, кроме деструктора, поскольку назначение виртуальных функций – обеспечить возможность настройки производных классов (см. правило 34). Например, в классе TimeKeeper может быть определена виртуальная функция getCurrentTime, реализованная по-разному в разных производных классах. Любой класс с виртуальными функциями почти наверняка должен иметь виртуальный деструктор.</p>
<p>Если же класс не имеет виртуальных функций, это часто означает, что он не предназначен быть базовым. А в таком классе определять виртуальный деструктор не стоит. Рассмотрим класс, представляющий точку на плоскости:</p>
<empty-line/><p><code>class Point { // точка на плоскости</code></p>
<p><code>public:</code></p>
<p><code>Point(int xCoord, int yCoord);</code></p>
<p><code>~Point();</code></p>
<p><code>private:</code></p>
<p><code>int x,y;</code></p>
<p><code>};</code></p>
<empty-line/><p>Если int занимает 32 бита, то объект Point обычно может поместиться в 64-битовый регистр. Более того, такой объект Point может быть передан как 64-битовое число функциям, написанным на других языках (таких как C или FORTRAN). Если же деструктор Point сделать виртуальным, то ситуация изменится.</p>
<p>Для реализации виртуальных функций необходимо, чтобы в объекте хранилась информация, которая во время исполнения позволяет определить, какая виртуальная функция должна быть вызвана. Эта информация обычно представлена указателем на таблицу виртуальных функций vptr (virtual table pointer). Сама таблица – это массив указателей на функции, называемый vtbl (virtual table). С каждым классом, в котором определены виртуальные функции, ассоциирована таблица vtbl. Когда для некоторого объекта вызывается виртуальная функция, то с помощью указателя vptr в таблице vtbl ищется та реальная функция, которую нужно вызвать.</p>
<p>Детали реализации виртуальных функций не важны. Важно то, что если класс Point содержит виртуальную функцию, то объект этого типа увеличивается в размере. В 32-битовой архитектуре его размер возрастает с 64 бит (два целых int) до 96 бит (два int плюс vptr); в 64-битовой архитектуре он может вырасти с 64 до 128 бит, потому что указатели в этой архитектуре имеют размер 64 бита. Таким образом, добавление vptr к объекту Point увеличивает его размер на величину от 50 до 100 %! После этого объект Point уже не может поместиться в 64-битный регистр. Более того, объекты этого типа в C++ перестают выглядеть так, как аналогичные структуры, объявленные на других языках, например на C, потому что в других языках нет понятия vptr. В результате становится невозможно передавать объекты типа Point написанным на других языках программам, если только вы не учтете наличия vptr. А это уже деталь реализации, и, следовательно, такой код не будет переносимым.</p>
<p>Практический вывод из всего вышесказанного состоит в том, что необоснованно объявлять все деструкторы виртуальными так же неверно, как не объявлять их виртуальными никогда. Можно высказать этот совет и в таком виде: деструкторы следует объявлять виртуальными тогда, когда в классе есть хотя бы одна виртуальная функция.</p>
<p>Однако невиртуальные деструкторы могут стать причиной неприятностей даже при полном отсутствии в классе виртуальных функций. Например, в стандартном классе string нет виртуальных функций, но программисты временами все же используют его как базовый класс:</p>
<empty-line/><p><code>class SpecialString: public std::string { // плохо! std::string содержит</code></p>
<p><code>... // невиртуальный деструктор</code></p>
<p><code>};</code></p>
<empty-line/><p>На первый взгляд такой код может показаться безвредным, но если где-то в приложении вы преобразуете указатель на SpecialString в указатель на string, а затем выполните для этого указателя delete, то немедленно попадете в область неопределенного поведения:</p>
<empty-line/><p><code>SpecialString *pss = new SpecialString(“Надвигающаяся опасность”);</code></p>
<p><code>std::string *ps;</code></p>
<p><code>...</code></p>
<p><code>ps = pss; // SpecialString*=&gt;std::string*</code></p>
<p><code>...</code></p>
<p><code>delete ps; // неопределенность! На практике ресурсы, выделенные</code></p>
<p><code>// объекту SpecialString, не будут освобождены, потому</code></p>
<p><code>// что деструктор SpecialString не вызывается</code></p>
<empty-line/><p>То же относится к любому классу, в котором нет виртуального деструктора, в частности ко всем типам STL-контейнеров (например, vector, list, set, tr1::unordered_map [см. правило 54] и т. д.). Если у вас когда-нибудь возникнет соблазн унаследовать стандартному контейнеру или любому другому классу с невиртуальным деструктором, воздержитесь! (К сожалению, в C++ не предусмотрено никакого механизма предотвращения наследования, как, скажем, final в языке Java, или sealed в C#).</p>
<p>Иногда может быть удобно добавить в класс чисто виртуальный деструктор. Вспомним, что чисто виртуальные функции порождают <emphasis>абстрактные</emphasis> классы, то есть классы, экземпляры которых создать нельзя. Иногда, однако, у вас есть класс, который вы хотели бы сделать абстрактным, но в нем нет ни одной пустой виртуальной функции. Что делать? Поскольку абстрактный класс предназначен для использования в качестве базового и поскольку базовый класс должен иметь виртуальный деструктор, а чисто виртуальная функция порождает абстрактный класс, то решение очевидно: объявить чисто виртуальный деструктор в классе, который вы хотите сделать абстрактным. Вот пример:</p>
<empty-line/><p><code>class AWOV { // AWOV = “Abstract w/o Virtuals”</code></p>
<p><code>public:</code></p>
<p><code>virtual ~AWOV() = 0; // объявление чисто виртуального</code></p>
<p><code>}; // деструктора</code></p>
<empty-line/><p>Этот класс включает в себя чисто виртуальную функцию, поэтому он абстрактный. А раз в нем объявлен виртуальный деструктор, то можно не беспокоиться о том, что деструкторы базовых классов не будут вызваны. Однако есть одна тонкость: вы должны предоставить <emphasis>определение</emphasis> чисто виртуального деструктора:</p>
<empty-line/><p><code>AWOV::~AWOV(){}; // определение чисто виртуального деструктора</code></p>
<empty-line/><p>Дело в том, что сначала всегда вызывается деструктор «самого производного» класса (то есть находящегося на нижней ступени иерархии наследования), а затем деструкторы каждого базового класса. Компилятор сгенерирует вызов ~AWOV из деструкторов производных от него классов, а значит, вы должны позаботиться о его реализации. Если этого не сделать, компоновщик будет недоволен.</p>
<p>Правило включения в базовые классы виртуальных деструкторов касается только <emphasis>полиморфных</emphasis> базовых классов, то есть таких, которые позволяют манипулировать объектами производных классов с помощью указателя на базовый. TimeKeeper – полиморфный базовый класс, мы ожидаем, что при наличии указателя на объект TimeKeeper сможем манипулировать объектами AtomicClock и WaterClock.</p>
<p>Не все базовые классы разрабатываются с учетом полиморфизма. Например, и стандартный тип string, и типы STL-контейнеров спроектированы так, что не допускают возможности использования в качестве базовых, так как не являются полиморфными. Некоторые классы предназначены служить в качестве базовых, но полиморфно использоваться не могут; примером могут служить класс Uncopyable из правила 6 и класс input_iterator_tag из стандартной библиотеки (см. правило 47). Таким классам не нужны виртуальные деструкторы.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Полиморфные базовые классы должны объявлять виртуальные деструкторы. Если класс имеет хотя бы одну виртуальную функцию, он должен иметь виртуальный деструктор.</p>
<p>• В классах, не предназначенных для использования в качестве базовых или для полиморфного применения, не следует объявлять виртуальные деструкторы.</p>
</section><section><title><p>Правило 8: Не позволяйте исключениям покидать деструкторы</p>
</title><p>C++ не запрещает использовать исключения в деструкторах, но это, безусловно, очень нежелательная практика. На то есть серьезная причина. Рассмотрим пример:</p>
<empty-line/><p><code>class Widget {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>~Widget() {...} // предположим, здесь есть исключение</code></p>
<p><code>};</code></p>
<p><code>void doSomething()</code></p>
<p><code>{</code></p>
<p><code>std::vector&lt;Widget&gt; v;</code></p>
<p><code>...</code></p>
<p><code>} // здесь v автоматически уничтожается</code></p>
<empty-line/><p>Когда вектор v уничтожается, он отвечает за уничтожение всех объектов Widget, которые в нем содержатся. Предположим, что v содержит 10 объектов Widget, и во время уничтожения первого из них возбужается исключение. Остальные девять объектов Widget также должны быть уничтожены (иначе ресурсы, выделенные для них, будут потеряны), поэтому необходимо вызвать и их деструкторы. Но представим, что в это время деструктор второго объекта Widget также возбудит исключение. Тогда возникнет сразу два одновременно активных исключения, а это слишком много для C++. В зависимости от конкретных условий исполнение программы либо будет прервано, либо ее поведение окажется неопределенным. В этом примере как раз имеет место второй случай. И так будет происходить при использовании любого библиотечного контейнера (например, list, set), любого контейнера TR1 (см. правило 54) и даже массива. И причина этой проблемы не в контейнерах или массивах. Преждевременное завершение программы или неопределенное поведение здесь является результатом того, что деструкторы возбуждают исключения. C++ <emphasis>не</emphasis> любит деструкторов, возбуждающих исключения!</p>
<p>Это достаточно просто понять. Но что вы должны делать, если в вашем деструкторе необходимо выполнить операцию, которая может породить исключение? Например, предположим, что мы имеем дело с классом, описывающим подключение к базе данных:</p>
<empty-line/><p><code>class DBConnection {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>static DBConnection create(); // функция возвращает объект</code></p>
<p><code>// DBConnection; параметры для</code></p>
<p><code>// простоты опущены</code></p>
<p><code>void close(); // закрыть соединение; при неудаче</code></p>
<p><code>}; // возбуждает исключение</code></p>
<empty-line/><p>Для гарантии того, что клиент не забудет вызвать close для объектов DBConnection, резонно создать класс для управления ресурсами DBConnection, который вызывает close в своем деструкторе. Классы, управляющие ресурсами, мы подробно рассмотрим в главе 3, а здесь достаточно прикинуть, как должен выглядеть деструктор такого класса:</p>
<empty-line/><p><code>class DBConn { // Класс для управления объектами</code></p>
<p><code>public: // DBConnection</code></p>
<p><code>...</code></p>
<p><code>~DBConn() // обеспечить, чтобы соединения с базой</code></p>
<p><code>{ // данных всегда закрывались</code></p>
<p><code>db.close();</code></p>
<p><code>}</code></p>
<p><code>private:</code></p>
<p><code>DBConnecton db;</code></p>
<p><code>};</code></p>
<empty-line/><p>Тогда клиент может содержать такой код:</p>
<empty-line/><p><code>{ // блок открывается</code></p>
<p><code>DBConn dbc(DBConnection::create()); // создать объект DBConnection</code></p>
<p><code>// и передать его объекту DBConn</code></p>
<p><code>... // использовать объект DBConnection</code></p>
<p><code>// через интерфейс DBConn</code></p>
<p><code>} // в конце блока объект DBConn</code></p>
<p><code>// уничтожается, при этом</code></p>
<p><code>// автоматически вызывается метод close</code></p>
<p><code>// объекта DBConnection</code></p>
<empty-line/><p>Все это приемлемо до тех пор, пока метод close завершается успешно, но если его вызов возбуждает исключение, то оно покидает пределы деструктора DBConn. Это очень плохо, потому что деструкторы, возбуждающие исключения, могут стать источниками ошибок.</p>
<p>Есть два основных способа избежать этой проблемы. Деструктор DBConn может:</p>
<p>• <strong>Прервать программу,</strong> если close возбуждает исключение; обычно для этого вызывается функция abort:</p>
<empty-line/><p><code>DBConn::~DBConn()</code></p>
<p><code>{</code></p>
<p><code>try {db.close();}</code></p>
<p><code>catch(...) {</code></p>
<p><code><emphasis>записать в протокол, что вызов close завершился неудачно;</emphasis></code></p>
<p><code>std::abort();</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/><p>Это резонный выбор, если программа не может продолжать работу после того, как в деструкторе произошла ошибка. Преимущество такого подхода – в предотвращении неопределенного поведения. Вызов abort упредит возникновение неопределенности.</p>
<p>• <strong>Перехватить исключение,</strong> возбужденное вызовом close:</p>
<empty-line/><p><code>DBConn::~DBConn()</code></p>
<p><code>{</code></p>
<p><code>try {db.close();}</code></p>
<p><code>catch(...) {</code></p>
<p><code><emphasis>записать в протокол, что вызов close завершился неудачно;</emphasis></code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/><p>Вообще говоря, такое «проглатывание» исключений – плохая идея, потому что мы теряем важную информацию: <emphasis>что-то не сработало</emphasis> ! Но иногда лучше поступить так, чтобы избежать преждевременной остановки программы или неопределенного поведения. Выбирать этот подход следует лишь в случае, когда программа в состоянии надежно продолжать исполнение, даже после того, как ошибка произошла, но была проигнорирована.</p>
<p>Ни одно из этих решений не является идеальным. Проблема в том, что в обоих случаях программа не имеет возможности отреагировать на ситуацию, которая привела к возбуждению исключения внутри close.</p>
<p>Более разумная стратегия – спроектировать интерфейс DBConn так, чтобы его клиенты сами имели возможность реагировать на возникающие ошибки. Например, класс DBConn может предоставить собственную функцию close и таким образом дать клиентам шанс обработать исключение, возникшее в процессе операции. Объект этого класса мог бы отслеживать, было ли соединение DBConnection уже закрыто функцией close, и, если это не так, закрывать его в деструкторе. Тем самым предотвращается утечка соединений. Но если close все-таки будет вызвана из деструктора и возбудит исключение, то мы опять возвращаемся к описанным выше вариантам: прервать программу или «проглотить» исключение:</p>
<empty-line/><p><code>class DBConn {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>void close() // новая функция для использования клиентом</code></p>
<p><code>{</code></p>
<p><code>db.close()</code></p>
<p><code>closed = true;</code></p>
<p><code>}</code></p>
<p><code>~DBConn()</code></p>
<p><code>{</code></p>
<p><code>if(!closed)</code></p>
<p><code>try {</code></p>
<p><code>db.close(); // закрыть соединение, если этого не сделал</code></p>
<p><code>} // клиент</code></p>
<p><code>catch(...) { // если возникнет исключение, запротоколировать</code></p>
<p><code><emphasis>записать в протокол, </emphasis></code></p>
<p><code>// и прервать программу или «проглотить» его</code></p>
<p><code><emphasis>что вызов close</emphasis></code></p>
<p><code><emphasis>завершился неудачно;</emphasis></code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<p><code>private:</code></p>
<p><code>DBConnecton db;</code></p>
<p><code>bool closed;</code></p>
<p><code>};</code></p>
<empty-line/><p>Перемещение вызова close из деструктора DBConn в код клиента (и оставлением в деструкторе DBConn «страховочного» вызова) может показаться вам беспринципным перекладыванием ответственности. Вы даже можете усмотреть в этом нарушение принципа, описанного в правиле 18: интерфейс должно быть легко использовать правильно. На самом деле все не так. Если операция может завершиться неудачно с возбуждением исключения и есть необходимость обработать это исключение, то исключение должно возбуждаться <emphasis>функцией, не являющейся деструктором.</emphasis> Связано это с тем, что деструкторы, возбуждающие исключения, опасны и всегда чреваты преждевременным завершением программы или неопределенным поведением. Говоря клиентам, что они должны сами вызывать функцию close, мы не обременяем их лишней работой, а даем возможность обработать ошибки, на которые в противном случае они не смогли бы отреагировать. Если они считают, что им это ни к чему, то могут проигнорировать эту возможность, полагаясь на то, что соединение закроет деструктор DBConn. Если же при этом произойдет ошибка, то есть close возбудит исключение, то им не на что жаловаться, если DBConn проглотит его или прервет программу. В конце-то концов, у них ведь был случай отреагировать по-другому, а они им не воспользовались.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Деструкторы никогда не должны возбуждать исключений. Если функция, вызываемая в деструкторе, может это сделать, то деструктор обязан перехватывать все исключения, а затем «проглатывать» их либо прерывать программу.</p>
<p>• Если клиенты класса нуждаются в возможности реагировать на исключения во время некоторой операции, то класс должен предоставить обычную функцию (то есть не деструктор), которая эту операцию выполнит.</p>
</section><section><title><p>Правило 9: Никогда не вызывайте виртуальные функции в конструкторе или деструкторе</p>
</title><p>Начну с повторения: вы не должны вызывать виртуальные функции во время работы конструкторов или деструкторов, потому что эти вызовы будут делать не то, что вы думаете, и результатами их работы вы будете недовольны. Если вы – программист на Java или C#, то обратите на это правило особое внимание, потому что это в этом отношении C++ ведет себя иначе.</p>
<p>Предположим, что имеется иерархия классов для моделирования биржевых транзакций, то есть поручений на покупку, на продажу и т. д. Важно, чтобы эти транзакции было легко проверить, поэтому каждый раз, когда создается новый объект транзакции, в протокол аудита должна вноситься соответствующая запись. Следующий подход к решению данной проблемы выглядит разумным:</p>
<empty-line/><p><code>class Transaction { // базовый класс для всех</code></p>
<p><code>public: // транзакций</code></p>
<p><code>Transaction();</code></p>
<p><code>virtual void logTransaction() const = 0; // выполняет зависящую от типа</code></p>
<p><code>// запись в протокол</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>Transaction::Transaction() // реализация конструктора</code></p>
<p><code>{ // базового класса</code></p>
<p><code>...</code></p>
<p><code>logTransaction();</code></p>
<p><code>}</code></p>
<p><code>class BuyTransaction: public Transaction { // производный класс</code></p>
<p><code>public:</code></p>
<p><code>virtual void logTransaction() const = 0; // как протоколировать</code></p>
<p><code>// транзакции данного типа</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class SellTransaction: public Transaction { // производный класс</code></p>
<p><code>public:</code></p>
<p><code>virtual void logTransaction() const = 0; // как протоколировать</code></p>
<p><code>// транзакции данного типа</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Посмотрим, что произойдет при исполнении следующего кода:</p>
<empty-line/><p><code>BuyTransaction b;</code></p>
<empty-line/><p>Ясно, что будет вызван конструктор BuyTransaction, но сначала должен быть вызван конструктор Transaction, потому что части объекта, принадлежащие базовому классу, конструируются прежде, чем части, принадлежащие производному классу. В последней строке конструктора Transaction вызывается виртуальная функция logTransaction, тут-то и начинаются сюрпризы. Здесь вызывается та версия logTransaction, которая определена в классе Transaction, а не в BuyTransaction, несмотря на то что тип создаваемого объекта – BuyTransaction. Во время конструирования базового класса не вызываются виртуальные функции, определенные в производном классе. Объект ведет себя так, как будто он принадлежит базовому типу. Короче говоря, во время конструирования базового класса виртуальных функций не существует.</p>
<p>Есть веская причина для столь, казалось бы, неожиданного поведения. Поскольку конструкторы базовых классов вызываются раньше, чем конструкторы производных, то данные-члены производного класса еще не инициализированы во время работы конструктора базового класса. Это может стать причиной неопределенного поведения и близкого знакомства с отладчиком. Обращение к тем частям объекта, которые еще не были инициализированы, опасно, поэтому C++ не дает такой возможности.</p>
<p>Есть даже более фундаментальные причины. Пока над созданием объекта производного класса трудится конструктор базового класса, типом объекта <emphasis>является</emphasis> базовый класс. Не только виртуальные функции считают его таковым, но и все прочие механизмы языка, использующие информацию о типе во время исполнения (например, описанный в правиле 27 оператор dynamic_cast и оператор typeid). В нашем примере, пока работает конструктор Transaction, инициализируя базовую часть объекта BuyTransaction, этот объект относится к типу Transaction. Именно так его воспринимают все части C++, и в этом есть смысл: части объекта, относящиеся к BuyTransaction, еще не инициализированы, поэтому безопаснее считать, что их не существует вовсе. Объект не является объектом производного класса до тех пор, пока не начнется исполнение конструктора последнего.</p>
<p>То же относится и к деструкторам. Как только начинает исполнение деструктор производного класса, предполагается, что данные-члены, принадлежащие этому классу, не определены, поэтому C++ считает, что их больше не существует. При входе в деструктор базового класса наш объект становится объектом базового класса, и все части C++ – виртуальные функции, оператор dynamic_cast и т. п. – воспринимают его именно так.</p>
<p>В приведенном выше примере кода конструктор Transaction напрямую обращается к виртуальной функции, что представляет собой откровенное нарушение принципов, описанных в данном правиле. Это нарушение легко обнаружить, поэтому некоторые компиляторы выдают предупреждение (а другие – нет; дискуссию о предупреждениях см. в правиле 53). Но даже без такого предупреждения ошибка наверняка проявится до времени исполнения, потому что функция logTransaction в классе Transaction объявлена чисто виртуальной. Если только она не была где-то определена (маловероятно, но возможно – см. правило 34), то такая программа не скомпонуется: компоновщик не найдет необходимую реализацию Transaction::logTransaction.</p>
<p>Не всегда так просто обнаружить вызов виртуальной функции во время работы конструктора или деструктора. Если Transaction имеет несколько конструкторов, каждый из которых выполняет одну и ту же работу, то следует проектировать программу так, чтобы избежать дублирования кода, поместив общую часть инициализации, включая вызов logTransaction, в закрытую невиртуальную функцию инициализации, скажем, init:</p>
<empty-line/><p><code>class Transaction {</code></p>
<p><code>public:</code></p>
<p><code>Transaction()</code></p>
<p><code>{ init(); } // вызов невиртуальной функции</code></p>
<p><code>Virtual void logTransaction() const = 0;</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>void init()</code></p>
<p><code>{</code></p>
<p><code>...</code></p>
<p><code>logTransaction(); // а это вызов виртуальной</code></p>
<p><code>// функции!</code></p>
<p><code>}</code></p>
<p><code>};</code></p>
<empty-line/><p>Концептуально этот код не отличается от приведенного выше, но он более коварный, потому что обычно будет скомпилирован и скомпонован без предупреждений. В этом случае, поскольку logTransaction – чисто виртуальная функция класса Transaction, в момент ее вызова большинство систем времени исполнения прервут программу (обычно выдав соответствующее сообщение). Однако если logTransaction будет «нормальной» виртуальной функцией, у которой в классе Transaction есть реализация, то эта функция и будет вызвана, и программа радостно продолжит работу, оставляя вас в недоумении, почему при создании объекта производного класса была вызвана неверная версия logTransaction. Единственный способ избежать этой проблемы – убедиться, что ни один из конструкторов и деструкторов не вызывает виртуальных функций при создании или уничтожении объекта, и что все функции, к которым они обращаются, следуют тому же правилу.</p>
<p>Но как вы можете убедиться в том, что вызывается правильная версия log-Transaction при создании любого объекта из иерархии Transaction? Понятно, что вызов виртуальной функции объекта из конструкторов не годится.</p>
<p>Есть разные варианты решения этой проблемы. Один из них – сделать функцию logTransaction невиртуальной в классе Transaction, затем потребовать, чтобы конструкторы производного класса передавали необходимую для записи в протокол информацию конструктору Transaction. Эта функция затем могла бы безопасно вызвать невиртуальную logTransaction. Примерно так:</p>
<empty-line/><p><code>class Transaction {</code></p>
<p><code>public:</code></p>
<p><code>explicit Transaction(const std::string&amp; loginfo);</code></p>
<p><code>void logTransaction(const std::string&amp; loginfo) const; // теперь –</code></p>
<p><code>// невиртуальная</code></p>
<p><code>// функция</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>Transaction::Transaction(const std::string&amp; loginfo)</code></p>
<p><code>{</code></p>
<p><code>...</code></p>
<p><code>logTransaction(loginfo); // теперь –</code></p>
<p><code>// невиртуальный</code></p>
<p><code>// вызов</code></p>
<p><code>}</code></p>
<p><code>class BuyTransaction : public Transaction {</code></p>
<p><code>public:</code></p>
<p><code>BuyTransaction( <emphasis>parameters </emphasis>)</code></p>
<p><code>: Transaction(createLogString( <emphasis>parameters </emphasis>)) // передать информацию</code></p>
<p><code>{...} // для записи в протокол</code></p>
<p><code>... // конструктору базового</code></p>
<p><code>// класса</code></p>
<p><code>private:</code></p>
<p><code>static std::string createLogString( <emphasis>parameters </emphasis>);</code></p>
<p><code>}</code></p>
<empty-line/><p>Другими словами, если вы не можете вызывать виртуальные функции из конструктора базового класса, то можете компенсировать это передачей необходимой информации конструктору базового класса из конструктора производного.</p>
<p>В этом примере обратите внимание на применение закрытой статической функции createLogString в BuyTransaction. Использование вспомогательной функции для создания значения, передаваемого конструктору базового класса, часто удобнее (и лучше читается), чем отслеживание длинного списка инициализации членов для передачи базовому классу того, что ему нужно. Сделав эту функцию статической, мы избегаем опасности нечаянно сослаться на неинициализированные данные-члены класса BuyTransaction. Это важно, поскольку тот факт, что эти данные-члены еще не определены, и является основной причиной, почему нельзя вызывать виртуальные функции из конструкторов и деструкторов.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Не вызывайте виртуальные функции во время работы конструкторов и деструкторов, потому что такие вызовы никогда не дойдут до производных классов, расположенных в иерархии наследования ниже того, который сейчас конструируется или уничтожается.</p>
</section><section><title><p>Правило 10: Операторы присваивания должны возвращать ссылку на *this</p>
</title><p>Одно из интересных свойств присваивания состоит в том, что такие операции можно выполнять последовательно:</p>
<empty-line/><p><code>int x,y,z;</code></p>
<p><code>x = y = z = 15; // цепочка присваиваний</code></p>
<empty-line/><p>Также интересно, что оператор присваивания правоассоциативен, поэтому приведенный выше пример присваивания интерпретируется следующим образом:</p>
<empty-line/><p><code>x = (y = (z = 15));</code></p>
<empty-line/><p>Здесь переменной z присваивается значение 15, затем результат присваивания (новое значение z) присваивается переменной y, после чего результат (новое значение y) присваивается переменной x.</p>
<p>Достигается это за счет того, что оператор присваивания возвращает ссылку на свой левый аргумент, и этому соглашению вы должны следовать при реализации операторов присваивания в своих классах:</p>
<empty-line/><p><code>class Widget {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>Widget&amp; operator=(const Widget&amp; rhs) // возвращаемый тип – ссылка</code></p>
<p><code>{ // на текущий класс</code></p>
<p><code>...</code></p>
<p><code>return *this; // вернуть объект из левой части</code></p>
<p><code>} // выражения</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Это соглашение касается всех операторов присваивания, а не только стандартной формы, показанной выше. Следовательно:</p>
<empty-line/><p><code>class Widget {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>Widget&amp; operator+=(const Widget&amp; rhs) // соглашение распространяется на</code></p>
<p><code>{ // +=, -=, *=, и т. д.</code></p>
<p><code>...</code></p>
<p><code>return *this;</code></p>
<p><code>}</code></p>
<p><code>Widget&amp; operator=(int rhs) // это относится даже</code></p>
<p><code>{ // к параметрам разных типов</code></p>
<p><code>...</code></p>
<p><code>return *this;</code></p>
<p><code>}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Это всего лишь соглашение. Если программа его не придерживается, она тем не менее скомпилируется. Однако ему следуют все встроенные типы, как и все типы (см. правило 54) стандартной библиотеки (то есть string, vector, complex, tr1::shared_ptr и т. д.). Если у вас нет веской причины нарушать соглашение, не делайте этого.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Пишите операторы присваивания так, чтобы они возвращали ссылку на *this.</p>
</section><section><title><p>Правило 11: В operator= осуществляйте проверку на присваивание самому себе</p>
</title><p>Присваивание самому себе возникает примерно в такой ситуации:</p>
<empty-line/><p><code>class Widget {...};</code></p>
<p><code>Widget w;</code></p>
<p><code>...</code></p>
<p><code>w = w; // присваивание себе</code></p>
<empty-line/><p>Код выглядит достаточно нелепо, однако он совершенно корректен, и в том, что программисты на такое способны, вы можете не сомневаться ни секунды.</p>
<p>Кроме того, присваивание самому себе не всегда так легко узнаваемо. Например:</p>
<empty-line/><p><code>a[i] = a[j]; // потенциальное присваивание себе</code></p>
<empty-line/><p>это присваивание себе, если i и j равны одному и тому же значению, и</p>
<empty-line/><p><code>*px = *py; // потенциальное присваивание себе</code></p>
<empty-line/><p>тоже становится присваиванием самому себе, если окажется, что px и py указывают на одно и то же.</p>
<p>Эти менее очевидные случаи присваивания себе являются результатом совмещения имен <emphasis>(aliasing),</emphasis> когда для ссылки на объект существует более одного способа. Вообще, программа, которая оперирует ссылками или указателями на различные объекты одного и того же типа, должна считаться с тем, что эти объекты могут совпадать. Необязательно даже, чтобы два объекта имели одинаковый тип, ведь если они принадлежат к одной иерархии классов, то ссылка или указатель на базовый класс может в действительно относиться к объекту производного класса:</p>
<empty-line/><p><code>class Base {...};</code></p>
<p><code>class Derived: public Base {...};</code></p>
<p><code>void doSomething(const Base&amp; rb, // rb и *pd могут быть одним и тем же</code></p>
<p><code>Derived * pd); // объектом</code></p>
<empty-line/><p>Если вы следуете правилам 13 и 14, то всегда пользуетесь объектами для управления ресурсами; следите за тем, чтобы управляющие объекты правильно вели себя при копировании. В таком случае операторы присваивания должны быть безопасны относительно присваивания самому себе. Если вы пытаетесь управлять ресурсами самостоятельно (а как же иначе, если вы пишете класс для управления ресурсами), то можете попасть в ловушку, нечаянно освободив ресурс до его использования. Например, предположим, что вы создали класс, который содержит указатель на динамически распределенный объект класса Bitmap:</p>
<empty-line/><p><code>class Bitmap {...};</code></p>
<p><code>class Widget {</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>Bitmap *pb; // указатель на объект, размещенный в куче</code></p>
<p><code>};</code></p>
<empty-line/><p>Ниже приведена реализация оператора присваивания operator=, которая выглядит совершенно нормально, но становится опасной в случае выполнения присваивания самому себе (она также небезопасна с точки зрения исключений, но сейчас не об этом).</p>
<empty-line/><p><code>Widget&amp;</code></p>
<p><code>Widget::operator=(const Widget&amp; rhs) // небезопасная реализация operator=</code></p>
<p><code>{</code></p>
<p><code>delete pb; // прекратить использование текущего</code></p>
<p><code>// объекта Bitmap</code></p>
<p><code>pb = new Bitmap(*rhs.pb); // начать использование копии объекта</code></p>
<p><code>// Bitmap, указанной в правой части</code></p>
<p><code>return *this; // см. правило 10</code></p>
<p><code>}</code></p>
<empty-line/><p>Проблема состоит в том, что внутри operator= *this (чему присваивается значение) и rhs (что присваивается) могут оказаться одним и тем же объектом. Если это случится, то delete уничтожит не только Bitmap, принадлежащий текущему объекту, но и Bitmap, принадлежащий объекту в правой части. По завершении работы этой функции Widget, который не должен был бы измениться в процессе присваивания самому себе, содержит указатель на удаленный объект!</p>
<p>Традиционный способ предотвратить эту ошибку состоит в том, что нужно выполнить проверку совпадения в начале operator=:</p>
<empty-line/><p><code>Widget&amp;</code></p>
<p><code>Widget::operator=(const Widget&amp; rhs) // небезопасная реализация operator=</code></p>
<p><code>{</code></p>
<p><code>if(this == &amp;rhs) return *this; // проверка совпадения: если</code></p>
<p><code>// присваивание самому себе, то</code></p>
<p><code>// ничего не делать</code></p>
<p><code>delete pb;</code></p>
<p><code>pb = new Bitmap(*rhs.pb);</code></p>
<p><code>return *this;</code></p>
<p><code>}</code></p>
<empty-line/><p>Это решает проблему, но я уже упоминал, что предыдущая версия оператора присваивания была не только опасна в случае присваивания себе, но и небезопасна в смысле исключений, и последняя опасность остается актуальной во второй версии. В частности, если выражение «new Bitmap» вызовет исключение (либо по причине недостатка свободной памяти, либо исключение возбудит конструктор копирования Bitmap), то Widget также будет содержать указатель на несуществующий Bitmap. Такие указатели – источник неприятностей. Их нельзя безопасно удалить, их даже нельзя разыменовывать. А вот потратить массу времени на отладку, выясняя, откуда они взялись, – это можно.</p>
<p>К счастью, существует способ одновременно сделать operator= безопасным в смысле исключений и безопасным по части присваивания самому себе. Поэтому все чаще программисты не занимаются специально присваиванием самому себе, а сосредоточивают усилия на достижении безопасности в смысле исключений. В правиле 29 эта проблема рассмотрена детально, а сейчас достаточно упомянуть, что во многих случаях продуманная последовательность операторов присваивания может обеспечить безопасность в смысле исключений (а заодно безопасность присваивания самому себе) кода. Например, ниже мы просто не удаляем pb до тех пор, пока не скопируем то, на что он указывает:</p>
<empty-line/><p><code>Widget&amp; Widget::operator=(const Widget&amp; rhs)</code></p>
<p><code>{</code></p>
<p><code>Bitmap *pOrig = pb; // запомнить исходный pb</code></p>
<p><code>pb = new Bitmap(*rhs.pb); // установить указатель pb на копию *pb</code></p>
<p><code>delete pOrig; // удалить исходный pb</code></p>
<p><code>return *this;</code></p>
<p><code>}</code></p>
<empty-line/><p>Теперь, если «new Bitmap» возбудит исключение, то pb (и объект Widget, которому он принадлежит) останется неизменным. Даже без проверки на совпадение здесь обрабатывается присваивание самому себе, потому что мы сделали копию исходного объекта Bitmap, удалили его, а затем направили указатель на сделанную копию. Возможно, это не самый эффективный способ обработать присваивание самому себе, но он работает.</p>
<p>Если вы печетесь об эффективности, то можете вернуть проверку на совпадение в начале функции. Но прежде спросите себя, как часто может происходить присваивание самому себе, потому что выполнение проверки тоже не обходится даром. Это делает код (исходный и объектный) чуть больше, а ветвление несколько снижает скорость исполнения. Эффективность предварительной выборки команд, кэширования и конвейеризации тоже может пострадать.</p>
<p>Альтернативой ручному упорядочиванию предложений в operator= может быть обеспечение и безопасности в смысле исключений, и безопасности присваивания самому себе за счет применения техники «копирования с обменом» («copy and swap»). Она тесно связана с безопасностью в смысле исключений, поэтому рассматривается в правиле 29. Тем не менее это достаточно распространенный способ написания operator=, и на него стоит взглянуть:</p>
<empty-line/><p><code>class Widget {</code></p>
<p><code>...</code></p>
<p><code>void swap(Widget&amp; rhs); // обмен данными *this и rhs</code></p>
<p><code>... // см. подробности в правиле 29</code></p>
<p><code>};</code></p>
<p><code>Widget&amp; Widget:: operator=(const Widget&amp; rhs)</code></p>
<p><code>{</code></p>
<p><code>Widget temp(rhs); // создать копию данных rhs</code></p>
<p><code>swap(tmp); // обменять данные *this с копией</code></p>
<p><code>return *this;</code></p>
<p><code>}</code></p>
<empty-line/><p>Здесь мы пользуемся тем, что: (1) оператор присваивания можно объявить как принимающим аргумент по значению и (2) передача объекта по значению означает создание копии этого объекта (см. правило 20):</p>
<empty-line/><p><code>Widget&amp; Widget::operator=(Widget rhs) // rhs – копия переданного объекта</code></p>
<p><code>{ // обратите внимание на передачу по</code></p>
<p><code>// значению</code></p>
<p><code>swap(rhs); // обменять данные *this с копией</code></p>
<p><code>return *this;</code></p>
<p><code>}</code></p>
<empty-line/><p>Лично меня беспокоит, что такой подход приносит ясность в жертву изощренности, но, перемещая операцию копирования из тела функции в конструирование параметра, компилятор иногда может сгенерировать более эффективный код.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Убедитесь, что operator= правильно ведет себя, когда объект присваивается самому себе. Для этого можно сравнить адреса исходного и целевого объектов, аккуратно упорядочить предложения или применить идиому копирования обменом.</p>
<p>• Убедитесь, что все функции, оперирующие более чем одним объектом, ведут себя корректно при совпадении двух или более объектов.</p>
</section><section><title><p>Правило 12: Копируйте все части объекта</p>
</title><p>В хорошо спроектированных объектно-ориентированных системах, которые инкапсулируют внутреннее устройство объектов, копированием занимаются только две функции: конструктор копирования и оператор присваивания. Назовем их <emphasis>функциями копирования.</emphasis> В правиле 5 я говорил, что компилятор генерирует копирующие функции при необходимости, и объяснял, что сгенерированные компилятором версии делают точно то, что вы ожидаете: копию всех данных исходного объекта.</p>
<p>Объявляя собственные копирующие функции, вы сообщаете компилятору, что реализация по умолчанию вам чем-то не нравится. Компилятор «обижается» и мстит оригинальным образом: он не сообщает, если в вашей реализации что-то неправильно.</p>
<p>Рассмотрим класс, представляющий заказчиков, в котором копирующие функции написаны вручную таким образом, что их вызовы протоколируются:</p>
<empty-line/><p><code>void logCall(const std::string&amp; funcName); // делает запись в протокол</code></p>
<p><code>class Customer {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>Customer(const Customer&amp; rhs);</code></p>
<p><code>Customer&amp; operator=(const Customer&amp; rhs);</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>std::string name;</code></p>
<p><code>};</code></p>
<p><code>Customer::Customer(const Customer&amp; rhs)</code></p>
<p><code>: name(rhs.name) // копировать данные rhs</code></p>
<p><code>{</code></p>
<p><code>logCall(“Конструктор копирования Customer”);</code></p>
<p><code>}</code></p>
<p><code>Customer&amp; Customer::operator=(const Customer&amp; rhs)</code></p>
<p><code>{</code></p>
<p><code>logCall(“Копирующий оператор присвоения Customer”);</code></p>
<p><code>name = rhs.name; // копировать данные rhs</code></p>
<p><code>return *this; // см. правило 10</code></p>
<p><code>}</code></p>
<empty-line/><p>Все здесь выглядит отлично, и на самом деле так оно и есть – до тех пор, пока в класс Customer не будет добавлен новый член:</p>
<empty-line/><p><code>class Date {...}; // для даты и времени</code></p>
<p><code>class Customer {</code></p>
<p><code>public:</code></p>
<p><code>... // как раньше</code></p>
<p><code>private:</code></p>
<p><code>std::string name;</code></p>
<p><code>Date lastTransaction;</code></p>
<p><code>};</code></p>
<empty-line/><p>С этого момента существующие функции копирования копируют только часть объекта, именно поле name, но не поле lastTransaction. Однако большинство компиляторов ничего не скажут об этом даже при установке максимального уровня диагностики (см. также правило 53). Вот к чему приводит самостоятельное написание функций копирования. Вы отвергаете функции, которые генерирует компилятор, поэтому он не сообщает, что ваш код не полон. Решение очевидно: если вы добавляете новый член в класс, то должны обновить и копирующие функции (а также все конструкторы [см. правила 4 и 45] и все нестандартные варианты operator= в классе [пример в правиле 10]; если вы забудете, то компилятор вряд ли напомнит).</p>
<p>Одним из наиболее коварных случаев проявления этой ситуации является наследование. Рассмотрим пример:</p>
<empty-line/><p><code>class PriorityCustomer: public Customer { // производный класс</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>PriorityCustomer(const PriorityCustomer&amp; rhs);</code></p>
<p><code>PriorityCustomer&amp; operator=(const PriorityCustomer&amp; rhs);</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>int priority;</code></p>
<p><code>};</code></p>
<p><code>PriorityCustomer::PriorityCustomer(const PriorityCustomer&amp; rhs)</code></p>
<p><code>: priority(rhs.priority)</code></p>
<p><code>{</code></p>
<p><code>logCall(“Конструктор копирования PriorityCustomer”);</code></p>
<p><code>}</code></p>
<p><code>PriorityCustomer&amp;</code></p>
<p><code>PriorityCustomer::operator=(const PriorityCustomer&amp; rhs)</code></p>
<p><code>{</code></p>
<p><code>logCall(“Оператор присваивания PriorityCustomer”);</code></p>
<p><code>priority = rhs. Priority;</code></p>
<p><code>return *this;</code></p>
<p><code>}</code></p>
<empty-line/><p>На первый взгляд, копирующие функции в классе PriorityCustomer копируют все его члены, но приглядитесь внимательнее. Да, они копируют данные-члены, которые объявлены в PriorityCustomer, но каждый объект PriorityCustomer также содержит члены, унаследованные от Customer, а они-то не копируются вовсе! Конструктор копирования PriorityCustomer не специфицирует аргументы, которые должны быть переданы конструктору его базового класса (то есть не упоминает Customer в своем списке инициализации членов), поэтому часть Customer объекта PriorityCustomer будет инициализирована конструктором Customer, не принимающим аргументов, конструктором по умолчанию (если он отсутствует, то такой код просто не скомпилируется). Этот конструктор выполняет инициализацию по умолчанию членов name и lastTransaction.</p>
<p>Для оператора присваивания PriorityCustomer ситуация мало чем отличается. Он не выполняет никаких попыток модифицировать данные-члены базового класса, поэтому они остаются неизменными.</p>
<p>Всякий раз, когда вы самостоятельно пишете копирующие функции для производного класса, позаботьтесь о том, чтобы скопировать части базового класса. Обычно они находятся в закрытом разделе класса (см. правило 22), поэтому у вас нет прямого доступа к ним. Поэтому копирующие функции производного класса должны вызывать соответствующие функции базового класса:</p>
<empty-line/><p><code>PriorityCustomer::PriorityCustomer(const PriorityCustomer&amp; rhs)</code></p>
<p><code>: Customer(rhs), // вызвать копирующий конструктор</code></p>
<p><code>// базового класса</code></p>
<p><code>priority(rhs.priority)</code></p>
<p><code>{</code></p>
<p><code>logCall(“Конструктор копирования PriorityCustomer”);</code></p>
<p><code>}</code></p>
<p><code>PriorityCustomer&amp;</code></p>
<p><code>PriorityCustomer::operator=(const PriorityCustomer&amp; rhs)</code></p>
<p><code>{</code></p>
<p><code>logCall(“Оператор присваивания PriorityCustomer”);</code></p>
<p><code>Customer::operator=(rhs); // присвоить значения данным-членам</code></p>
<p><code>// базового класса</code></p>
<p><code>priority = rhs. Priority;</code></p>
<p><code>return *this;</code></p>
<p><code>}</code></p>
<empty-line/><p>Значение фразы «копировать все части» в заголовке этого параграфа теперь должно быть понятно. Когда вы пишете копирующие функции, убедитесь, что (1) копируются все локальные данные-члены и (2) вызываются соответствующие копирующие функции всех базовых классов.</p>
<p>На практике эти две копирующие функции часто имеют похожие реализации, и у вас может возникнуть соблазн избежать дублирования кода за счет вызова одной функции из другой. Такое стремление похвально, но вызов одной копирующей функции из другой – неверный путь.</p>
<p>Нет смысла вызывать конструктор копирования из оператора присваивания, поскольку вы тем самым попытаетесь сконструировать объект, который уже существует. Это настолько бессмысленно, что даже не существует синтаксиса для такой операции. Есть синтаксис, который выглядит так, будто вы делаете это, хотя на самом деле он означает совсем иное. Есть также синтаксис, который позволяет это сделать, но совершенно неочевидным способом, причем при некоторых условиях ваш объект может быть поврежден. Поэтому я не покажу ни тот, ни другой. Просто примите как данность, что вызывать из оператора присваивания конструктор копирования не следует.</p>
<p>Попытка выполнить обратную операцию – из конструктора копирования вызвать оператор присваивания – также бессмысленна. Конструктор инициализирует новые объекты, а оператор присваивания работает с уже существующими и инициализированными объектами. Выполнять присваивание объекту, находящемуся в процессе конструирования, – значит делать с еще не инициализированным объектом что-то такое, что имеет смысл только для инициализированного объекта. Нонсенс! Даже не пытайтесь.</p>
<p>Но если вы обнаружите, что ваш конструктор копирования и оператор присваивания содержат похожий код, попробуйте избежать дублирования, создав функцию-член, которую будут вызывать оба. Такая функция обычно делается закрытой и часто называется init. Эта стратегия представляет безопасный, испытанный способ избежать дублирования кода в конструкторах копирования и операторах присваивания.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Копирующие функции должны гарантировать копирование всех членов-данных объекта и частей его базовых классов.</p>
<p>• Не пытайтесь реализовать одну из копирующих функций в терминах другой. Вместо этого поместите общую функциональность в третью функцию, которую вызовут обе.</p>
</section></section><section><title><p>Глава 3</p>
<p>Управление ресурсами</p>
</title><section><p>Ресурс – это нечто такое, что после использования должно быть возвращено системе. Если этого не сделать, случаются неприятности. В программах на C++ наиболее часто используемым ресурсом является динамическая память (если вы выделяете память и никогда ее не освобождаете, то получаете утечку памяти), но это лишь один из множества ресурсов, которыми нужно управлять. К другим часто используемым ресурсам относятся файловые дескрипторы, мьютексы, шрифты и кисти в графических интерфейсах пользователя (GUI), соединения с базой данных и сетевые сокеты. Независимо от вида ресурсов, важно, чтобы по окончании использования они были освобождены.</p>
<p>Попытки обеспечить это «вручную» представляют сложность при любых условиях, но если принять во внимание исключения, функции со многими путями возврата и приложения, модифицируемое программистами без отчетливого понимания последствий вносимых изменений, то становится ясно, что придумывать в каждом случае особый способ управления ресурсами нежелательно.</p>
<p>Эта глава начинается с прямого, базирующегося на объектах подхода к управлению ресурсами, построенного на имеющейся в C++ поддержке для конструкторов, деструкторов и операций копирования. Опыт показывает, что при дисциплинированном подходе можно исключить почти все проблемы с управлением ресурсами. Следующие далее правила посвящены исключительно управлению памятью. Каждое следующее правило уточняет предыдущие: объекты, управляющие памятью, должны делать это правильно.</p>
</section><section><title><p>Правило 13: Используйте объекты для управления ресурсами</p>
</title><p>Предположим, что мы работаем с библиотекой, моделирующей инвестиции (то есть акции, облигации и т. п.), и классы, представляющие разные виды инвестиций, наследуются от корневого класса Investment:</p>
<empty-line/><p><code>class Investment {...} // корневой класс иерархии</code></p>
<p><code>// типов инвестиций</code></p>
<empty-line/><p>Предположим далее, что библиотека предоставляет объекты, описывающие конкретные инвестиции, с помощью фабричной функции (см. правило 7):</p>
<empty-line/><p><code>Investment *createInvestment(); // возвращает указатель на динамически</code></p>
<p><code>// распределенный объект в иерархии</code></p>
<p><code>// Investment: вызвавший клиент обязан</code></p>
<p><code>// удалить его (параметры для простоты</code></p>
<p><code>// опущены)</code></p>
<empty-line/><p>Как следует из комментария, пользователь, вызвавший createlnvestment, отвечает за удаление объекта, возвращенного этой функцией, по окончании его использования. Рассмотрим теперь функцию f, которая это делает:</p>
<empty-line/><p><code>void f()</code></p>
<p><code>{</code></p>
<p><code>Investment *pInv = createInvestment(); // вызвать фабричную функцию</code></p>
<p><code>... // использовать pInv</code></p>
<p><code>delete pInv; // освободить память, занятую</code></p>
<p><code>} // объектом</code></p>
<empty-line/><p>Выглядит хорошо, но есть несколько случаев, когда f не удастся удалить объект инвестиций, полученный от createlnvestment. Где-нибудь внутри непоказанной части функции может встретиться предложение return. Если такой возврат будет выполнен, то управление никогда не достигнет оператора delete. Похожая ситуация может случиться, если вызов createlnvestment и delete поместить в в цикл, и этот цикл будет прерван в результате выполнения goto или continue. И наконец, некоторые предложения внутри части, обозначенной «…», могут возбудить исключение. И в этом случае управление не дойдет до оператора delete. Независимо от того, почему delete будет пропущен, мы потеряем не только память, выделенную для объекта Investment, но и все ресурсы, которые он захватил.</p>
<p>Конечно, тщательное программирование может предотвратить ошибки подобного рода, но подумайте о том, как может измениться код со временем. При сопровождении программы кто-то может добавить предложение return или continue, не вполне понимая последствий своих действий для стратегии управления ресурсами, реализованной в данной функции. Хуже того, часть «…» функции f может вызвать функцию, которая никогда не возбуждала исключений, но начнет это делать после некоторого «усовершенствования». То есть полагаться на то, что f всегда доберется до своего оператора delete, просто нельзя.</p>
<p>Чтобы обеспечить освобождение ресурса, возвращенного createlnvestment, нам нужно инкапсулировать ресурс внутри объекта, чей деструктор автоматически освободит его, когда управление покинет функцию f. Фактически это половина идеи дела: заключая ресурс в объект, мы можем положиться на автоматический вызов деструкторов C++, чтобы гарантировать их освобождение. (Вторую половину мы обсудим чуть ниже.)</p>
<p>Многие ресурсы динамически выделяются из «кучи», используются внутри одного блока или функции и должны быть освобождены, когда управление покидает этот блок или функцию. Для таких ситуаций предназначен класс стандартной библиотеки auto_ptr. Класс auto_ptr описывает объект, подобный указателю (интеллектуальный указатель), чей деструктор автоматически вызывает delete для того, на что он указывает. Вот как использовать auto_ptr для предотвращения потенциальной опасности утечки ресурсов в нашей функции f:</p>
<p><code>void f()</code></p>
<p><code>{</code></p>
<p><code>std::auto_ptr&lt;Investment&gt; pInv(createInvestment()); // вызов фабричной</code></p>
<p><code>// функции</code></p>
<p><code>... // использование pInv как раньше</code></p>
<p><code>} // автоматическое удаление pInv</code></p>
<p><code>// деструктором auto_ptr</code></p>
<empty-line/><p>Этот простой пример демонстрирует два наиболее существенных аспекта применения объектов для управления ресурсами:</p>
<p><strong>• Ресурс захватывается и сразу преобразуется объект, управлящий им. </strong>В приведенном примере ресурс, возвращенный функцией createInvestment, используется для инициализации auto_ptr, который будет им управлять. Фактически идею использования объектов для управления ресурсами часто называют <emphasis>Получение Ресурса Есть Инициализация</emphasis> (Resource Acquisition Is Initialization – RAII), поскольку нередко приходится получать ресурс и инициализировать объект управления ресурсом в одном и том же предложении. Иногда полученные ресурсы присваиваются управляющему объекту вместо инициализации, но в любом случае каждый ресурс сразу после получения преобразуется в управляющий им объект.</p>
<p>• <strong>Управляющие ресурсами объекты используют свои деструкторы для гарантии освобождения ресурсов.</strong> Поскольку деструктор вызывается автоматически при уничтожении объекта (например, когда объект выходит из области действия), ресурсы корректно освобождаются независимо от того, как управление покидает блок. Ситуация осложняется, когда в ходе освобождения ресурса может возникнуть исключение, но эта тема обсуждается в правиле 8, поэтому сейчас мы о ней говорить не будем.</p>
<p>Так как деструктор auto_ptr автоматически удаляет то, на что указывает, важно, чтобы ни в какой момент времени не существовало более одного auto_ptr, указывающего на один и тот же объект. Если такое случается, то объект будет удален более одного раза, что обязательно приведет к неопределенному поведению. Чтобы предотвратить такие проблемы, объекты auto_ptr обладают необычным свойством: при копировании (посредством копирующих конструкторов или операторов присваивания) внутренний указатель в старом объекте становится равным нулю, а новый объект получает ресурс в свое монопольное владение!</p>
<empty-line/><p><code>std::auto_ptr&lt;Investment&gt; // pInv1 указывает на объект,</code></p>
<p><code>pInv1(createInvestment()); // возвращенный createInvestment()</code></p>
<p><code>std::auto_ptr&lt;Investment&gt; pInv2(pInv1); // pInv2 теперь указывает на объект,</code></p>
<p><code>// а pInv1 равен null</code></p>
<p><code>pInv1 = pInv2; // теперь pInv1 указывает на объект,</code></p>
<p><code>// а pInv2 равно null</code></p>
<empty-line/><p>Это странное поведение при копировании плюс лежащее в его основе требование о том, что ни на какой ресурс, управляемый auto_ptr, не должен указывать более чем один auto_ptr, означает, что auto_ptr – не всегда является наилучшим способом управления динамически выделяемыми ресурсами. Например, STL-контейнеры требуют, чтобы их содержимое при копировании вело себя «нормально», поэтому помещать в них объекты auto_ptr нельзя.</p>
<p>Альтернатива auto_ptr – это <emphasis>интеллектуальные указатели с подсчетом ссылок (reference-counting smart pointer – RCSP).</emphasis> RCSP – это интеллектуальный указатель, который отслеживает, сколько объектов указывают на определенный ресурс, и автоматически удаляет ресурс, когда никто на него не ссылается. Следовательно, RCSP ведет себя подобно сборщику мусора. Но, в отличие от сборщика мусора, RCSP не может разорвать циклические ссылки (когда два неиспользуемых объекта указывают друг на друга).</p>
<p>Класс tr1::shared_prt из библиотеки TR1 (см. правило 54) – это типичный пример RCSP, поэтому вы можете написать:</p>
<empty-line/><p><code>void f()</code></p>
<p><code>{</code></p>
<p><code>...</code></p>
<p><code>std::tr1::shared_ptr&lt;Investment&gt;</code></p>
<p><code>pInv(createStatement()); // вызвать фабричную функцию</code></p>
<p><code>... // использовать pInv как раньше</code></p>
<p><code>} // автоматически удалить pInv</code></p>
<p><code>// деструктором shared_ptr</code></p>
<empty-line/><p>Этот код выглядит почти так же, как и использующий auto_ptr, но shared_ptr при копировании ведет себя гораздо более естественно:</p>
<empty-line/><p><code>void f()</code></p>
<p><code>{</code></p>
<p><code>...</code></p>
<p><code>std::tr1::shared_ptr&lt;Investment&gt; // pInv1 указывает на объект,</code></p>
<p><code>pInv1(createStatement()); // возвращенный createInvestment</code></p>
<p><code>std::tr1::shared_ptr&lt;Investment&gt; // теперь оба объекта pInv1 и pInv2</code></p>
<p><code>pInv2(pInv1); // указывают на объект</code></p>
<p><code>pInv1 = pInv2; // ничего не изменилось</code></p>
<p><code>...</code></p>
<p><code>} // pInv1 и pInv2 уничтожены, а объект,</code></p>
<p><code>// на который они указывали,</code></p>
<p><code>// автоматически удален</code></p>
<empty-line/><p>Поскольку копирование объектов tr1::shared_ptr работает «как ожидается», то они могут быть использованы в качестве элементов STL-контейнеров, а также в других случаях, когда непривычное поведение auto_ptr нежелательно.</p>
<p>Однако не заблуждайтесь. Это правило посвящено не auto_ptr и tr1::shared_ptr, или любым другим типам интеллектуальных указателей. Здесь мы говорим о важности использования объектов для управления ресурсами. auto_ptr и tr1::shared_ptr – всего лишь примеры объектов, которые делают это. (Более подробно о tr1::shared_ptr читайте в правилах 14, 18 и 54.)</p>
<p>И auto_ptr, и tr1::shared_ptr в своих деструкторах используют оператор delete, а не delete[]. (Разница между ними описана в правиле 16.) Это значит, что нельзя применять auto_ptr и tr1::shared_ptr к динамически выделенным массивам, хотя, как это ни прискорбно, следующий код скомпилируется:</p>
<empty-line/><p><code>std::auto_ptr&lt;std::string&gt; // плохая идея! Будет</code></p>
<p><code>aps(new std::string[10]); // использована не та форма</code></p>
<p><code>// оператора delete</code></p>
<p><code>std::tr1::shared_ptr&lt;int&gt; spi(new int[1024]); // та же проблема</code></p>
<empty-line/><p>Вас может удивить, что не предусмотрено ничего подобного auto_ptr или tr1::shared_ptr для работы с динамически выделенными массивами – ни в C++, ни даже в TR1. Это объясняется тем, что такие массивы почти всегда можно заменить векторами или строками (vector и string). Если вы все-таки считаете, что было бы неплохо иметь auto_ptr и tr1::shared_ptr для массивов, обратите внимание на библиотеку Boost (см. правило 55). Там вы найдете классы boost::scoped_array и boost::shared_array, которые предоставляют нужное вам поведение.</p>
<p>Излагаемые здесь правила по использованию объектов для управления ресурсами предполагают, что если вы освобождаете ресурсы вручную (например, применяя delete помимо того, который содержится в деструкторе управляющего ресурсами класса), то поступаете неправильно. Готовые классы для управления ресурсами – вроде auto_ptr и tr1::shared_ptr – часто облегчают выполнение советов из настоящего правила, но иногда приходится иметь дело с ресурсами, для которых поведение этих классов неадекватно. В таких случаях вам придется разработать собственные классы управления ресурсами. Это не так уж трудно сделать, но нужно принять во внимание некоторые соображения (см. правила 14 и 15).</p>
<p>И в качестве завершающего комментария я должен сказать, что возврат из функции createInvestment обычного указателя – это путь к утечкам ресурсов, потому что после обращения к ней очень просто забыть вызвать delete для этого указателя. (Даже если используются auto_ptr или tr1::shared_ptr для выполнения delete, нужно не забыть «обернуть» возвращенное значение интеллектуальным указателем.) Чтобы решить эту проблему, нам придется изменить интерфейс createInvestment, и это станет темой правила 18.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Чтобы предотвратить утечку ресурсов, используйте объекты RAII, которые захватывают ресурсы в своих конструкторах и освобождают в деструкторах.</p>
<p>• Два часто используемых класса RAII – это tr1::shared_ptr и auto_ptr. Обычно лучше остановить выбор на классе tr1::shared_ptr, потому что его поведение при копировании соответствует интуитивным ожиданиям. Что касается auto_ptr, то после копирования он уже не указывает ни на какой объект.</p>
</section><section><title><p>Правило 14: Тщательно продумывайте поведение при копировании классов, управляющих ресурсами</p>
</title><p>В правиле 13 изложена идея <emphasis>Получение Ресурса Есть Инициализация</emphasis> (Resource Acquisition Is Initialization – RAII), лежащая в основе создания управляющих ресурсами классов. Было также показано, как эта идея воплощается в классах auto_ptr и tr1::shared_ptr для управления динамически выделяемой из кучи памятью. Но не все ресурсы имеют дело с «кучей», и для них интеллектуальные указатели вроде auto_ptr и tr1::shared_ptr обычно не подходят. Время от времени вы будете сталкиваться со случаями, когда понадобится создать собственный класс для управления ресурсами.</p>
<p>Например, предположим, что вы используете написанный на языке C интерфейс для работы с мьютексами – объектами типа Mutex, в котором есть функции lock и unlock:</p>
<empty-line/><p><code>void lock(Mutex *pm); // захватить мьютекс, на который указывает pm</code></p>
<p><code>void unlock(Mutex *pm); // освободить семафор</code></p>
<empty-line/><p>Чтобы гарантировать, что вы не забудете освободить ранее захваченный Mutex, можно создать управляющий класс. Базовая структура такого класса продиктована принципом RAII, согласно которому ресурс захватывается во время конструирования объекта и освобождается при его уничтожении:</p>
<empty-line/><p><code>class Lock {</code></p>
<p><code>public:</code></p>
<p><code>explicit Lock(Mutex *pm)</code></p>
<p><code>: mutexPtr(pm)</code></p>
<p><code>{lock(mutexPtr);} // захват ресурса</code></p>
<p><code>~Lock() {unlock(mutexPtr);} // освобождение ресурса</code></p>
<p><code>private:</code></p>
<p><code>Mutex *mutexPtr;</code></p>
<p><code>};</code></p>
<empty-line/><p>Клиенты используют класс Lock, как того требует идиома RAII:</p>
<empty-line/><p><code>Mutex m; // определить мьютекс, который вам нужно использовать</code></p>
<p><code>...</code></p>
<p><code>{ // создать блок для определения критической секции</code></p>
<p><code>Lock ml(&amp;m); // захватить мьютекс</code></p>
<p><code>... // выполнить операции критической секции</code></p>
<p><code>} // автоматически освободить мьютекс в конце блока</code></p>
<empty-line/><p>Все прекрасно, но что случится, если скопировать объект Lock?</p>
<empty-line/><p><code>Lock ml1(&amp;m); // захват m</code></p>
<p><code>Lock ml2(ml1); // копирование m1 в m2 – что должно произойти?</code></p>
<empty-line/><p>Это частный пример общего вопроса, с которым сталкивается каждый разработчик классов RAII: что должно происходить при копировании RAII-объекта? В большинстве случаев выбирается один из двух вариантов:</p>
<p><strong>• Запрет копирования.</strong> Во многих случаях не имеет смысла разрешать копирование объектов RAII. Вероятно, это справедливо для класса вроде Lock, потому что редко нужно иметь копии примитивов синхронизации (каковым является мьютекс). Когда копирование RAII-объектов не имеет смысла, вы должны запретить его. Правило 6 объясняет, как это сделать: объявите копирующие операции закрытыми. Для класса Lock это может выглядеть так:</p>
<empty-line/><p><code>сlass Lock: private Uncopyable { // запрет копирования –</code></p>
<p><code>public: // см. правило 6</code></p>
<p><code>... // как раньше</code></p>
<p><code>};</code></p>
<empty-line/><p>• <strong>Подсчет ссылок на ресурс.</strong> Иногда желательно удерживать ресурс до тех пор, пока не будет уничтожен последний объект, который его использует. В этом случае при копировании RAII-объекта нужно увеличивать счетчик числа объектов, ссылающихся на ресурс. Так реализовано «копирование» в классе tr1::shared_ptr.</p>
<p>Часто RAII-классы реализуют копирование с подсчетом ссылок путем включения члена типа tr1::shared_ptr&lt;Mutex&gt;. К сожалению, поведение по умолчанию tr1::shared_ptr заключается в том, что он удаляет то, на что указывает, когда значение счетчика ссылок достигает нуля, а это не то, что нам нужно. Когда мы работаем с Mutex, нам нужно просто разблокировать его, а не выполнять delete.</p>
<p>К счастью, tr1::shared_ptr позволяет задать «чистильщика» – функцию или функциональный объект, который должен быть вызван, когда счетчик ссылок достигает нуля (эта функциональность не предусмотрена для auto_ptr, который <emphasis>всегда</emphasis> удаляет указатель). Функция-чистильщик – это необязательный второй параметр конструктора tr1::shared_ptr, поэтому код должен выглядеть так:</p>
<empty-line/><p><code>class Lock {</code></p>
<p><code>public:</code></p>
<p><code>explicit Lock(Mutex *pm) // инициализировать shared_ptr объектом</code></p>
<p><code>: mutexPtr(pm, unlock) // Mutex, на который он будет</code></p>
<p><code>// указывать, функцией unlock</code></p>
<p><code>{ // в качестве чистильщика</code></p>
<p><code>lock(mutexPtr.get());</code></p>
<p><code>}</code></p>
<p><code>private:</code></p>
<p><code>std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr; // использовать</code></p>
<p><code>}; // shared_ptr вместо</code></p>
<p><code>// простого указателя</code></p>
<empty-line/><p>Отметим, что в этом примере в классе Lock больше нет деструктора. Просто в нем отпала необходимость. В правиле 5 объясняется, что деструктор класса (независимо от того, сгенерирован он компилятором или определен пользователем) автоматически вызывает деструкторы нестатических данных-членов класса. В нашем примере это mutexPtr. Но деструктор mutexPtr автоматически вызовет функцию-чистильщик tr1::shared_ptr (в данном случае unlock), когда счетчик ссылок на мьютекс достигнет нуля. (Пользователи, которые будут знакомиться с исходным текстом класса, вероятно, будут благодарны за комментарии, указывающие, что вы не забыли о деструкторе, а просто положились на поведение по умолчанию деструктора, сгенерированного компилятором.)</p>
<p>• <strong>Копирование управляемого ресурса.</strong> Иногда допустимо иметь столько копий ресурса, сколько вам нужно, и единственная причина использования класса, управляющего ресурсами, – гарантировать, что каждая копия ресурса будет освобождена по окончании работы с ней. В этом случае копирование управляющего ресурсом объекта означает также копирование самого ресурса, который в него «обернут». То есть копирование управляющего ресурсом объекта выполняет «глубокое копирование». Некоторые реализации стандартного класса string включают указатели на память из «кучи», где хранятся символы, входящие в строку. Объект такого класса содержит указатель на память из «кучи». Когда объект string копируется, то копируется и указатель, и память, на которую он указывает. Здесь мы снова встречаемся с «глубоким копированием».</p>
<p><strong>• Передача владения управляемым ресурсом.</strong> Иногда нужно гарантировать, что только один RAII-объект ссылается на ресурс, и при копировании такого объекта RAII владение ресурсом передается объекту-копии. Как объясняется в правиле 13, это означает копирование с применением auto_ptr.</p>
<p>Копирующие функции (конструктор копирования и оператор присваивания) могут быть сгенерированы компилятором, но если сгенерированные версии не делают того, что вам нужно (правило 5 объясняет поведение по умолчанию), придется написать их самостоятельно. Иногда имеет смысл поддерживать обобщенные версии этих функций. Такой подход описан в правиле 45.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Копирование RAII-объектов влечет за собой копирование ресурсов, которыми они управляют, поэтому поведение ресурса при копировании определяет поведение RAII-объекта.</p>
<p>• Обычно при реализации RAII-классов применяется одна из двух схем: запрет копирования или подсчет ссылок, но возможны и другие варианты.</p>
</section><section><title><p>Правило 15: Предоставляйте доступ к самим ресурсам из управляющих ими классов</p>
</title><p>Управляющие ресурсами классы заслуживают всяческих похвал. Это бастион, защищающий от утечек ресурсов, а отсутствие таких утечек – фундаментальное свойство хорошо спроектированных систем. В идеальном мире вы можете положиться на эти классы для любых взаимодействий с ресурсами, не утруждая себя доступом к ним напрямую. Но мир неидеален. Многие программные интерфейсы требуют доступа к ресурсам без посредников. Если вы не планируете отказаться от использования таких интерфейсов (что редко имеет смысл на практике), то должны как-то обойти управляющий объект и работать с самим ресурсом.</p>
<p>Например, в правиле 13 изложена идея применения интеллектуальных указателей вроде auto_ptr или tr1::shared_ptr для хранения результата вызова фабричной функции createInvestment:</p>
<empty-line/><p><code>std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment()); // èç ïðàâèëà 13</code></p>
<empty-line/><p>Предположим, есть функция, которую вы хотите применить при работе с объектами класса Investment:</p>
<empty-line/><p><code>int daysHeld(const Investment *pi); // возвращает количество дней</code></p>
<p><code>// хранения инвестиций</code></p>
<empty-line/><p>Вы хотите вызывать ее так:</p>
<empty-line/><p><code>int days = daysHeld(pInv); // ошибка!</code></p>
<empty-line/><p>но этот код не скомпилируется: функция daysHeld ожидает получить указатель на объект класса Investment, а вы передаете ей объект типа tr1::shared_ptr &lt;Investment&gt;.</p>
<p>Необходимо как-то преобразовать объект RAII-класса (в данном случае tr1::shared_ptr) к типу управляемого им ресурса (то есть Investment*). Есть два основных способа сделать это: неявное и явное преобразование.</p>
<p>И tr1::shared_ptr, и auto_ptr предоставляют функцию-член get для выполнения явного преобразования, то есть возврата (копии) указателя на управляемый объект:</p>
<empty-line/><p><code>int days = daysHeld(pInv.get()); // нормально, указатель, хранящийся</code></p>
<p><code>// в pInv, передается daysHeld</code></p>
<empty-line/><p>Как почти все классы интеллектуальных указателей, tr1::shared_ptr и auto_ptr перегружают операторы разыменования указателей (operator-&gt; и operator*), и это обеспечивает возможность неявного преобразования к типу управляемого указателя:</p>
<empty-line/><p><code>class Investment { // корневой класс иерархии</code></p>
<p><code>public: // типов инвестиций</code></p>
<p><code>bool isTaxFree() const;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>Investment *createInvestment(); // фабричная функция</code></p>
<p><code>std::tr1::shared_ptr&lt;Investment&gt; // имеем tr1::shared_ptr</code></p>
<p><code>pi1(createInvestment()); // для управления ресурсом</code></p>
<p><code>bool taxable1 = !(pi1-&gt;isTaxFree()); // доступ к ресурсу</code></p>
<p><code>// через оператор -&gt;</code></p>
<p><code>...</code></p>
<p><code>std::auto_ptr&lt;Investment&gt; pi2(createInvestment()); // имеем auto_ptr для</code></p>
<p><code>// управления ресурсом</code></p>
<p><code>bool taxable2 = !((*pi2).isTaxFree()); // доступ к ресурсу</code></p>
<p><code>// через оператор *</code></p>
<p><code>...</code></p>
<empty-line/><p>Поскольку иногда необходимо получать доступ к ресурсу, управляемому RAII-объектом, то некоторые реализации RAII предоставляют функции для неявного преобразования. Например, рассмотрим следующий класс для работы со шрифтами, инкапсулирующий «родной» интерфейс, написанный на C:</p>
<empty-line/><p><code>FontHandle getFont(); // из С API – параметры пропущены</code></p>
<p><code>// для простоты</code></p>
<p><code>void releaseFont(FontHandle fh); // из того же API</code></p>
<p><code>class Font { // класс RAII</code></p>
<p><code>public:</code></p>
<p><code>explicit Font(FontHandle fh) // захватить ресурс:</code></p>
<p><code>:f(fh) // применяется передача по значению,</code></p>
<p><code>{} // потому что того требует C API</code></p>
<p><code>~Font() {releaseFont(f);} // освободить ресурс</code></p>
<p><code>private:</code></p>
<p><code>FontHandle f; // управляемый ресурс – шрифт</code></p>
<p><code>};</code></p>
<empty-line/><p>Предполагается, что есть обширный программный интерфейс, написанный на C, работающий исключительно в терминах FontHandle. Поэтому часто приходится преобразовывать объекты из типа Font в FontHandle. Класс Font может предоставить функцию явного преобразования, например get:</p>
<empty-line/><p><code>class Font {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>FontHandle get() const {return f;} // функция явного преобразования</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>К сожалению, пользователю придется вызывать get всякий раз при взаимодействии с API:</p>
<empty-line/><p><code>void changeFontSize(FontHandle f, int newSize); // из C API</code></p>
<p><code>Font f(getFont());</code></p>
<p><code>int newFontSize;</code></p>
<p><code>...</code></p>
<p><code>changeFontSize(f.get(), newFontSize); // явное преобразование</code></p>
<p><code>// из Font в FontHandle</code></p>
<empty-line/><p>Некоторые программисты могут посчитать, что каждый раз выполнять явное преобразование настолько обременительно, что вообще откажутся от применения этого класса. В результате возрастет опасность утечки шрифтов, а именно для того, чтобы предотвратить это, и был разработан класс Font.</p>
<p>Альтернативой может стать предоставление классом Font функции неявного преобразования к FontHandle:</p>
<empty-line/><p><code>class Font {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>operator FontHandle() const // функция неявного преобразования</code></p>
<p><code>{return f;}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Это сделает вызовы C API простыми и естественными:</p>
<empty-line/><p><code>Font f(getFont());</code></p>
<p><code>int newSize;</code></p>
<p><code>...</code></p>
<p><code>changeFontSize(f, newFontSize); // неявное преобразование из Font</code></p>
<p><code>// в FontHandle</code></p>
<empty-line/><p>Увы, у этого решения есть и оборотная сторона: повышается вероятность ошибок. Например, пользователь может нечаянно создать объект FontHandle, имея в виду Font:</p>
<empty-line/><p><code>Font f1(getFont());</code></p>
<p><code>...</code></p>
<p><code>FontHandle f2 = f1; // Ошибка! Предполагалось скопировать объект Font,</code></p>
<p><code>// а вместо f1 неявно преобразован в управляемый</code></p>
<p><code>// им FontHandle, который и скопирован в f2</code></p>
<empty-line/><p>Теперь в программе есть FontHandle, управляемый объектом Font f1, однако он же доступен и напрямую, как f2. Это почти всегда нехорошо. Например, если f1 будет уничтожен, шрифт освобождается, и f2 становится «висячей ссылкой».</p>
<p>Решение о том, когда нужно предоставить явное преобразование RAII-объекта к управляемому им ресурсу (посредством функции get), а когда – неявное, зависит от конкретной задачи, для решения которой был спроектирован класс, и условий его применения. Похоже, что лучшее решение – следовать советам правила 18, а именно: делать интерфейсы простыми для правильного применения и трудными – для неправильного. Часто явное преобразование типа функции get – более предпочтительный вариант, поскольку минимизирует шанс получить нежелательное преобразование типов. Однако иногда естественность применения неявного преобразования поможет сделать ваш код чище.</p>
<p>Может показаться, что функции, обеспечивающие доступ к управляемым ресурсам, противоречат принципам инкапсуляции. Верно, но в данном случае это не беда. Дело в том, что RAII-классы существуют не для того, чтобы что-то инкапсулировать. Их назначение – гарантировать, что определенное действие (а именно освобождение ресурса) обязательно произойдет. При желании инкапсуляцию ресурса можно реализовать поверх основной функциональности, но это не является необходимым. Более того, некоторые RAII-классы комбинируют истинную инкапсуляцию реализации с отказом от нее в отношении управляемого ресурса. Например, tr1::shared_ptr инкапсулирует подсчет ссылок, но предоставляет простой доступ к управляемому им указателю. Как и большинство хорошо спроектированных классов, он скрывает то, что клиенту не нужно видеть, но обеспечивает доступ к тому, что клиенту необходимо.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Программные интерфейсы (API) часто требуют прямого обращения к ресурсам. Именно поэтому каждый RAII-класс должен предоставлять возможность получения доступа к ресурсу, которым он управляет.</p>
<p>• Доступ может быть обеспечен посредством явного либо неявного преобразования. Вообще говоря, явное преобразование безопаснее, но неявное более удобно для пользователей.</p>
</section><section><title><p>Правило 16: Используйте одинаковые формы new и delete</p>
</title><p>Что неправильно в следующем фрагменте?</p>
<empty-line/><p><code>std::string *stringArray = new std::string[100];</code></p>
<p><code>...</code></p>
<p><code>delete stringArray;</code></p>
<empty-line/><p>На первый взгляд, все в полном порядке – использованию new соответствует применение delete, но кое-что здесь совершенно неверно. Поведение программы непредсказуемо. По меньшей мере, 99 из 100 объектов string, на которые указывает stringArray, вероятно, не будут корректно уничтожены, потому что их деструкторы, скорее всего, так и не вызваны.</p>
<p>При использовании <emphasis>выражения new</emphasis> (когда объект создается динамически путем вызова оператора <emphasis>new)</emphasis> происходят два события. Во-первых, выделяется память (посредством функции operator new, см. правила 49 и 51). Во-вторых, для этой памяти вызывается один или несколько конструкторов. При вызове delete также происходят два события: вызывается один или несколько деструкторов, а затем память возвращается системе (посредством функции operator delete, см. правило 51). Важный вопрос, возникающий в связи с использованием delete, заключается в следующем: <emphasis>сколько</emphasis> объектов следует удалить из памяти? Ответ на него и определяет, сколько деструкторов нужно будет вызвать.</p>
<p>В действительности вопрос гораздо проще: является ли удаляемый указатель указателем на один объект или на массив объектов? Это критичный вопрос, поскольку схема распределения памяти для отдельных объектов существенно отличается от схемы выделения памяти для массивов. В частности, при выделении памяти для массива обычно запоминается его размер, чтобы оператор delete знал, сколько деструкторов вызывать. В памяти, выделенной для отдельного объекта, такая информация не хранится. Различные схемы распределения памяти изображены на рисунке ниже (n – размер массива):</p>
<image l:href="#i_001.png"/><p>Конечно, это только пример. От компилятора не требуется реализовывать схему именно таким образом, хотя многие так и делают.</p>
<p>Когда вы используете оператор delete для указателя, как он может узнать, что где-то имеется информация о размере массива? Только от вас. Если после delete стоят квадратные скобки, то предполагается, что указатель указывает на массив. В противном случае компилятор считает, что это указатель на отдельный объект:</p>
<empty-line/><p><code>std::string *stringPtr1 = new std::string;</code></p>
<p><code>std::string *stringPtr2 = new std::string[100];</code></p>
<p><code>...</code></p>
<p><code>delete stringPtr1;</code></p>
<p><code>delete[]stringPtr2;</code></p>
<empty-line/><p>Что произойдет, если использовать форму «[]» с stringPtr1? Результат не определен, но вряд ли он будет приятным. В предположении, что память организована, как в приведенной выше схеме, delete сначала прочитает размер массива, а затем будет вызывать деструкторы, не обращая внимания на тот факт, что память, с которой он работает, не только не является массивом, но даже не содержит объектов того типа, для которых должны быть вызваны деструкторы.</p>
<p>Что случится, если вы не используете форму «[]» для stringPtr2? Неизвестно, но можно предположить, что будет вызван только один деструктор, хотя нужно было вызвать несколько. Более того, это не определено даже для встроенных типов, подобных int, несмотря на то что у них нет деструкторов.</p>
<p>Правило простое: если вы используете [] в выражении new, то должны использовать [] и в соответствующем выражении delete. Если вы не используете [] в new, то не надо использовать его в соответствующем выражении delete.</p>
<p>Это правило особенно важно помнить при написании классов, содержащих указатели на динамически распределенную память, в которых есть несколько конструкторов, поскольку в этом случае вы должны использовать одинаковую форму new во всех конструкторах для инициализации членов-указателей. Если этого не сделать, то как узнать, какую форму delete применить в деструкторе?</p>
<p>Данное правило для тех, кто часто прибегает к использованию typedef, поскольку из него следует, что автор typedef должен документировать, какую форму delete применять для удаления объектов типа, описываемого typedef. Рассмотрим пример:</p>
<empty-line/><p><code>typedef std::string AddressLines[5]; // адрес человека состоит из 4 строк,</code></p>
<p><code>// каждая из которых имеет тип string</code></p>
<empty-line/><p>Поскольку AddressLines – массив, то следующему применению new</p>
<empty-line/><p><code>std::string *pal = new AddressLines; // отметим, что “new AddressLines”</code></p>
<p><code>// вернет string *, как и</code></p>
<p><code>// выражение “new string[4]”</code></p>
<empty-line/><p>должна соответствовать форма delete для массивов:</p>
<empty-line/><p><code>delete pal; // не определено!</code></p>
<p><code>delete[] pal; // правильно</code></p>
<empty-line/><p>Чтобы избежать путаницы, старайтесь не примененять typedef для определения типов массивов. Это просто, потому что стандартная библиотека C++ (см. правило 54) включает шаблонные классы string и vector, позволяющие практически полностью избавиться от динамических массивов. Так, в примере выше AddressLines можно было бы определить как вектор строк: vector&lt;string&gt;.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Если вы используете [] в выражении new, то должны применять [] и в соответствующем выражении delete. Если вы не используете квадратные скобки [] в выражении new, то не должны использовать их и в соответствующем выражении delete.</p>
</section><section><title><p>Правило 17: Помещение в «интеллектуальный» указатель объекта, вьщеленного с помощью new, лучше располагать в отдельном предложении</p>
</title><p>Предположим, что есть функция, возвращающая уровень приоритета обработки, и другая функция для выполнения некоторой обработки динамически выделенного объекта Widget в соответствии с этим приоритетом:</p>
<empty-line/><p><code>int priority();</code></p>
<p><code>void processWidgets(std::tr1::shared_ptr&lt;Widget&gt; pw, int priority);</code></p>
<empty-line/><p>Помня о премудростях применения объектов, управляющих ресурсами (см. правило 13), processWidgets использует «интеллектуальный» указатель (здесь – tr1::shared_ptr) для обработки динамически выделенного объекта. Рассмотрим теперь такой вызов processWidgets:</p>
<empty-line/><p><code>processWidgets(new Widget, priority());</code></p>
<empty-line/><p>Стоп, не надо его рассматривать! Он не скомпилируется. Конструктор tr1::shared_ptr, принимающий указатель, объявлен с ключевым словом explicit, поэтому не происходит неявного преобразования из типа указателя, возвращенного выражением «new Widget», в тип tr1::shared_ptr, которого ожидает функция process-Widgets. Однако следующий код компилируется:</p>
<empty-line/><p><code>processWidgets(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority());</code></p>
<empty-line/><p>Как это ни странно, но несмотря на использование управляющего ресурсами объекта, здесь возможна утечка ресурсов. Разберемся, почему.</p>
<p>Прежде чем компилятор сможет сгенерировать вызов processWidgets, он должен вычислить аргументы, переданные ему в качестве параметров. Второй аргумент – просто вызов функции priority, но первый – (std::tr1::shared_ptr&lt;Widget&gt; (new Widget)) – состоит из двух частей:</p>
<p>• выполнение выражения «new Widget»;</p>
<p>• вызов конструктора tr1::shared_ptr.</p>
<p>Перед тем как произойдет вызов processWidgets, компилятор должен сгенерировать код для решения следующих трех задач:</p>
<p>• вызов priority;</p>
<p>• выполнение «new Widget»;</p>
<p>• вызов конструктора tr1::shared_ptr.</p>
<p>Компиляторам C++ предоставлена определенная свобода в определении порядка выполнения этих операций. (И этим C++ отличается от таких языков, как Java и C#, где параметры функций всегда вычисляются в определенном порядке.) Выражение «new Widget» должно быть выполнено перед вызовом конструктора tr1::shared_ptr, потому что результат этого выражения передается конструктору в качестве аргумента, однако вызов priority может быть выполнен первым, вторым или третьим. Если компилятор решит поставить его на второе место (иногда это позволяет сгенерировать более эффективный код), то мы получим следующую последовательность операций:</p>
<p>1. Выполнение «new Widget».</p>
<p>2. Вызов priority.</p>
<p>3. Вызов конструктора tr1::shared_ptr.</p>
<p>Посмотрим, что случится, если вызов priority возбудит исключение. В этом случае указатель, возвращенный «new Widget», будет потерян, то есть не помещен в объект tr1::shared_ptr, который, как ожидается, должен предотвратить утечку ресурса. Утечка при вызове processWidgets происходит из-за того, что исключение возникает между моментом создания ресурса и моментом помещения его в управляющий объект.</p>
<p>Избежать подобной проблемы просто: используйте отдельные предложения для создания объекта Widget и помещения его в интеллектуальный указатель, а затем передайте этот интеллектуальный указатель processWidgets:</p>
<empty-line/><p><code>std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget); // поместить новый объект</code></p>
<p><code>// в интеллектуальный указатель</code></p>
<p><code>// в отдельном предложении</code></p>
<p><code>processWidget(pw, priority()); // этот вызов не приведет</code></p>
<p><code>// к утечке</code></p>
<empty-line/><p>Такой способ работает потому, что компиляторам предоставляется меньше свободы в переопределении порядка операций <emphasis>в разных</emphasis> предложениях, чем <emphasis>в одном.</emphasis> В модифицированном коде выражение «new Widget» и вызов конструктора tr1::shared_ptr отделены от вызова priority, поэтому компилятор не может вставить вызов priority между ними.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Помещайте объекты, выделенные оператором new, в «интеллектуальные» указатели в отдельном предложении. В противном случае такие вызовы могут привести к утечкам ресурсов, если возникнет исключение.</p>
</section></section><section><title><p>Глава 4</p>
<p>Проектирование программ и объявления</p>
</title><section><p>Проектирование программного обеспечения – это приемы получения программ, которые делают то, чего вы от них хотите. Обычно проект начинается с довольно общей идеи, но затем обрастает деталями настолько, чтобы можно было приступить к разработке конкретных интерфейсов. Интерфейсы должны затем превратиться в объявления на языке C++. В настоящей главе мы рассмотрим проблему проектирования и объявления хороших интерфейсов на C++. Начнем с одного из самых важных правил проектирования интерфейсов: использовать их правильно должно быть просто, а неправильно – трудно. Отталкиваясь от этой мысли, мы сформулируем ряд более конкретных правил, касающихся самых разных тем, а именно: корректность, эффективность, инкапсуляция, удобство сопровождения, расширяемость и следование принятым соглашениям.</p>
<p>Представленный в этой главе материал не охватывает всего, что нужно знать о проектировании хороших интерфейсов. Мы остановимся лишь на некоторых из наиболее важных соглашений, укажем на наиболее типичные ошибки и предложим решения проблем, часто возникающих перед проектировщиками классов, функций и шаблонов.</p>
</section><section><title><p>Правило 18: Проектируйте интерфейсы так, что их легко было использовать правильно и трудно – неправильно</p>
</title><p>C++ изобилует интерфейсами. Интерфейсы функций. Интерфейсы классов. Интерфейсы шаблонов. Каждый интерфейс – это средство, посредством которого пользователь взаимодействует с вашим кодом. Предположим, что вы имеете дело с разумными людьми, которые стремятся хорошо сделать свою работу. Они <emphasis>хотят</emphasis> применять ваши интерфейсы корректно. Если случится, что они применят какой-то из них неправильно, то часть вины за это ляжет на вас. В идеале, при попытке использовать интерфейс так, что пользователь не получит ожидаемого результата, код не должен компилироваться. А если компилируется, то должен делать то, что имел в виду пользователь.</p>
<p>При разработке интерфейсов, простых для правильного применения и трудных – для неправильного, вы должны предвидеть, какие ошибки может допустить пользователь. Например, предположим, что вы разрабатываете конструктор класса, представляющего дату:</p>
<empty-line/><p><code>class Date {</code></p>
<p><code>public:</code></p>
<p><code>Date(int month, int day, int year);</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>На первый взгляд, этот интерфейс может показаться разумным (во всяком случае, в США), но есть, по крайней мере, две ошибки, которые легко может допустить пользователь. Во-первых, он может передать параметры в неправильном порядке:</p>
<empty-line/><p><code>Date(30, 3, 1995); // должно быть “3, 30”, а не “30, 3”</code></p>
<empty-line/><p>Во-вторых, номер месяца или дня может быть указан неверно:</p>
<empty-line/><p><code>Date(2, 20, 1995); // Должно быть “3, 30”, а не “2, 20”</code></p>
<empty-line/><p>(Последний пример может показаться надуманным, но вспомните, что на клавиатуре «2» находится рядом с «3». Такие опечатки случаются сплошь и рядом.)</p>
<p>Многих ошибок можно избежать за счет введения новых типов. Система контроля типов – ваш первый союзник в деле предотвращения компилируемости нежелательного кода. В данном случае мы можем ввести простые типы-обертки, чтобы различать дни, месяцы и годы, затем использовать их в конструкторе Date:</p>
<empty-line/><p><code>struct Day { struct Month { struct Year {</code></p>
<p><code>explicit Day(int d) explicit Month(int m) explicit Year(int y)</code></p>
<p><code>: val(d) {} : val(m) {} : val(y) {}</code></p>
<p><code>int val; int val; int val;</code></p>
<p><code>}; }; };</code></p>
<p><code>class Date {</code></p>
<p><code>public:</code></p>
<p><code>Date(const Month&amp; m, const Day&amp; d, const Year&amp; y(;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>Date d(30, 3, 1995); // ошибка! неправильные типы</code></p>
<p><code>Date d(Day(30), Month(3), Year(1995); // ошибка! неправильные типы</code></p>
<p><code>Date d(Month(3), Day(30), Year(1995)); // порядок, типы корректны</code></p>
<empty-line/><p>Еще лучше сделать Day, Month и Year полноценными классами, инкапсулирующими свои данные (см. правило 22). Но даже применение простых структур наглядно демонстрирует, что разумное использование новых типов способно эффективно предотвратить ошибки при использовании интерфейсов.</p>
<p>После того как определены правильные типы, иногда имеет смысл ограничить множество принимаемых ими значений. Например, есть только 12 допустимых значений месяцев, что и должен отразить тип Month. Один из способов сделать это – применить перечисление (enum) для представления месяца. Но перечисления не так безопасны по отношению к типам, как хотелось бы. Например, перечисления могут быть использованы как значения типа int (см. правило 2). Более безопасное решение – определить набор допустимых месяцев:</p>
<empty-line/><p><code>class Month {</code></p>
<p><code>public:</code></p>
<p><code>static Month Jan() {return Month(1);} // функции возвращают все</code></p>
<p><code>static Month Feb() {return Month(2);} // допустимые значения Month.</code></p>
<p><code>... // Cм. ниже, почему это функции,</code></p>
<p><code>static Month Dec() {return Month(12);} // а не объекты</code></p>
<p><code>... // прочие функции-члены</code></p>
<p><code>private:</code></p>
<p><code>explicit Month(int m); // предотвращает создание новых</code></p>
<p><code>// значений Month</code></p>
<p><code>... // специфичные для месяца данные</code></p>
<p><code>};</code></p>
<p><code>Date d(Month::Mar(), Day(30), Year(1995));</code></p>
<empty-line/><p>Идея применения функций вместо объектов для представления месяцев может показаться вам необычной. Но вспомните о ненадежности инициализации нелокальных статических объектов. Правило 4 поможет освежить вашу память.</p>
<p>Другой способ предотвратить вероятные ошибки клиентов – ограничить множество разрешенных для типа операций. Общий способ установить ограничения – добавить const. Например, в правиле 3 объясняется, как добавление модификатора const к типу значения, возвращаемого функцией operator*, может предотвратить следующую ошибку клиента:</p>
<empty-line/><p><code>if(a *b = c)... // имелось в виду сравнение</code></p>
<empty-line/><p>Фактически это пример другого общего правила облегчения правильного использования типов и усложнения неправильного их использования: поведение ваших типов должно быть согласовано с поведением встроенных типов (кроме некоторых исключительных случаев). Клиенты уже знают, как должны себя вести типы вроде int, поэтому вы должны стараться, чтобы ваши типы по возможности вели себя аналогично. Например, присваивание выражению a*b недопустимо, если a и b – целые, поэтому если нет веской причины отклониться от этого поведения, оно должно быть недопустимо и для ваших типов. Когда сомневаетесь, делайте так, как ведет себя int.</p>
<p>Избегать неоправданных расхождений с поведением встроенных типов необходимо для того, чтобы обеспечить согласованность интерфейсов. Из всех характеристик простых для применения интерфейсов согласованность – наверное, самая важная. И наоборот, несогласованность – прямая дорога к ухудшению качества интерфейса. Интерфейсы STL-контейнеров в большинстве случаев согласованы (хотя и не идеально), и это немало способствует простоте их использования. Например, каждый STL-контейнер имеет функцию-член size, которая сообщает, сколько объектов содержится в контейнере. Напротив, в языке Java для массивов используется <emphasis>свойство</emphasis> length, для класса String – <emphasis>метод</emphasis> length, а для класса List – метод size. Также и в. NET: класс Array имеет свойство Length, а класс ArrayList – свойство Count. Некоторые разработчики считают, что интегрированные среды разработки (IDE) делают эти несоответствия несущественными, но они ошибаются. Несоответствия мешают программисту продуктивно работать, и ни одна IDE это не компенсирует.</p>
<p>Любой интерфейс, который требует, чтобы пользователь что-то помнил, может быть использован неправильно, ибо пользователь вполне способен забыть, что от него требуется. Например, в правиле 13 представлена фабричная функция, которая возвращает указатель на динамически распределенный объект в иерархии Investment:</p>
<empty-line/><p><code>Investment *createInvestment(); // из правила 13: параметры</code></p>
<p><code>// для простоты опущены</code></p>
<empty-line/><p>Чтобы избежать утечки ресурсов, указатель, возвращенный createInvestment, обязательно должен быть удален. Следовательно, пользователь может совершить, по крайней мере, две ошибки: забыть удалить указатель либо удалить его более одного раза.</p>
<p>Правило 13 показывает, как клиенты могут поместить значение, возвращенное createInvestment, в «интеллектуальный» указатель наподобие auto_ptr или tr1::shared_ptr, возложив тем самым на него ответственность за вызов delete. Но что, если клиент забудет применить «интеллектуальный» указатель? Во многих случаях для предотвращения этой проблемы лучше было бы написать фабричную функцию, которая сама возвращает «интеллектуальный» указатель:</p>
<empty-line/><p><code>std::tr1::shared_ptr&lt;Investment&gt; createInvestment();</code></p>
<empty-line/><p>Тогда пользователь будет вынужден сохранять возвращаемое значение в объекте типа tr1::shared_ptr, и ему не придется помнить о том, что объект Investment по завершении работы с ним необходимо удалить.</p>
<p>Фактически возврат значения типа tr1::shared_ptr позволяет проектировщику интерфейса предотвратить и многие другие ошибки, связанные с освобождением ресурса, потому что, как объяснено в правиле 14, tr1::shared_ptr допускает привязку функции-чистильщика к интеллектуальному указателю при его создании (auto_ptr не имеет такой возможности).</p>
<p>Предположим, что от пользователя, который получил указатель Investment* от createInvestment, ожидается, что в конце работы он передаст его функции getRidOfInvestment, вместо того чтобы применить к нему delete. Подобный интерфейс – прямая дорога к другой ошибке, заключающейся в использовании не того механизма удаления ресурсов (пользователь может все-таки вызвать delete вместо getRidOfInvestment). Реализация createInvestment может снять эту проблему за счет того, что вернет tr1::shared_ptr с привязанной к нему в качестве чистильщика функцией getRidOfInvestment.</p>
<p>Конструктор tr1::shared_ptr принимает два аргумента: указатель, которым нужно управлять, и функцию-чистильщик, которая должна быть вызвана, когда счетчик ссылок достигнет нуля. Это наводит на мысль попытаться следующим образом создать нулевой указатель tr1::shared_ptr с getRidOfInvestment в качестве чистильщика:</p>
<empty-line/><p><code>std::tr1_shared_ptr&lt;Investment&gt; // попытка создать нулевой shared_ptr</code></p>
<p><code>pInv(0, getRidOfInvestment); // с чистильщиком</code></p>
<p><code>// <emphasis>это не скомпилируется</emphasis></code></p>
<empty-line/><p>К сожалению, C++ это не приемлет. Конструктор tr1::shared_ptr требует, чтобы его первый параметр был указателем, а 0 – это не указатель, это целое. Да, оно <emphasis>преобразуется</emphasis> в указатель, но для данного случая этого недостаточно: tr1::shared_ptr настаивает на настоящем указателе. Приведение типа решает эту проблему:</p>
<empty-line/><p><code>std::tr1_shared_ptr&lt;Investment&gt; // создает null shared_ptr</code></p>
<p><code>pInv(static_cast&lt;Investment*&gt;(0), // с getRidOfInvestment в качестве</code></p>
<p><code>getRidOfInvestment); // чистильщика. о static_cast см.</code></p>
<p><code>// в правиле 27</code></p>
<empty-line/><p>Это значит, что код, реализующий createInvestment, который должен возвратить tr1::shared_ptr с getRidOfInvestment в качества чистильщика, будет выглядеть примерно так:</p>
<empty-line/><p><code>std::tr1::shared_ptr&lt;Investment&gt; createInvestment()</code></p>
<p><code>{</code></p>
<p><code>std::tr1::shared_ptr&lt;Investment&gt; retVal(static_cast&lt;Investment*&gt;(0),</code></p>
<p><code>getRidOfInvestment);</code></p>
<p><code>retVal = ...; // retVal должен указывать</code></p>
<p><code>// на корректный объект</code></p>
<p><code>return retVal;</code></p>
<p><code>}</code></p>
<empty-line/><p>Конечно, если указатель, которым должен управлять pInv, можно было бы определить до создания pInv, то лучше было бы передать его конструктору pInv вместо инициализации pInv нулем с последующим присваиванием значения (см. правило 26).</p>
<p>Особенно симпатичное свойство tr1::shared_ptr заключается в том, что он автоматически использует определенного пользователем чистильщика, чтобы избежать другой потенциальной ошибки пользователя – «проблемы нескольких DLL». Она возникает, если объект создается оператором new в одной динамически скомпонованной библиотеке (DLL), а удаляется оператором delete в другой. На многих платформах в такой ситуации возникает ошибка во время исполнения. tr1::shared_ptr решает эту проблемы, поскольку его чистильщик по умолчанию использует delete из той же самой DLL, где был создан tr1::shared_ptr. Это значит, например, что если класс Stock является производным от Investment и функция createInvestment реализована следующим образом:</p>
<empty-line/><p><code>std::tr1::shared_ptr&lt;Investment&gt; createInvestment()</code></p>
<p><code>{</code></p>
<p><code>return std::tr1::shared_ptr&lt;Investment&gt;(new Stock);</code></p>
<p><code>}</code></p>
<empty-line/><p>то возвращенный ей объект tr1::shared_ptr можно передавать между разными DLL без риска столкнуться с описанной выше проблемой. Объект tr1::shared_ptr, указывающий на Stock, «помнит», из какой DLL должен быть вызван delete, когда счетчик ссылок на Stock достигнет нуля.</p>
<p>Впрочем, этот правило не о tr1::shared_ptr, а о том, как делать интерфейсы легкими для правильного использования и трудными – для неправильного. Но класс tr1::shared_ptr дает настолько простой способ избежать некоторых клиентских ошибок, что на нем стоило остановиться. Наиболее распространенная реализация tr1::shared_ptr находится в библиотеке Boost (см. правило 55). Размер объекта shared_ptr из Boost вдвое больше размера обычного указателя, в нем динамически выделяется память для служебных целей и данных, относящихся к чистильщику, используется вызов виртуальной функции для обращения к чистильщику, производится синхронизация потоков при изменении значения счетчика ссылок в многопоточной среде. (Вы можете отключить поддержку многопоточности, определив символ препроцессора.) Короче говоря, этот интеллектуальный указатель по размеру больше обычного, работает медленнее и использует дополнительную динамически выделяемую память. Но во многих приложениях эти дополнительные затраты времени исполнения будут незаметны, зато уменьшение числа ошибок пользователей заметят все.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Хорошие интерфейсы легко использовать правильно и трудно использовать неправильно. Вы должны стремиться обеспечить эти характеристики в ваших интерфейсах.</p>
<p>• Для обеспечения корректного использования интерфейсы должны быть согласованы и совместимы со встроенными типами.</p>
<p>• Для предотвращения ошибок применяют следующие способы: создание новых типов, ограничение допустимых операций над этими типами, ограничение допустимых значений, а также освобождение пользователя от обязанностей по управлению ресурсами.</p>
<p>• Класс tr1::shared_ptr поддерживает пользовательские функции-чистильщики. Это снимает «проблему нескольких DLL» и может быть, в частности, использовано для автоматического освобождения мьютекса (см. правило 14).</p>
</section><section><title><p>Правило 19: Рассматривайте проектирование класса как проектирование типа</p>
</title><p>В C++, как и в других объектно-ориентированных языках программирования, при определении нового класса определяется новый тип. Потому большую часть времени вы как разработчик C++ будете тратить на совершенствование вашей системы типов. Это значит, что вы – не просто разработчик классов, но еще и разработчик типов. Перегруженные функции и операторы, управление распределением и освобождением памяти, определение инициализации и порядка уничтожения объектов – все это находится в ваших руках. Поэтому вы должны подходить к проектированию классов так, как разработчики языка подходят к проектированию встроенных типов.</p>
<p>Проектирование хороших классов – ответственная работа, и этим все сказано. Хорошие типы имеют естественный синтаксис, интуитивно воспринимаемую семантику и одну или более эффективных реализаций. В C++ плохо спланированное определение класса может сделать невозможным достижение любой из этих целей. Даже характеристики производительности функций-членов класса могут зависеть от того, как они объявлены.</p>
<p>Итак, как же проектировать эффективные классы? Прежде всего вы должны понимать, с чем имеете дело. Проектирование почти любого класса ставит перед разработчиком вопросы, ответы на которые часто ограничивают спектр возможных решений:</p>
<p>• <strong>Как должны создаваться и уничтожаться объекты нового типа?</strong> От ответа на этот вопрос зависит дизайн конструкторов и деструкторов, а равно функций распределения и освобождения памяти (оператор new, оператор new[], оператор delete и оператор delete[] – см. главу 8), если вы собираетесь их переопределить.</p>
<p>• <strong>Чем должна отличаться инициализация объекта от присваивания значений?</strong> Ответ на этот вопрос определяет разницу в поведении между конструкторами и операторами присваивания. Важно не путать инициализацию с присваиванием, потому что им соответствуют разные вызовы функций (см. правило 4).</p>
<p>• <strong>Что означает для объектов нового типа быть переданными по значению?</strong> Помните, что конструктор копирования определяет реализацию передачи по значению для данного типа.</p>
<p>• <strong>Каковы ограничения на допустимые значения вашего нового типа?</strong> Обычно только некоторые комбинации значений данных-членов класса являются правильными. Эти комбинации определяют инварианты, которые должен поддерживать класс. А инварианты уже диктуют, как следует контролировать ошибки в функциях-членах, в особенности в конструкторах, операторах присваивания и функциях установки значений («setter» functions). Могут быть также затронуты исключения, которые возбуждают ваши функции, и спецификации этих исключений.</p>
<p>• <strong>Укладывается ли ваш новый тип в граф наследования?</strong> Наследуя свои классы от других, вы должны следовать ограничениям, налагаемым базовыми классами. В частности, нужно учитывать, как объявлены в них функции-члены: виртуальными или нет (см. правила 34 и 36). Если вы хотите, чтобы вашему классу могли наследовать другие, то нужно тщательно продумать, какие функции объявить виртуальными; в особенности это относится к деструктору (см. правило 7).</p>
<p>• <strong>Какие варианты преобразования типов допустимы для вашего нового типа?</strong> Ваш тип существует в море других типов, поэтому должны ли быть предусмотрены варианты преобразования между вашим типом и другими? Если вы хотите разрешить <emphasis>неявное</emphasis> преобразование объекта типа T1 в объект типа T2, придется либо написать функцию преобразования в классе T1 (то есть operator T2), либо неявный конструктор в классе T2, который может быть вызван с единственным аргументом. Если же вы хотите разрешить только <emphasis>явные</emphasis> преобразования, то нужно будет написать специальные функции, но ни в коем случае не делать их операторами преобразования или не-explicit конструкторами с одним аргументом. (Примеры явных и неявных функций преобразования приведены в правиле 15.)</p>
<p>• <strong>Какие операторы и функции имеют смысл для нового типа?</strong> Ответ на этот вопрос определяет набор функций, которые вы объявляете в вашем классе. Некоторые из них будут функциями-членами, другие – нет (см. правила 23, 24 и 46).</p>
<p><strong>• Какие стандартные функции должны стать недоступными?</strong> Их надо будет объявить закрытыми (см. правило 6).</p>
<p>• <strong>Кто должен получить доступ к членам вашего нового типа?</strong> Ответ на этот вопрос помогает определить, какие члены должны быть открытыми (public), какие – защищенными (protected) и какие – закрытыми (private). Также вам предстоит решить, какие классы и/или функции должны быть друзьями класса, а также когда имеет смысл вложить один класс внутрь другого.</p>
<p>• <strong>Что такое «необъявленный интерфейс» вашего нового типа?</strong> Какого рода гарантии могут быть предоставлены относительно производительности, безопасности относительно исключений (см. правило 29) и использования ресурсов (например, блокировок и динамической памяти)? Такого рода гарантии определяют ограничения на реализацию вашего класса.</p>
<p>• <strong>Насколько общий ваш новый тип?</strong> Возможно, в действительности вы не определяете новый тип. Возможно, вы определяете целое <emphasis>семейство</emphasis> типов. Если так, то вам нужно определять не новый класс, а новый шаблон класса.</p>
<p>• <strong>Действительно ли новый тип представляет собой то, что вам нужно?</strong> Если вы определяете новый производный класс только для того, чтобы расширить функциональность существующего класса, то, возможно, этой цели лучше достичь простым определением одной или более функций-нечленов либо шаблонов.</p>
<p>На эти вопросы нелегко ответить, поэтому определение эффективных классов – непростая задача. Но при ее должном выполнении определенные пользователями классы C++ дают типы, которые ничем не уступают встроенным и уже оправдывают все ваши усилия.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Проектирование класса – это проектирование типа. Прежде чем определять новый тип, убедитесь, что рассмотрены все вопросы, которые обсуждаются в настоящем правиле.</p>
</section><section><title><p>Правило 20: Предпочитайте передачу по ссылке на const передаче по значению</p>
</title><p>По умолчанию в C++ объекты передаются в функции и возвращаются функциями по значению (свойство, унаследованное от C). Если не указано противное, параметры функции инициализируются копиями реальных аргументов, а после вызова функции программа получает <emphasis>копию</emphasis> возвращаемой функцией величины. Копии вырабатываются конструкторами копирования. Поэтому передача по значению может оказаться накладной операцией. Например, рассмотрим следующую иерархию классов:</p>
<empty-line/><p><code>class Person {</code></p>
<p><code>public:</code></p>
<p><code>Person(); // параметры опущены для простоты</code></p>
<p><code>virtual ~Person(); // см. в правиле 7 – почему виртуальный</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>std::string name;</code></p>
<p><code>std::string address;</code></p>
<p><code>};</code></p>
<p><code>class Student: public Person {</code></p>
<p><code>public:</code></p>
<p><code>Student(); // и здесь параметры опущены</code></p>
<p><code>~ Student();</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>std::string schoolName;</code></p>
<p><code>std::string schoolAddress;</code></p>
<p><code>};</code></p>
<empty-line/><p>Теперь взгляните на следующий код, где вызывается функция validateStudent, которая принимает аргумент Student (по значению) и возвращает признак его корректности:</p>
<empty-line/><p><code>bool validateStudent(Student s); // функция принимает параметр</code></p>
<p><code>// Student по значению</code></p>
<p><code>Student plato; // Платон учился у Сократа</code></p>
<p><code>bool platoIsOk = validateStudent(plato); // вызов функции</code></p>
<empty-line/><p>Что происходит при вызове этой функции?</p>
<p>Ясно, что вызывается конструктор копирования Student для инициализации параметра plato. Также ясно, что s уничтожается при возврате из validate-Student. Поэтому передача параметра по значению этой функции обходится в один вызов конструктора копирования Student и один вызов деструктора Student.</p>
<p>Но это еще не все. Объект Student содержит внутри себя два объекта string, поэтому каждый раз, когда вы конструируете объект Student, вы должны также конструировать и эти два объекта. Класс Student наследует класу Person, поэтому каждый раз, конструируя объект Student, вы должны сконструировать и объект Person. Но объект Person содержит еще два объекта string, поэтому каждое конструирование Person влечет за собой два вызова конструктора string. Итак, передача объекта Student по значению приводит к одному вызову конструктора копирования Student, одному вызову конструктора копирования Person и четырем вызовам конструкторов копирования string. Когда копия объекта Student разрушается, каждому вызову конструктора соответствует вызов деструктора, поэтому общая стоимость передачи Student по значению составляет шесть конструкторов и шесть деструкторов!</p>
<p>Что ж, это корректное и желательное поведение. В конец концов, вы <emphasis>хотите,</emphasis> чтобы все ваши объекты были надежно инициализированы и уничтожены. И все же было бы неплохо найти способ пропустить все эти вызовы конструкторов и деструкторов. Способ есть! Это – передача по ссылке на константу:</p>
<empty-line/><p><code>bool validateStudent(const Student&amp; s);</code></p>
<empty-line/><p>Этот способ гораздо эффективнее: не вызываются никакие конструкторы и деструкторы, поскольку не создаются никакие новые объекты. Квалификатор const в измененном объявлении параметра важен. Исходная версия validateStudent принимала параметр Student по значению, вызвавший ее знает о том, что он защищен от любых изменений, которые функция может внести в переданный ей объект; validateStudent сможет модифицировать только его копию. Теперь же, когда Student передается по ссылке, необходимо объявить его const, поскольку в противном случае вызывающая программа должна побеспокоиться о том, чтобы validateStudent не вносила изменений в переданный ей объект.</p>
<p>Передача параметров по ссылке также позволяет избежать проблемы « <emphasis>срезки</emphasis> » (slicing). Когда объект производного класса передается (по значению) как объект базового класса, вызывается конструктор копирования базового класса, а те части, которые принадлежат производному, «срезаются». У вас остается только простой объект базового класса – что вполне естественно, так как его создал конструктор базового класса. Это почти всегда не то, что вам нужно. Например, предположим, что вы работаете с набором классов для реализации графической оконной системы:</p>
<empty-line/><p><code>class Window {</code></p>
<p><code>public</code></p>
<p><code>...</code></p>
<p><code>std::string name() const; // возвращает имя окна</code></p>
<p><code>virtual void display() const; // рисует окно и его содержимое</code></p>
<p><code>};</code></p>
<p><code>class WindwoWithScrollBars: public Window {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>virtual void display() const;</code></p>
<p><code>};</code></p>
<empty-line/><p>Все объекты класса Window имеют имя, которое вы можете получить посредством функции name, и все окна могут быть отображены, на что указывает наличие функции display. Тот факт, что display – функция виртуальная, говорит о том, что способ отображения простых объектов базового класса Window может отличаться от способа отображения объектов WindowWithScrollBar (см. правила 34 и 36).</p>
<p>Теперь предположим, что вы хотите написать функцию, которая будет печатать имя окна и затем отображать его. Вот <emphasis>неверный</emphasis> способ написания такой функции:</p>
<empty-line/><p><code>void printNameAndDisplay(Window w) // неправильно! Параметр</code></p>
<p><code>{ // может быть «срезан»</code></p>
<p><code>std::cout &lt;&lt; w.name();</code></p>
<p><code>w.display();</code></p>
<p><code>}</code></p>
<empty-line/><p>Посмотрим, что случится, если вызвать эту функцию, передав ей объект WindowWithScrollBar:</p>
<empty-line/><p><code>WindowWithScrollBar wwsb;</code></p>
<p><code>PrintNameAndDisplay(wwsb);</code></p>
<empty-line/><p>Параметр w будет сконструирован – он передан по значению, помните? – как объект Window, и вся дополнительная информация, которая делает его объектом WindowWithScrollBar, будет срезана. Внутри printNameAndDisplay w всегда будет вести себя как объект класса Window (потому что это и есть объект класса Window), независимо от типа объекта, в действительности переданного функции. В частности, вызов функции display внутри printNameAndDisplay всегда вызовет Window::display и никогда – WindowWithScrollBar::display.</p>
<p>Способ решения проблемы «срезки» – передать w по ссылке на константу:</p>
<empty-line/><p><code>void printNameAndDisplay(const Window&amp; w) // правильно, параметр</code></p>
<p><code>{ // не может быть «срезан»</code></p>
<p><code>std::cout &lt;&lt; w.name();</code></p>
<p><code>w.display();</code></p>
<p><code>}</code></p>
<empty-line/><p>Теперь w ведет себя правильно, какое бы окно он ни представлял в действительности.</p>
<p>Если вы заглянете «под капот» C++, то увидите, что ссылки обычно реализуются как указатели, поэтому передача чего-либо по ссылке обычно означает передачу указателя. В результате объекты встроенного типа (например, int) всегда более эффективно передавать по значению, чем по ссылке. Поэтому для встроенных типов, если у вас есть выбор – передавать по значению или по ссылке на константу, имеет смысл выбрать передачу по значению. Тот же совет касается итераторов и функциональных объектов STL, потому что они специально спроектированы для передачи по значению. Программисты, реализующие итераторы и функциональные объекты, отвечают за то, чтобы обеспечить эффективность передачи их по значению и исключить «срезку». Это пример того, как меняются правила в зависимости от используемой вами части C++ (см. правило 1).</p>
<p>Встроенные типы являются небольшими объектами, поэтому некоторые делают вывод, что все встроенные типы – хорошие кандидаты на передачу по значению, даже если они определены пользователем. Сомнительно. То, что объект небольшой, еще не значит, что вызов его конструктора копирования обойдется дешево. Многие объекты – среди них большинство контейнеров STL – содержат в себе немногим больше обычного указателя, но копирование таких объектов влечет за собой копирование всего, на что они указывают. Это может оказаться <emphasis>очень</emphasis> дорого.</p>
<p>Даже когда маленькие объекты имеют ненакладные конструкторы копирования, все равно они могут оказывать влияние на производительность. Некоторые компиляторы рассматривают встроенные и пользовательские типы по-разному, даже если они имеют одинаковое внутреннее представление. Например, некоторые компиляторы не размещают объекты, состоящие из одного лишь double в регистрах, даже если готовы размещать там значения встроенного типа double. В таких случаях лучше передавать объекты по ссылке, потому что компилятор безусловно готов поместить в регистр указатель (реализующий ссылку).</p>
<p>Другая причина того, почему маленькие пользовательские типы не обязательно хороши для передачи по значению, заключается в том, что их размер подвержен изменениям. Тип, который мал сегодня, может вырасти в будущем, потому что его внутренняя реализация может измениться. Ситуация меняется даже в том случае, если вы переключаетесь на другую реализацию C++. Например, в одних реализациях тип string из стандартной библиотеки <emphasis>в семь раз больше,</emphasis> чем в других.</p>
<p>Вообще говоря, единственные типы, для которых можно предположить, что передача по значению будет недорогой, – это встроенные типы, а также итераторы и функциональные объекты STL. Для всего остального следуйте совету этого правила и передавайте параметры по ссылке на константу вместо передачи по значению.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Передаче по значению предпочитайте передачу по ссылке на константу. Обычно это более эффективно и позволяет избежать проблемы «срезки».</p>
<p>• Это правило не касается встроенных типов, итераторов и функциональных объектов STL. Для них передача по значению обычно подходит больше.</p>
</section><section><title><p>Правило 21: Не пытайтесь вернуть ссылку, когда должны вернуть объект</p>
</title><p>Как только программисты осознают проблемы эффективности, связанные с передачей объектов по значению (см. правило 20), они, подобно крестоносцам, преисполняются решимости искоренить зло – передачу по значению – везде, где бы оно ни пряталось. Непреклонные в своем «святом» порыве, они с неизбежностью допускают фатальную ошибку: начинают передавать по ссылке значения несуществующих объектов. А это неправильно.</p>
<p>Рассмотрим класс для представления рациональных чисел, включающий в себя дружественную функцию для перемножения двух таких чисел:</p>
<empty-line/><p><code>class Rational {</code></p>
<p><code>public:</code></p>
<p><code>Rational(int numerator = 0, // см. в правиле 24 – почему этот</code></p>
<p><code>int denominator = 1); // конструктор не explicit</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>int n, d;</code></p>
<p><code>friend</code></p>
<p><code>const Rational // см. в правиле 3 -</code></p>
<p><code>operator*(const Rational&amp; lhs, // почему возвращаемый тип const</code></p>
<p><code>const Rational&amp; rhs);</code></p>
<p><code>};</code></p>
<empty-line/><p>Ясно, что эта версия operator* возвращает результирующий объект по значению, и вы обнаружили бы непрофессиональный подход, если бы не уделили внимания вопросу о затратах на создание и удаление объекта. Вы не хотите платить за то, за что платить не должны. Отсюда вопрос: должны ли вы платить?</p>
<p>Нет, если можете вернуть ссылку. Но ссылка – это просто другое <emphasis>имя</emphasis> некоторого <emphasis>существующего</emphasis> объекта. Всякий раз, сталкиваясь с объявлением ссылки, вы должны спросить себя: для чего предназначено это имя, ведь оно должно принадлежать <emphasis>чему-то.</emphasis> В случае operator*, если функция возвращает ссылку, значит, она должна вернуть ссылку на некоторый уже существующий объект Rational, который и содержит произведение двух объектов, которые следовало перемножить.</p>
<p>Очевидно, нет никаких оснований полагать, что такой объект существует до вызова operator*. Например, если у вас есть</p>
<empty-line/><p><code>Rational a(1, 2); // a = 1/2</code></p>
<p><code>Rational a(3, 5); // b = 3/5</code></p>
<p><code>Rational c = a*b; // c должно равняться 3/10</code></p>
<empty-line/><p>то неразумно ожидать, что уже существует то рациональное число со значением три десятых. Если operator* будет возвращать такое число, то он должен создать его самостоятельно.</p>
<p>Функция может создать новый объект только двумя способами: в стеке или в куче. Создание в стеке осуществляется посредством определения локальной переменной. Используя эту стратегию, вы можете попытаться написать operator* так:</p>
<empty-line/><p><code>const Rational&amp; operator*(const Rational&amp; lhs, // предупреждение!</code></p>
<p><code>const Rational&amp; rhs) // плохой код!</code></p>
<p><code>{</code></p>
<p><code>Rational result(lhs.n * rhs.h, lhs.d * rhs.d);</code></p>
<p><code>return result;</code></p>
<p><code>}</code></p>
<empty-line/><p>Этот подход можно отвергнуть сразу, потому что вашей целью было избежать вызова конструктора, а result должен быть создан, подобно любому другому объекту. Кроме того, эта функция порождает и более серьезную проблему, поскольку возвращает ссылку на result, но result – это локальный объект, а локальные объекты разрушаются при завершении функции, в которой они объявлены. Таким образом, эта версия operator* возвращает ссылку не на Rational, а на бывший Rational – пустой, отвратительный, гнилой скелет того, что когда-то было объектом Rational, но уже не является таковым, потому что он уничтожен. Стоит вызвать эту функцию – вы попадете в область неопределенного поведения. Запомним: любая функция, которая возвращает ссылку на локальный объект, некорректна (то же касается и функций, возвращающих указатель на локальный объект).</p>
<p>А теперь давайте рассмотрим возможность конструирования объекта в «куче» с возвратом ссылки на него. Объекты в «куче» создаются посредством new. Вот как мог бы выглядеть operator* в этом случае:</p>
<empty-line/><p><code>const Rational&amp; operator*(const Rational&amp; lhs, // предупреждение!</code></p>
<p><code>const Rational&amp; rhs) // Опять плохой код!</code></p>
<p><code>{</code></p>
<p><code>Rational *result = new Rational(lhs.n * rhs.h, lhs.d * rhs.d);</code></p>
<p><code>return *result;</code></p>
<p><code>}</code></p>
<empty-line/><p>Да, вам все же придется расплачиваться за вызов конструктора, поскольку память, выделяемая new, инициализируется вызовом соответствующего конструктора, но теперь возникает новая проблема: кто выполнит delete для объекта, созданного вами с использованием new?</p>
<p>Даже если вызывающая программа написана аккуратно и добросовестно, не вполне понятно, как она предотвратит утечку в следующем вполне естественном сценарии:</p>
<empty-line/><p><code>Rational w, x, y, z;</code></p>
<p><code>w = x * y * z; // то же, что operator*(operator*(x, y), z)</code></p>
<empty-line/><p>Здесь выполняется два вызова operator* в одном предложении, поэтому получаются два вызова new, которым должны соответствовать два delete. Но у пользователя operator* нет возможности это сделать, так как он не может получить указатели, скрытые за ссылками, которые возвращает функция operator*. Это гарантированная утечка ресурсов.</p>
<p>Но, возможно, вы заметили, что оба подхода (на основе стека и на основе кучи) страдают от необходимости вызова конструкторов для каждого возвращаемого значения operator*. Вспомните, что исходно мы ставили себе целью вообще не вызывать конструкторы. Быть может, вы думаете, что знаете, как избежать всего, всех вызовов конструктора, кроме одного. Не исключено, что вы придумали следующую реализацию функции operator*, которая возвращает ссылку на <emphasis>статический</emphasis> объект Rational, определенный <emphasis>внутри</emphasis> функции:</p>
<empty-line/><p><code>const Rational&amp; operator*(const Rational&amp; lhs, // предупреждение!</code></p>
<p><code>const Rational&amp; rhs) // Код еще хуже!</code></p>
<p><code>{</code></p>
<p><code>static Rational result; // статический объект,</code></p>
<p><code>// на который возвращается ссылка</code></p>
<p><code>result = ...; // умножить lhs на rhs и поместить</code></p>
<p><code>// произведение в result</code></p>
<p><code>return result;</code></p>
<p><code>}</code></p>
<empty-line/><p>Подобно всем проектным решениям на основе статических объектов, это сразу вызывает вопросы, связанные с безопасностью относительно потоков, но есть и более очевидный недостаток. Чтобы разглядеть его, рассмотрим следующий абсолютно разумный код:</p>
<empty-line/><p><code>bool operator==(const Rational&amp; lhs, // оператор == для Rational</code></p>
<p><code>const Rational&amp; rhs);</code></p>
<p><code>Rational a, b, c, d;</code></p>
<p><code>...</code></p>
<p><code>if ((a*b) == (c*d)) {</code></p>
<p><code><emphasis>действия, необходимые в случае, если два произведения равны;</emphasis></code></p>
<p><code>} else {</code></p>
<p><code><emphasis>действия, необходимые в противном случае;</emphasis></code></p>
<p><code>}</code></p>
<empty-line/><p>Догадываетесь, что не так? Выражение ((a*b) == (c*d)) будет <emphasis>всегда</emphasis> равно true независимо от значений a, b, c и d!</p>
<p>Легче всего найти объяснение такому неприятному поведению, переписать проверку на равенство в эквивалентной функциональной форме:</p>
<empty-line/><p><code>if(operator==(operator*(a, b), operator*(c, d)))</code></p>
<empty-line/><p>Заметьте, что когда вызывается operator==, уже присутствуют два активных вызова operator*, каждый из которых будет возвращать ссылку на статический объект Rational внутри operator*. Таким образом, operator== будет сравнивать статический объект Rational, определенный в функции operator*, со значением статического объект Rational внутри той же функции. Было бы удивительно, если бы они не оказались равны всегда.</p>
<p>Этого должно быть достаточно, чтобы убедить вас, что возвращение ссылки из функции, подобной operator*, – пустая трата времени, но я не настолько наивен, чтобы полагаться на везение. Кое-кто в настоящий момент думает: «Хорошо, если недостаточно одного статического объекта, то, может быть, для этого подойдет статический массив…»</p>
<p>Я не снизойду до того, чтобы посвятить такой программе отдельный пример, но вкратце могу пояснить, почему даже возникновение такой идеи должно повергать вас в стыд. Во-первых, вы должны выбрать n – размер массива. Если n слишком мало, у вас может закончиться место для хранения, и вы ничего не выиграете по сравнению с вышеописанной программой. Если же n чересчур велико, вы уменьшаете производительность вашей программы, поскольку каждый объект в массиве конструируется при первом вызове функции. Это будет стоить вам n вызовов конструкторов и n вызовов деструкторов, даже если данная функция вызывается всего один раз. Если процесс повышения производительности программного обеспечения называется оптимизацией, тогда самое верное название происходящему – «пессимизация». И наконец, подумайте о том, как заносить необходимые вам значения в массив объектов и во что это обойдется. Наиболее прямой способ передачи объектов – операция присваивания, но с чем она связана? В общем случае это вызов деструктора (для уничтожения старого значения) плюс вызов конструктора (для копирования нового значения). А ваша цель – избежать вызовов конструктора и деструктора! Так что затея весьма неудачна (нет-нет: применение векторов вместо массивов не улучшит ситуацию).</p>
<p>Правильный способ написания функции заключается в том, что она должна возвращать новый объект. В применении к operator* для класса Rational это означает либо следующий код, либо нечто похожее:</p>
<empty-line/><p><code>inline const Rational operator*(const Rational&amp; lhs, Rational&amp; rhs)</code></p>
<p><code>{</code></p>
<p><code>return Rational(lhs.n*rhs.h, lhs.d*rhs.d);</code></p>
<p><code>}</code></p>
<empty-line/><p>Конечно, в этом случае вам придется смириться с издержками на вызов конструктора и деструктора для объектов, возвращаемых operator*, но в глобальном масштабе это небольшая цена за корректное поведение. Притом, вероятно, все не так уж страшно. Подобно всем языкам программирования, C++ позволяет разработчикам компиляторов применить оптимизацию для повышения производительности генерируемого кода, и, как оказывается, в некоторых случаях вызовы конструктора и деструктора возвращаемого operator* значения можно безопасно устранить. Когда компилятор пользуется этой возможностью (а часто он так и поступает), ваша программа продолжает делать то, чего вы от нее хотите, и даже быстрее, чем ожидалось.</p>
<p>Подведем итог: когда вы выбираете между возвратом ссылки и возвращением объекта, ваша задача заключается в том, чтобы все работало правильно. О том, как сделать этот выбор менее накладным, должен заботиться разработчик компилятора.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Никогда не возвращайте указатель или ссылку на локальный объект, ссылку на объект, распределенный в «куче», либо указатель или ссылку на локальный статический объект, если есть шанс, что понадобится более, чем один экземпляр такого объекта. В правиле 4 приведен пример ситуации, когда возврат ссылки на локальный статический объект имеет смысл, по крайней мере, в однопоточных средах.</p>
</section><section><title><p>Правило 22: Объявляйте данные-члены закрытыми</p>
</title><p>В этом правиле мы поговорим о том, почему данные-члены не должны быть открытыми (public). Затем мы убедимся, что все аргументы против открытых данных-членов касаются также защищенных (protected). Это приведет нас к выводу, что данные-члены должны быть закрытыми (private), и на этом мы поставим точку.</p>
<p>Итак, открытые данные-члены. Почему нет?</p>
<p>Начнем с синтаксической непротиворечивости (см. также правило 18). Если данные-члены не будут открытыми, то единственный способ для пользователей добраться до объекта – через функции-члены. Если весь открытый интерфейс будет состоять из функций, то пользователям не нужно будет ломать голову, пытаясь вспомнить, где нужно применять скобки, а где – нет, когда он захотят обратиться к члену класса. Они будут ставить скобки, поскольку ничего, кроме функций, не существует. Долой лишнюю головную боль.</p>
<p>Но, может быть, вы не считаете аргумент о непротиворечивости убедительным. Как насчет того факта, что применение функций обеспечивает более тонкую настройку доступа к данным-членам? Если вы сделаете данные-члены открытыми, каждый будет иметь к ним доступ для чтения и записи, но если вы используете функции для получения и установки значения, то сможете запретить доступ вовсе, разрешить только чтение или чтение-запись. Вы даже сможете реализовать доступ только для записи, если захотите:</p>
<empty-line/><p><code>class AccessLevels {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>int getReadOnly() const { return readOnly;}</code></p>
<p><code>void setReadWrite(int value) { readWrite = value;}</code></p>
<p><code>int getReadWrite() { return readWrite;}</code></p>
<p><code>void setWriteOnly(int value) { writeOnly = value;}</code></p>
<p><code>private:</code></p>
<p><code>int noAccess; // нет доступа к этому int</code></p>
<p><code>int readOnly; // доступ к этому int только для чтения</code></p>
<p><code>int readWrite; // доступ к этому int для чтения и записи</code></p>
<p><code>int writeOnly; // доступ к этому int только для записи</code></p>
<p><code>};</code></p>
<empty-line/><p>Такой точный контроль доступа важен, потому что многие данные-члены <emphasis>должны</emphasis> быть скрыты. Редко бывает так, чтобы член нуждался и в функции получения, и в функции установки значения.</p>
<p>Все еще не убедил? Тогда самое время доставать тяжелую артиллерию: инкапсуляция! Если вы реализуете доступ к данным через функции, то позже сможете не хранить, а вычислять данные-члены, и никто из пользователей вашего класса этого не заметит.</p>
<p>Например, предположим, что вы пишете приложение, в котором автоматическое устройство отслеживает скорость проходящих автомобилей. Когда автомобиль проезжает мимо, его скорость вычисляется и заносится в коллекцию данных о скоростях:</p>
<empty-line/><p><code>class SpeedDataCollection {</code></p>
<p><code>...</code></p>
<p><code>public:</code></p>
<p><code>void addValue(int speed); // добавить новое значение</code></p>
<p><code>double averageSoFar() const; // вернуть среднюю скорость</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Теперь рассмотрим реализацию функции-члена averageSoFar. Можно, например, завести в классе член, который представляет среднее арифметическое значений скоростей, накопленных на данный момент. Тогда функция averageSoFar будет просто возвращать значение этого члена класса. Другой подход заключается в том, чтобы вычислять среднее значение скорости в функции averageSoFar при каждом вызове, для чего ей придется просмотреть все данные в коллекции.</p>
<p>Первый подход (хранение текущей средней скорости) увеличивает размер каждого объекта SpeedDataCollection, потому что необходимо выделить место для члена данных, хранящего текущее среднее, накопленный итог и количество элементов данных. При этом averageSoFar может быть реализована очень эффективно: это будет просто встроенная функция (см. правило 30), которая возвращает значение текущего среднего. В противоположность этому вычисление по запросу сделает данную функцию медленнее, но каждый объект SpeedDataCollection станет меньше.</p>
<p>Кто скажет – как лучше? На машинах с маленькой памятью (например, встроенных устройствах, установленных на дороге), и в приложениях, где среднее значение требуется нечасто, его вычисление при каждом вызове, возможно, представляет лучшее решение. Но в приложениях, где среднее значение будет запрашиваться часто, скорость реакции существенна, а память – не проблема, хранение текущего среднего обычно предпочтительнее. Важно отметить, что, имея доступ к среднему через функцию-член (то есть инкапсулировав его), вы можете легко заменять реализацию, при этом программу-клиент придется всего лишь перекомпилировать. Можно избежать даже этого неудобства, если следовать технике, описанной в правиле 31.</p>
<p>Сокрытие данных-членов за интерфейсом функций может обеспечить гибкость реализации в разных отношениях. Например, это облегчает извещение других объектов о том, что к члену данных происходит обращение для чтения или записи, обеспечивает возможность проверять инварианты и выполнение пред– и постусловий, позволяет реализовать синхронизацию в многопоточной среде и т. д. Программисты, которые пришли в C++ из таких языков, как Delphi и C#, увидят в этой возможности аналогию со «свойствами» («properties»), существующими в этих языках, правда, к имени «свойства» приходится добавлять скобки.</p>
<p>Замечание об инкапсуляции важнее, чем может показаться с первого взгляда. Если вы скрываете данные-члены от пользователей (то есть инкапсулируете их), то можете обеспечить неизменность инвариантов класса, поскольку повлиять на них могут только функции-члены. Более того, вы сохраняете за собой право позже изменить реализацию. Если же вы не скрываете своих решений, то очень скоро обнаружите, что даже если у вас есть исходный код класса, ваша способность изменить его открытые члены чрезвычайно ограничена, потому что при этом перестанет работать слишком много клиентских программ. Открытость означает отсутствие инкапсуляции, и на практике «неинкапсулированный» означает «неизменяемый», особенно если речь идет о классах, которые нашли широкое применение. Но как раз широко используемые классы наиболее нуждаются в инкапсуляции, поскольку они более других могут выиграть от замены старой реализации на более совершенную.</p>
<p>Аргументы против защищенных (protected) данных-членов аналогичны. Фактически тут нет вообще никаких отличий, хотя поначалу может показаться, что это не так. Рассуждения о синтаксической непротиворечивости и тонко настраиваемом доступе в той же мере касаются защищенных членов, что и открытых, но как насчет инкапсуляции? Являются ли защищенные данные более инкапсулированными, чем открытые? Как это ни странно, но на практике – нет.</p>
<p>В правиле 23 объясняется, что инкапсуляция некоей сущности обратно пропорциональна объему кода, который может перестать работать, если эта сущность изменяется. Таким образом, степень инкапсуляции членов данных обратно пропорциональна объему кода, который перестанет работать, если этот член изменится, например будет изъят из класса (возможно, став вычисляемым, как в примере averageSoFar выше).</p>
<p>Предположим, у нас есть открытый член данных, и мы исключаем его из класса. Как много кода это затронет? Весь клиентский код, который использует его, объем которого, как правило, <emphasis>неизвестен.</emphasis> Открытые данные-члены, таким образом, абсолютно не инкапсулированы. Но предположим, что исключается защищенный член данных. Сколько кода будет затронуто теперь? Все производные классы, количество которых опять же <emphasis>неизвестно.</emphasis> Таким образом, защищенные члены-данные не инкапсулированы в той же степени, что и открытые, поскольку в обоих случаях изменения затрагивают клиентский код неизвестного объема. Это не очевидно, но, как вам скажут опытные разработчики библиотек, это все-таки правда. Как только вы объявили член данных открытым или защищенным и пользователи начали обращаться к нему, изменить что-либо становится очень трудно. Слишком много кода нужно переписывать, повторно тестировать, документировать или перекомпилировать. С точки зрения инкапсуляции, должно быть только два уровня доступа: закрытый (обеспечивающий инкапсуляцию) и все остальные (не обеспечивающие).</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Объявляйте данные-члены закрытыми (private). Это дает клиентам синтаксически однородный доступ к данным, обеспечивает возможность тонкого управления доступом, позволяет гарантировать инвариантность и предоставляет авторам реализации классов гибкость.</p>
<p>• Защищенные члены не более инкапсулированы, чем открытые.</p>
</section><section><title><p>Правило 23: Предпочитайте функциям-членам функции, не являющиеся ни членами, ни друзьями класса</p>
</title><p>Возьмем класс для представления Web-браузера. В числе прочих такой класс может предлагать функции, который очищают кэш загруженных элементов, очищают историю посещенных URL и удаляют из системы все «куки» (cookies):</p>
<empty-line/><p><code>class WebBrowser {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>void clearCache();</code></p>
<p><code>void clearHistory();</code></p>
<p><code>void removeCookies();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Найдутся пользователи, которые захотят выполнить все эти действия вместе, поэтому WebBrowser может также предоставить функцию и для этой цели:</p>
<empty-line/><p><code>class WebBrowser {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>void clearEveryThing(); // вызывает clearCache(), clearHistory()</code></p>
<p><code>// и removeCookies()</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Конечно, такая функциональность может быть обеспечена также функцией, не являющейся членом класса, которая вызовет соответствующие функции-члены:</p>
<empty-line/><p><code>void clearBrowser(WebBrowser&amp; wb)</code></p>
<p><code>{</code></p>
<p><code>wb.clearCache();</code></p>
<p><code>wb.clearHistory();</code></p>
<p><code>wb.removeCache();</code></p>
<p><code>}</code></p>
<empty-line/><p>Что лучше – функция-член clearEverything или свободная функция clear-Browser?</p>
<p>Принципы объектно-ориентированного проектирования диктуют, что данные и функции, которые оперируют ими, должны быть связаны вместе, и это предполагает, что функция-член – лучший выбор. К сожалению, это предположение неверно. Оно основано на непонимании того, что такое «объектно-ориентированный». Да, в объектно-ориентированных программах данные должны быть <emphasis>инкапсулированы,</emphasis> насколько возможно. В противоположность интуитивному восприятию функция-член clearEverything в действительности менее инкапсулирована, чем свободная функция clearBrowser. Более того, предоставление свободной функции позволяет обеспечить большую гибкость при «упаковке» функциональности класса WebBrowser, а это приводит к меньшему числу зависимостей на этапе компиляции и расширяет возможности для расширения класса. Поэтому свободная функция лучше по многим причинам. Важно их отчетливо понимать.</p>
<p>Начнем с инкапсуляции. Если некая сущность инкапсулируется, она скрывается из виду. Чем больше эта сущность инкапсулирована, тем меньше частей программы могут ее видеть. Чем меньше частей программы могут видеть некую сущность, тем больше гибкости мы имеем для внесения изменений, поскольку изменения напрямую касаются лишь тех частей, которым эти изменения видны. Таким образом, чем больше степень инкапсуляции сущности, тем шире наши возможности вносить в нее изменения. Вот причина того, почему мы ставим инкапсуляцию на первое место: она обеспечивает нам гибкость в изменении кода таким образом, что это затрагивает минимальное количество пользователей.</p>
<p>Рассмотрим данные, ассоциированные с объектом. Чем меньше существует кода, который видит эти данные (то есть имеет к ним доступ), тем в большей степени они инкапсулированы и тем свободнее мы можем менять их характеристики, например количество членов-данных, их типы и т. п. Грубой оценкой объем кода, который может видеть некоторый член данных, можно считать число функций, имеющих к нему доступ: чем больше таких функций, тем менее инкапсулированы данные.</p>
<p>В правиле 22 объясняется, что данные-члены должны быть закрытыми, потому что в противном случае к ним имеет доступ неограниченное число функций. Они вообще не инкапсулированы. Для <emphasis>закрытых</emphasis> же данных-членов количество функций, имеющих доступ к ним, определяется количеством функций-членов класса плюс количество функций-друзей, потому что доступ к закрытым членам разрешен только функциям-членам и друзьям класса. Если есть выбор между функцией-членом (которая имеет доступ не только к закрытым данным класса, но также к его закрытым функциям, перечислениям, определениям типов (typedef) и т. п.) и свободной функцией, не являющейся к тому же другом класса (такие функции не имеют доступа ни к чему из вышеперечисленного), но обеспечивающей ту же функциональность, то напрашивается очевидный вывод: большую инкапсуляцию обеспечивает функция, не являющаяся ни членом, ни другом, потому что она не увеличивает числа функций, которые могут иметь доступ к закрытой секции класса. Это объясняет, почему clearBrowser (свободная функция) предпочтительнее, чем clearEverything (функция-член).</p>
<p>Здесь стоит обратить внимание на два момента. Первое – все вышесказанное относится только к свободным функциям, <emphasis>не являющимся друзьями</emphasis> класса. Друзья имеют такой же доступ к закрытым членам класса, что и функции-члены, а потому точно так же влияют на инкапсуляцию. С точки зрения инкапсуляции, выбор следует делать не между функциями-членами и свободными функциями, а между функциями-членами, с одной стороны, и свободными функциями, не являющимися друзьями, – с другой. (Но оценивать проектное решение надо, конечно, не только с точки зрения инкапсуляции. В правиле 24 объясняется, что когда дело касается неявного приведения типов, то выбирать надо между функциями-членами и свободными функциями.)</p>
<p>Во-вторых, из того, что забота об инкапсуляции требует, чтобы функция не была членом класса, вовсе не следует, что эта функция не может быть членом какого-то другого класса. Это может облегчить жизнь программистам, привыкшим к языкам, в которых все функции <emphasis>должны</emphasis> быть членами классов (например, Eiffel, Java, C# и т. п.). Например, мы можем сделать clearBrowser статической функцией-членом некоторого служебного класса. До тех пор пока она не является частью (или другом) класса WebBrowser, она никак не скажется на инкапсуляции его закрытых членов.</p>
<p>В C++ более естественно объявить clearBrowser свободной функцией в том же пространстве имен, что и класс WebBrowser:</p>
<empty-line/><p><code>namespace WebBrowserStuff {</code></p>
<p><code>class WebBrowser {...};</code></p>
<p><code>void clearBrowser(WebBrowser&amp; wb);</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>Но дело тут не только в естественности, ведь пространства имен, в отличие от классов, могут быть находиться в нескольких исходных файлах. И это важно, потому что функции вроде clearBrowser являются <emphasis>вспомогательными.</emphasis> Не будучи ни членами, ни друзьями класса, они не имеют специального доступа к WebBrowser и никак не могут расширить те возможности, которые у пользователей класса WebBrowser и так уже были. Не будь функции clearBrowser, пользователь мог бы самостоятельно вызвать clearCache, clearHistory и removeCookies.</p>
<p>Для класса, подобного WebBrowser, можно было бы определить много таких вспомогательных функций: для работы с закладками, вывода на печать, управления «куками» и т. п. Вообще говоря, большинству пользователей будут интересны только некоторые из этих функций. Но с какой стати компиляция пользовательской программы, в которой используются только функции, относящиеся к закладкам, должна зависеть, например, от наличия функций управления «куками»? Самый простой способ разделить их – это объявить функции, относящиеся к закладкам, в одном заголовочном файле, функции управления «куками» – в другом, функции поддержки печати – в третьем и так далее:</p>
<empty-line/><p><code>// заголовок “webbrowser.h” – заголовок для самого класса WebBrowser,</code></p>
<p><code>// а также базовой функциональности, имеющей к нему отношение</code></p>
<p><code>namespace WebBrowserStuff {</code></p>
<p><code>class WebBrowser{...};</code></p>
<p><code>... // базовая функциональность, то есть</code></p>
<p><code>// функции-нечлены, нужные почти всем</code></p>
<p><code>// клиентам</code></p>
<p><code>}</code></p>
<p><code>// заголовок “webbrowserbookmarks.h”</code></p>
<p><code>namespace WebBrowserStuff {</code></p>
<p><code>... // вспомогательные функции, касающиеся</code></p>
<p><code>} // закладок</code></p>
<p><code>// заголовок “webbrowsercookies.h”</code></p>
<p><code>namespace WebBrowserStuff {</code></p>
<p><code>... // вспомогательные функции, касающиеся</code></p>
<p><code>} // “куков”</code></p>
<p><code>...</code></p>
<empty-line/><p>Отметим, что именно так организована стандартная библиотека C++. Вместо единственного монолитного заголовка &lt;С++ StandardLibrary&gt;, содержащего все, что есть в пространстве имен std, существуют десятки более мелких заголовочных файлов (например, &lt;vector&gt;, &lt;algorithm&gt;, &lt;memory&gt; и т. п.). В каждом из них объявлена некоторая функциональность из std. Пользователь, которому нужно только то, что имеет отношение к векторам, может не включать в свою программу директиву #include &lt;memory&gt;, а пользователь, не нуждающийся в списках, не обязан включать #include &lt;list&gt;. Поэтому на этапе компиляции пользовательские программы зависят только от тех частей системы, которые они действительно используют (см. в правиле 31 обсуждение других способов уменьшения зависимостей компиляции). Подобное разделение функциональности невозможно, если она обеспечивается функциями-членами класса, потому что класс должен быть определен полностью, его нельзя разбить на части.</p>
<p>Размещение вспомогательных функций в разных заголовочных файлах, но в одном пространстве имен – означает также, что пользователи могут легко расширять набор вспомогательных функций. Для этого нужно лишь поместить новые функции (нечлены и недрузья) в то же пространство имен. Например, если пользователь класса WebBrowser решит дописать вспомогательные функции, имеющие отношение к загрузке изображений, он должен будет создать заголовочный файл, включающий объявления этих функций в пространство имен Web-BrowserStuff. Новые функции становятся после этого так же доступны, как и все прочие вспомогательные функции. Это еще одно свойство, которое не могут представить классы, потому что определения классов закрыты для расширения клиентами. Конечно, клиенты могут создавать производные классы, но они не будут иметь доступа к инкапсулированным (то есть закрытым) членам базового класса, поэтому таким образом «расширенную» функциональность уже не назовешь первоклассной. Кроме того, в правиле 7 объясняется, что не все классы предназначены для того, чтобы быть базовыми.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Предпочитайте функциям-членам функции, не являющиеся ни членами, ни друзьями класса. Это повышает степень инкапсуляции и расширяемости, а также гибкость «упаковки» функциональности.</p>
</section><section><title><p>Правило 24: Объявляйте функции, не являющиеся членами, когда преобразование типов должно быть применимо ко всем параметрам</p>
</title><p>Во введении я отмечал, что в общем случае поддержка классом неявных преобразований типов – неудачная мысль. Но, конечно, из этого правила есть исключения, и одно из наиболее важных касается создания числовых типов. Например, если вы проектируете класс для представления рациональных чисел, то неявное преобразование целого числа в рациональное выглядит вполне разумно. Уж во всяком случае не менее разумно, чем встроенное в C++ преобразование int в double (и куда разумнее встроенного преобразования из double в int). Коли так, то начать объявления класса Rational можно было бы следующим образом:</p>
<empty-line/><p><code>class Rational {</code></p>
<p><code>public:</code></p>
<p><code>Rational(int numerator = 0,</code></p>
<p><code>int denominator = 1); // конструктор сознательно не explicit;</code></p>
<p><code>// допускает неявное преобразование</code></p>
<p><code>// int в Rational</code></p>
<p><code>int numerator() const; // функции доступа к числителю и</code></p>
<p><code>int denominator() const; // знаменателю – см. правило 22</code></p>
<p><code>private:</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Вы знаете, что понадобится поддерживать арифметические операции (сложение, умножение и т. п.), но не уверены, следует реализовывать их посредством функций-членов или свободных функций, возможно, являющихся друзьями класса. Инстинкт говорит: «Сомневаешься – придерживайся объектно-ориентированного подхода». Вы понимаете, что, скажем, умножение рациональных чисел относится к классу Rational, поэтому кажется естественным реализовать operator* в самом этом классе. Но наперекор интуиции правило 23 утверждает, что идея помещения функции внутрь класса, с которым она ассоциирована, иногда противоречит объектно-ориентированным принципам. Впрочем, оставим на время эту тему и посмотрим, во что выливается объявление operator* функцией-членом Rational:</p>
<empty-line/><p><code>class Rational {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>const Rational operator*(const Rational&amp; rhs) const;</code></p>
<p><code>}</code></p>
<empty-line/><p>Если вы не понимаете, почему эта функция объявлена именно таким образом (возвращает константный результат по значению и принимает ссылку на const в качестве аргумента), обратитесь к правилам 3, 20 и 21.</p>
<p>Такое решение позволяет легко манипулировать рациональными числами:</p>
<empty-line/><p><code>Rational oneEighth(1, 8);</code></p>
<p><code>Rational one Half(1, 2);</code></p>
<p><code>Rational result = oneHalf * oneEighth; // правильно</code></p>
<p><code>result = result * oneEighth; // правильно</code></p>
<empty-line/><p>Но вы не удовлетворены. Хотелось бы поддерживать также смешанные операции, чтобы Rational можно было умножить, например, на int. В конце концов, это довольно естественно – иметь возможность перемножать два числа, даже если они принадлежат к разным числовым типам.</p>
<p>Однако если вы попытаетесь выполнить смешанные арифметические операции, то обнаружите, что они работают только в половине случаев:</p>
<empty-line/><p><code>result = oneHalf * 2; // правильно</code></p>
<p><code>result = 2 * oneHalf; // ошибка!</code></p>
<empty-line/><p>Это плохой знак. Умножение должно быть коммутативным (не зависеть от порядка сомножителей), помните?</p>
<p>Источник проблемы становится понятным, если переписать два последних выражения в функциональной форме:</p>
<empty-line/><p><code>result = oneHalf.operator*(2); // правильно</code></p>
<p><code>result = 2.operator*(oneHalf); // ошибка!</code></p>
<empty-line/><p>Объект oneHalf – это экземпляр класса, включающего в себя operator*, поэтому компилятор вызывает эту функцию. Но с целым числом 2 не ассоциирован никакой класс, а значит, нет для него и функции operator*. Компилятор будет также искать функции operator*, не являющиеся членами класса (в текущем пространстве имен или в глобальной области видимости):</p>
<empty-line/><p><code>result = operator*(2, oneHalf); // ошибка!</code></p>
<empty-line/><p>Но в данном случае нет и свободной функции operator*, которая принимала бы аргументы int и Rational, поэтому поиск завершится ничем.</p>
<p>Посмотрим еще раз на успешный вызов. Видите, что второй параметр – целое число 2, хотя Rational::operator* принимает в качестве аргумента объект Rational. Что происходит? Почему 2 работает в одной позиции и не работает в другой?</p>
<p>Происходит неявное преобразование типа. Компилятор знает, что вы передали int, а функция требует Rational, но он также знает, что можно получить подходящий объект, если вызвать конструктор Rational c переданным вами аргументом int. Так он и поступает. Иными словами, компилятор трактует показанный выше вызов, как если бы он был написан примерно так:</p>
<empty-line/><p><code>const Rational temp(2); // создать временный объект Rational из 2</code></p>
<p><code>result = oneHalf * temp; // то же, что oneHalf.operator*(temp);</code></p>
<empty-line/><p>Конечно, компилятор делает это только потому, что есть конструктор, объявленный без квалификатора explicit. Если бы квалификатор explicit присутствовал, то ни одно из следующих предложений не скомпилировалось бы:</p>
<empty-line/><p><code>result = oneHalf * 2; // ошибка! (при наличии explicit-конструктора):</code></p>
<p><code>// невозможно преобразовать 2 в Ratinal</code></p>
<p><code>result = 2 * oneHalf; // та же ошибка, та же проблема</code></p>
<empty-line/><p>Со смешанной арифметикой при таком подходе придется распроститься, но, по крайней мере, такое поведение непротиворечиво.</p>
<p>Ваша цель, однако, – обеспечить и согласованность, и поддержку смешанной арифметики, то есть нужно найти такое решение, при котором оба предложения компилируются. Это возвращает нас к вопросу о том, почему даже при наличии explicit-конструктора в классе Rational одно из них компилируется, а другое – нет:</p>
<empty-line/><p><code>result = oneHalf * 2; // правильно (при не explicit-конструкторе)</code></p>
<p><code>result = 2 * oneHalf; // ошибка! (даже при не explicit-конструкторе)</code></p>
<empty-line/><p>Оказывается, что к параметрам применимы неявные преобразования, <emphasis>только если они перечислены в списке параметров.</emphasis> Неявный параметр, соответствующий объекту, чья функция-член вызывается (тот, на который указывает this), никогда не подвергается неявному преобразованию. Вот почему первый вызов компилируется, а второй – нет. В первом случае параметр указан в списке параметров функции, а во втором – нет.</p>
<p>Однако вам хотелось бы получить полноценную поддержку смешанной арифметики, и теперь ясно, как ее обеспечить: нужен operator* в виде свободной функции, тогда компилятор сможет выполнить неявное преобразование <emphasis>всех</emphasis> аргументов:</p>
<empty-line/><p><code>class Rational {</code></p>
<p><code>... // не содержит operator*</code></p>
<p><code>};</code></p>
<p><code>const Rational operator*(const Rational&amp; lhs, // теперь свободная функция</code></p>
<p><code>const Rational&amp; rhs)</code></p>
<p><code>{</code></p>
<p><code>return Rational(lhs.numerator() * rhs.numerator(),</code></p>
<p><code>lhs.denominator() * rhs.denominator());</code></p>
<p><code>}</code></p>
<p><code>Rational oneFourth(1, 4);</code></p>
<p><code>Rational result;</code></p>
<p><code>result = oneFourth * 2; // правильно</code></p>
<p><code>result = 2 * oneFourth; // ура, работает!</code></p>
<empty-line/><p>Это можно было бы назвать счастливым концом, если бы не одно «но». Должен ли operator* быть другом класса Rational?</p>
<p>В данном случае ответом будет «нет», потому что operator* может быть реализован полностью в терминах открытого интерфейса Rational. Приведенный выше код показывает, как это можно сделать. И мы приходим к важному выводу: противоположностью функции-члена является свободная функция, а функция – друг класса. Многие программисты на C++ полагают, что раз функция имеет отношение к классу и не должна быть его членом (например, из-за необходимости преобразовывать типы всех аргументов), то она должна быть другом. Этот пример показывает, что такое предположение неправильно. Если вы можете избежать назначения функции другом класса, то должны так и поступить, потому что, как и в реальной жизни, друзья часто доставляют больше хлопот, чем хотелось бы. Конечно, иногда отношения дружественности оправданы, но факт остается фактом: если функция не должна быть членом, это не означает автоматически, что она должна быть другом.</p>
<p>Сказанное выше правда, и ничего, кроме правды, но это не вся правда. Когда вы переходите от «Объектно-ориентированного C++» к «C++ с шаблонами» (см. правило 1) и превращаете Rational из класса в <emphasis>шаблон класса,</emphasis> то вступают в силу новые факторы, новые способы их учета, и появляются неожиданные проектные решения. Все это является темой правила 46.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Если преобразование типов должно быть применимо ко всем параметрам функции (включая и скрытый параметр this), то функция не должна быть членом класса.</p>
</section><section><title><p>Правило 25: Подумайте о поддержке функции swap, не возбуждающей исключений</p>
</title><p>swap – интересная функция. Изначально она появилась в библиотеке STL и с тех пор стала, во-первых, основой для написания программ, безопасных в смысле исключений (см. правило 29), а во-вторых, общим механизмом решения задачи и присваивания самому себе (см. правило 11). Раз уж swap настолько полезна, то важно реализовать ее правильно, но рука об руку с особой важностью идут и особые сложности. В этом правиле мы исследуем, что они собой представляют и как с ними бороться.</p>
<p>Чтобы обменять (swap) значения двух объектов, нужно присвоить каждому из них значение другого. По умолчанию такой обмен осуществляет стандартный алгоритм swap. Его типичная реализация не расходится с вашими ожиданиями:</p>
<empty-line/><p><code>namespace std {</code></p>
<p><code>template &lt;typename T&gt; // типичная реализация std::swap</code></p>
<p><code>void swap(T&amp; a, T&amp; b) // меняет местами значения a и b</code></p>
<p><code>{</code></p>
<p><code>T temp(a);</code></p>
<p><code>a = b;</code></p>
<p><code>b = temp;</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/><p>Коль скоро тип поддерживает копирование (с помощью конструктора копирования и оператора присваивания), реализация swap по умолчанию позволяет объектам этого типа обмениваться значениями без всяких дополнительных усилий с вашей стороны.</p>
<p>Стандартная реализация swap, может быть, не приведет вас в восторг. Она включает копирование трех объектов: a в temp, b в a и temp – в b. Для некоторых типов ни одна из этих операция в действительности не является необходимой. Для таких типов swap по умолчанию – быстрый путь на медленную дорожку.</p>
<p>Среди таких типов сразу стоит выделить те, что состоят в основном из указателей на другой тип, содержащий реальные данные. Общее название для таких проектных решений: «идиома pimpl» (pointer to implementation – указатель на реализацию – см. правило 31). Спроектированный так класс Widget может быть объявлен следующим образом:</p>
<empty-line/><p><code>class WidgetImpl { // класс для данных Widget</code></p>
<p><code>public: // детали несущественны</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>int a,b,c; // возможно, много данных –</code></p>
<p><code>std::vector&lt;double&gt; v; // копирование обойдется дорого</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class Widget { // класс, использующий идиому pimpl</code></p>
<p><code>public:</code></p>
<p><code>Widget(const Widget&amp; rhs);</code></p>
<p><code>Widget&amp; operator=(const Widget&amp; rhs) // чтоб скопировать Widget, копируем</code></p>
<p><code>{ // его объект WidgetImpl. Детали</code></p>
<p><code>... // реализации operator= как такового</code></p>
<p><code>*pimpl = *(rhs.pimpl); // см. в правилах 10, 11 и 12</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>WidgetImpl *pimpl; // указатель на объект с данными</code></p>
<p><code>}; // этого Widget</code></p>
<empty-line/><p>Чтобы обменять значения двух объектов Widget, нужно лишь обменять значениями их указатели pimpl, но алгоритм swap по умолчанию об этом знать не может. Вместо этого он не только трижды выполнит операцию копирования Widget, но еще и три раза скопирует Widgetlmpl. Очень неэффективно!</p>
<p>А нам бы хотелось сообщить функции std::swap, что при обмене объектов Widget нужно обменять значения хранящихся в них указателей pimpl. И такой способ существует: специализировать std::swap для класса Widget. Ниже приведена основная идея, хотя в таком виде код не скомпилируется:</p>
<empty-line/><p><code>namespace std {</code></p>
<p><code>template &lt;&gt; // это специализированная версия</code></p>
<p><code>void swap&lt;Widget&gt;(Widget&amp; a, // std::swap, когда T есть</code></p>
<p><code>Widget&amp; b) // Widget; <emphasis>не скомпилируется</emphasis></code></p>
<p><code>{</code></p>
<p><code>swap(a.pimpl, b.pimpl); // для обмена двух Widget просто</code></p>
<p><code>} // обмениваем их указатели pimpl</code></p>
<p><code>}</code></p>
<empty-line/><p>Строка «template &lt;&gt;» в начале функции говорит о том, что это <emphasis>полная специализация шаблона</emphasis> std::swap, а «&lt;Widget&gt;» после имени функции говорит о том, что это специализация для случая, когда T есть Widget. Другими словами, когда общий шаблон swap применяется к Widget, то должна быть использована эта реализация. Вообще-то не допускается изменять содержимое пространства имен std, но разрешено вводить полные специализации стандартных шаблонов (подобных swap) для созданных нами типов (например, Widget). Что мы и делаем.</p>
<p>Как я уже сказал, эта функция не скомпилируется. Дело в том, что она пытается получить доступ к указателям pimpl внутри a и b, а они закрыты. Мы можем объявить нашу специализацию другом класса, но соглашение требует поступить иначе: нужно объявить в классе Widget открытую функцию-член по имени swap, которая осуществит реальный обмен значениями, а затем специализация std::swap вызовет эту функцию-член:</p>
<empty-line/><p><code>class Widget { // все как раньше, за исключением</code></p>
<p><code>public: // добавления функции-члена swap</code></p>
<p><code>...</code></p>
<p><code>void swap(Widget&amp; other)</code></p>
<p><code>{</code></p>
<p><code>using std::swap; // необходимость в этом объявлении</code></p>
<p><code>// объясняется далее</code></p>
<p><code>swap(pimpl, other.pimpl); // чтобы обменять значениями два объекта</code></p>
<p><code>} // Widget,обмениваем указатели pimpl</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>namespace std {</code></p>
<p><code>template &lt;&gt; // переделанная версия</code></p>
<p><code>void swap&lt;Widget&gt;(Widget&amp; a, // std::swap</code></p>
<p><code>Widget&amp; b)</code></p>
<p><code>{</code></p>
<p><code>a.swap(b); // чтобы обменять значениями Widget,</code></p>
<p><code>} // вызываем функцию-член swap</code></p>
<p><code>}</code></p>
<empty-line/><p>Этот вариант не только компилируется, но и полностью согласован с STL-контейнерами, каждый из которых предоставляет и открытую функцию-член swap, и специализированную версию std::swap, которая вызывает эту функцию-член.</p>
<p>Предположим, однако, что Widget и Widgetlmpl – это не обычные, а <emphasis>шаблонные</emphasis> классы. Возможно, это понадобилось для того, чтобы можно было параметризировать тип данных, хранимых в Widgetlmpl:</p>
<empty-line/><p><code>template &lt;typename T&gt;</code></p>
<p><code>class WidgetImpl {...};</code></p>
<p><code>template &lt;typename T&gt;</code></p>
<p><code>class Widget {...};</code></p>
<empty-line/><p>Поместить функцию-член swap в Widget (и при необходимости в Widgetlmpl) в этом случае так же легко, как и раньше, но мы сталкиваемся с проблемой, касающейся специализации std::swap. Вот что мы хотим написать:</p>
<empty-line/><p><code>namespace std {</code></p>
<p><code>template &lt;typename T&gt;</code></p>
<p><code>void swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt;&amp; a, // ошибка! Недопустимый код</code></p>
<p><code>Widget&lt;T&gt;&amp; b)</code></p>
<p><code>{ a.swap(b);}</code></p>
<p><code>}</code></p>
<empty-line/><p>Выглядит совершенно разумно, но все равно неправильно. Мы пытаемся частично специализировать шаблон функции (std::swap), но, хотя C++ допускает частичную специализацию шаблонов класса, он не разрешает этого для шаблонов функций. Этот код не должен компилироваться (если только некоторые компиляторы не пропустят его по ошибке).</p>
<p>Когда вам нужно «частично специализировать» шаблон функции, лучше просто добавить перегруженную версию. Примерно так:</p>
<empty-line/><p><code>namespace std {</code></p>
<p><code>template &lt;typename T&gt;</code></p>
<p><code>void swap(Widget&lt;T&gt;&amp; a, // перегрузка std::swap</code></p>
<p><code>Widget&lt;T&gt;&amp; b) // (отметим отсутствие &lt;...&gt; после</code></p>
<p><code>{ a.swap(b);} // “swap”), далее объяснено, почему</code></p>
<p><code>} // этот код некорректен</code></p>
<empty-line/><p>Вообще, перегрузка шаблонных функций – нормальное решение, но std – это специальное пространство имен, и правила, которым оно подчиняется, тоже специальные. Можно полностью специализировать шаблоны в std, но нельзя добавлять в std новые шаблоны (или классы, или функции, или что-либо еще). Содержимое std определяется исключительно комитетом по стандартизации C++, и нам запрещено пополнять список того, что они решили включить туда. К сожалению, форма этого запрета может привести вас в смятение. Программы, которые нарушают его, почти всегда компилируются и исполняются, но их поведение не определено! Если вы не хотите, чтобы ваши программы вели себя непредсказуемым образом, то не должны добавлять ничего в std.</p>
<p>Что же делать? Нам по-прежнему нужен способ, чтобы разрешить другим людям вызывать swap и иметь более эффективную шаблонную версию. Ответ прост. Мы, как и раньше, объявляем свободную функцию swap, которая вызывает функцию-член swap, но не говорим, что это специализация или перегруженный вариант std::swap. Например, если вся функциональность, касающаяся Widget, находится в пространстве имен WidgetStuff, то это будет выглядеть так:</p>
<empty-line/><p><code>namespace WidgetStuff {</code></p>
<p><code>... // шаблонный WidgetImpl и т. п.</code></p>
<p><code>template&lt;typename T&gt; // как и раньше, включая</code></p>
<p><code>class Widget {...}; // функцию-член swap</code></p>
<p><code>...</code></p>
<p><code>template&lt;typename T&gt; // свободная функция swap</code></p>
<p><code>void swap(Widget&lt;T&gt;&amp; a, // не входит в пространство имен std</code></p>
<p><code>Widget&lt;T&gt;&amp; b)</code></p>
<p><code>{</code></p>
<p><code>a.swap(b);</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/><p>Теперь если кто-то вызовет swap для двух объектов Widget, то согласно правилам поиска имен в C++ (а точнее, согласно правилу <emphasis>учета зависимостей от аргументов)</emphasis> будет найдена специфичная для Widget версия в пространстве имен WidgetStuff. А это как раз то, что мы хотим.</p>
<p>Этот подход работает одинаково хорошо для классов и шаблонов классов, поэтому кажется, что именно его и следует всегда использовать. К сожалению, для классов есть причина, по которой надо специализировать std::swap (я опишу ее ниже), поэтому если вы хотите иметь собственную специфичную для класса версию swap, вызываемую в любых контекстах (а вы, без сомнения, хотите), то придется написать и свободную функцию swap в том же пространстве имен, где находится ваш класс, и специализацию std::swap.</p>
<p>Кстати, если вы не пользуетесь пространствам имен, все вышесказанное остается в силе (то есть вам нужна свободная функция swap, которая вызывает функцию-член swap). Но зачем засорять глобальное пространство имен вашими классами, шаблонами, функциями, перечислениями и перечисляемыми константами, определениями типов typedef? Разве вы не имеете понятия о приличиях?</p>
<p>Все, что я написал до сих пор, представляет интерес для авторов функции swap, но стоит посмотреть на ситуацию с точки зрения пользователя. Предположим, вы пишете шаблон функции, в котором хотите поменять значениями два объекта:</p>
<empty-line/><p><code>template &lt;typename T&gt;</code></p>
<p><code>void doSomething(T&amp; obj1, T&amp; obj2)</code></p>
<p><code>{</code></p>
<p><code>...</code></p>
<p><code>swap(obj1, obj2);</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>Какая версия swap должна здесь вызываться? Общая – из пространства std, о существовании которой вы точно знаете; ее специализация главного из std, которая может, существует, а может, нет; или специфичная для класса T, существование которой также под вопросом и которая может находиться в каком-то пространстве имен (но заведомо не в std)? Вам хотелось бы вызвать специфичную для T версию, если она существует, а в противном случае к общей версии из std. Вот как удовлетворить это желание:</p>
<empty-line/><p><code>template &lt;typename T&gt;</code></p>
<p><code>void doSomething(T&amp; obj1, T&amp; obj2)</code></p>
<p><code>{</code></p>
<p><code>using std::swap; // сделать std::swap доступной этой функции</code></p>
<p><code>...</code></p>
<p><code>swap(obj1, obj2); // вызвать лучший вариант swap для объектов типа T</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>Когда компилятор встречает вызов swap, он ищет, какую версию вызвать. Правила разрешения имен в C++ гарантируют, что будет найдена любая специфичная для типа T версия в глобальной области видимости или в том же пространстве имен, что и T. (Например, если T – это Widget в пространстве имен Widget-Stuff, компилятор проанализирует аргументы и найдет именно эту версию.) Если же версии swap, специфичной для T, не существует, то компилятор возьмет swap из std благодаря объявлению using, которая делает std::swap видимой. Но даже в этом случае компилятор предпочтет специализацию std::swap для типа T общему шаблону.</p>
<p>Таким образом, заставить компилятор вызвать нужную вам версию swap достаточно просто. Единственное, о чем следует позаботиться, – не квалифицировать вызов именем пространства имен, потому что это влияет на способ выбора функции. Например, если вы напишете вызов следующим образом:</p>
<empty-line/><p><code>std::swap(obj1, obj2): // неправильный способ вызова swap</code></p>
<empty-line/><p>то заставите компилятор рассматривать только swap из пространства std (включая все специализации шаблонов), исключив возможность отыскания более подходящей версии, специфичной для типа T, даже если она где-то определена. К сожалению, некоторые программисты по ошибке квалифицируют вызов swap таким образом, поэтому важно предоставлять в своем классе полную специализацию std::swap, тогда даже в таком, неправильно написанном коде специфичная для типа реализация swap окажется доступной. (Подобный код присутствует в некоторых реализациях стандартной библиотеки, поэтому в ваших интересах – сделать все, чтобы он работал эффективно).</p>
<p>Итак, мы обсудили реализацию swap по умолчанию, в виде функции-члена класса, в виде свободной функции и в виде специализации std::swap, а также вызовы swap. Теперь подведем итоги.</p>
<p>Во-первых, если реализация swap по умолчанию обеспечивает приемлемую эффективность для ваших классов или шаблонов классов, то вам не нужно делать ничего. Всякий, кто попытается обменять значения объектов вашего класса, получит версию по умолчанию, и она будет прекрасно работать.</p>
<p>Во-вторых, если реализация по умолчанию swap недостаточно эффективна (что почти всегда означает, что ваш класс или шаблон использует некоторую вариацию идиомы pimpl), сделайте следующее:</p>
<p>1) предоставьте открытую функцию-член, которая эффективно обменивает значения двух объектов вашего типа. По причинам, которые я сейчас объясню, эта функция никогда не должна возбуждать исключений;</p>
<p>2) предоставьте свободную функцию swap в том же пространстве имен, что и ваш класс или шаблон. Пусть она вызывает вашу функцию-член;</p>
<p>3) если вы пишете класс (а не шаблон), специализируйте std::swap для вашего класса. Пусть она также вызывает вашу функцию-член.</p>
<p>Наконец, если вы вызываете swap, убедитесь, что включено using-объявление, которое вводит std::swap в область видимости вашей функции, а затем вызывайте swap без квалификации пространства имен.</p>
<p>Я еще забыл предупредить, что версия функции-члена swap никогда не должна возбуждать исключений. Дело в том, что одно из наиболее частых применений swap – помочь классам (и шаблонам классов) в предоставлении надежных гарантий безопасности исключений. В правиле 29 вы найдете подробную информацию на эту тему, а сейчас лишь подчеркнем, что в основе этого приема лежит предположение о том, что swap, реализованная в виде функции-члена, никогда не возбуждает исключений. Это ограничение касается только функции-члена! Оно не относится к реализации swap в виде свободной функции, поскольку стандартная версия swap по умолчанию основана на конструкторах копирования и операторе присваивания, а этим функциям разрешено возбуждать исключения. Когда вы пишете собственную версию swap, то обычно представляете не просто эффективный способ обмена значений, а такой, при котором не возбуждаются исключения. Общее правил таково: эти две характеристики swap идут рука об руку, потому что высокоэффективные операции обмена всегда основаны на операциях над встроенными типами (такими как указатели, лежащие в основе идиомы pimpl), а операции над встроенными типами никогда не возбуждают исключений.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Предоставьте функцию-член swap, если std::swap работает с вашим типом неэффективно. Убедитесь, что она не возбуждает исключений.</p>
<p>• Если вы предоставляете функцию-член swap, то также предоставьте свободную функцию, вызывающую функцию-член. Для классов (не шаблонов) специализируйте также std::swap.</p>
<p>• Когда вызывается swap, используйте using-объявление, вводящее std::swap в область видимости, и вызывайте swap без квалификатора пространства имен.</p>
<p>• Допускается предоставление полной специализации шаблонов, находящихся в пространстве имен std, для пользовательских типов, но никогда не пытайтесь добавить в пространство std что-либо новое.</p>
</section></section><section><title><p>Глава 5</p>
<p>Реализация</p>
</title><section><p>В основном разработка программы сводится к написанию определений классов (и шаблонов классов) и объявлений функций (и шаблонов функций). Если сделать это правильно, то реализация уже не так сложна. Однако на некоторые моменты все же стоит обратить внимание. Слишком раннее определение переменных может отрицательно повлиять на производительность. Чрезмерное применение приведений типов также приводит к появлению медленно работающей программы, которую нелегко сопровождать и в которой могут быть трудноуловимые ошибки. Возврат дескрипторов внутренних данных объекта может нарушить принципы инкапсуляции и привести к появлению «висячих дескрипторов». Если не принимать во внимание исключения, результатом может стать утечка ресурсов и повреждение структур данных. Злоупотребление встроенными функциями приводит к «разбуханию» кода. Большое количество зависимостей между различными частями программы ведет к неприемлемо большим затратам времени на сборку программ.</p>
</section><section><title><p>Правило 26: Откладывайте определение переменных насколько возможно</p>
</title><p>Всякий раз при объявлении переменной, принадлежащий типу, в котором есть конструктор или деструктор, программа тратит время на ее конструирование, когда поток управления достигнет определения переменной, и на уничтожение – при выходе переменной из области видимости. Эти накладные расходы приходится нести даже тогда, когда переменная не используется, и, разумеется, их хотелось бы избежать.</p>
<p>Вероятно, вы думаете, что никогда не объявляете неиспользуемых переменных, но так ли это? Рассмотрим следующую функцию, которая возвращает зашифрованный пароль при условии, что его длина не меньше некоторого минимума. Если пароль слишком короткий, функция возбуждает исключение типа logic_error, определенное в стандартной библиотеке C++ (см. правило 54):</p>
<empty-line/><p><code>// эта функция объявляет переменную encrypted слишком рано</code></p>
<p><code>std::string encryptPassword(const std::string&amp; password)</code></p>
<p><code>{</code></p>
<p><code>using namespace std;</code></p>
<p><code>string encrypted;</code></p>
<p><code>if(password.length() &lt; MinimumPasswordLength) {</code></p>
<p><code>throw logic_error(“Слишком короткий пароль”);</code></p>
<p><code>}</code></p>
<p><code>... // сделать все, что необходимо для помещения</code></p>
<p><code>// зашифрованного пароля в переменную encrypted</code></p>
<p><code>return encrypted;</code></p>
<p><code>}</code></p>
<empty-line/><p>Нельзя сказать, что объект encrypted в этой функции совсем уж не используется, но он не используется в случае, когда возбуждается исключение. Другими словами, вы платите за вызов конструктора и деструктора объекта encrypted, даже если функция encryptPassword возбуждает исключение. Так не лучше ли отложить определение переменной encrypted до того момента, когда вы будете <emphasis>знать,</emphasis> что она нужна?</p>
<empty-line/><p><code>// в этой функции определение переменной encrypted отложено до момента,</code></p>
<p><code>// когда в ней возникает надобность</code></p>
<p><code>std::string encryptPassword(const std::string&amp; password)</code></p>
<p><code>{</code></p>
<p><code>using namespace std;</code></p>
<p><code>if(password.length() &lt; MinimumPasswordLength) {</code></p>
<p><code>throw logic_error(“Слишком короткий пароль”);</code></p>
<p><code>}</code></p>
<p><code>string encrypted;</code></p>
<p><code>... // сделать все, что необходимо для помещения</code></p>
<p><code>// зашифрованного пароля в переменную encrypted</code></p>
<p><code>return encrypted;</code></p>
<p><code>}</code></p>
<empty-line/><p>Этот код все еще не настолько компактный, как мог бы быть, потому что переменная encrypted определена без начального значения. А значит, будет использован ее конструктор по умолчанию. Часто первое, что нужно сделать с объектом, – это дать ему какое-то значение, нередко посредством присваивания. В правиле 4 объяснено, почему конструирование объектов по умолчанию с последующим присваиванием значения менее эффективно, чем инициализация нужным значением с самого начала. Это относится и к данному случаю. Например, предположим, что для выполнения «трудной» части работы функция encryptPassword вызывает следующую функцию:</p>
<empty-line/><p><code>void encrypt(std::string&amp; s); // шифрует s по месту</code></p>
<empty-line/><p>Тогда encryptPassword может быть реализована следующим образом, хотя и это еще не оптимальный способ:</p>
<empty-line/><p><code>// в этой функции определение переменной encrypted отложено до момента,</code></p>
<p><code>// когда в ней возникает надобность, но и этот вариант еще недостаточно</code></p>
<p><code>// эффективен</code></p>
<p><code>std::string encryptPassword(const std::string&amp; password)</code></p>
<p><code>{</code></p>
<p><code>... // проверка длины</code></p>
<p><code>string encrypted; // конструктор по умолчанию</code></p>
<p><code>encrypted = password; // присваивание encrypted</code></p>
<p><code>encrypt(encrypted);</code></p>
<p><code>return encrypted;</code></p>
<p><code>}</code></p>
<empty-line/><p>Еще лучше инициализировать encrypted параметром password, избежав таким образом потенциально дорогостоящего конструктора по умолчанию:</p>
<empty-line/><p><code>// а это оптимальный способ определения и инициализации encrypted</code></p>
<p><code>std::string encryptPassword(const std::string&amp; password)</code></p>
<p><code>{</code></p>
<p><code>... // проверка длины</code></p>
<p><code>string encrypted(password); // определение и инициализация</code></p>
<p><code>// конструктором копирования</code></p>
<p><code>encrypt(encrypted);</code></p>
<p><code>return encrypted;</code></p>
<p><code>}</code></p>
<empty-line/><p>Это и означает «откладывать насколько возможно» (как сказано в заголовке правила). Вы не только должны откладывать определение переменной до того момента, когда она используется, нужно еще постараться отложить определение до получения аргументов для инициализации. Поступив так, вы избегаете конструирования и разрушения ненужных объектов, а также излишних вызовов конструкторов по умолчанию. Более того, это помогает документировать назначение переменных за счет инициализации их в том контексте, в котором их значение понятно без слов.</p>
<p>«А как насчет циклов?» – можете удивиться вы. Если переменная используется только внутри цикла, то что лучше: определить ее вне цикла и выполнять присваивание на каждой итерации или определить ее внутри цикла? Другими словами, какая из следующих конструкций предпочтительнее?</p>
<empty-line/><p><code>// Подход A: определение вне цикла</code></p>
<p><code>Widget w;</code></p>
<p><code>for(int i=0; i&lt;n; ++i) {</code></p>
<p><code>w = <emphasis>некоторое значение, зависящее от i;</emphasis></code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<p><code>// Подход B: определение внутри цикла</code></p>
<p><code>for(int i=0; i&lt;n; ++i) {</code></p>
<p><code>Widget w(<emphasis>некоторое значение, зависящее от i</emphasis>);</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>Здесь я перехожу от объекта типа string к объекту типа Widget, чтобы избежать любых предположений относительно стоимости конструирования, разрушения и присваивания.</p>
<p>В терминах операций Widget накладные расходы вычисляются так:</p>
<p>• Подход A: 1 конструктор + 1 деструктор + n присваиваний</p>
<p>• Подход B: n конструкторов + n деструкторов</p>
<p>Для классов, в которых стоимость операции присваивания меньше, чем пары конструктор-деструктор, подход A обычно более эффективен. Особенно это верно, когда значение n достаточно велико. В противном случае, возможно, подход B лучше. Более того, в случае A имя w видимо в более широкой области (включающей в себя цикл), чем в случае B, а иногда это делает программу менее понятной и удобной для сопровождения. Поэтому если (1) нет априорной информации о том, что присваивание обходится дешевле, чем пара конструктор-деструктор, и (2) речь идет о части программы, производительность которой критична, то по умолчанию рекомендуется использовать подход B.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Откладывайте определение переменных насколько возможно. Это делает программы яснее и повышает их эффективность.</p>
</section><section><title><p>Правило 27: Не злоупотребляйте приведением типов</p>
</title><p>Правила C++ разработаны так, чтобы неправильно работать с типами было невозможно. Теоретически, если ваша программа компилируется без ошибок, значит, она не пытается выполнить никаких небезопасных или бессмысленных операций с объектами. Это ценная гарантия. Не надо от нее отказываться.</p>
<p>К сожалению, приведения обходят систему типов. И это может привести к различным проблемам, некоторые из которых распознать легко, а некоторые – чрезвычайно трудно. Если вы пришли к C++ из мира C, Java или C#, примите эток сведению, поскольку в указанных языках в приведениях типов чаще возникает необходимость, и они менее опасны, чем в C++. Но C++ – это не C. Это не Java. Это не C#. В этом языке приведение – это средство, к которому нужно относиться с должным почтением.</p>
<p>Начнем с обзора синтаксиса операторов приведения типов, потому что существует три разных способа написать одно и то же. Приведение в стиле C выглядит так:</p>
<empty-line/><p><code>(T) <emphasis>expression</emphasis> // привести <emphasis>expression</emphasis> к типу T</code></p>
<empty-line/><p>Функциональный синтаксис приведения таков:</p>
<empty-line/><p><code>T( <emphasis>expression)</emphasis> // привести <emphasis>expression</emphasis> к типу T</code></p>
<empty-line/><p>Между этими двумя формами нет ощутимого различия, просто скобки расставляются по-разному. Я называю эти формы <emphasis>приведениями в старом стиле.</emphasis></p>
<p>C++ также представляет четыре новые формы приведения типов (часто называемые приведениями <emphasis>в стиле С++):</emphasis></p>
<empty-line/><p><code>const_cast&lt;T&gt;(expression)</code></p>
<p><code>dynamic_cast&lt;T&gt;(expression)</code></p>
<p><code>reinterpret_cast&lt;T&gt;(expression)</code></p>
<p><code>static_cast&lt;T&gt;(expression)</code></p>
<empty-line/><p>У каждой из них свое назначение:</p>
<p>• const_cast обычно применяется для того, чтобы отбросить константность объекта. Никакое другое приведение в стиле C++ не позволяет это сделать;</p>
<p>• dynamic_cast применяется главным образом для выполнения «безопасного понижающего приведения» (downcasting). Этот оператор позволяет определить, принадлежит ли объект данного типа некоторой иерархии наследования. Это единственный вид приведения, который не может быть выполнен с использованием старого синтаксиса. Это также единственное приведение, которое может потребовать ощутимых затрат во время исполнения (подробнее позже);</p>
<p>• reinterpret_cast предназначен для низкоуровневых приведений, которые порождают зависимые от реализации (то есть непереносимые) результаты, например приведение указателя к int. Вне низкоуровневого кода такое приведение должно использоваться редко. Я использовал его в этой книге лишь однажды, когда обсуждал написание отладочного распределителя памяти (см. правило 50);</p>
<p>• static_cast может быть использован для явного преобразования типов (например, неконстантных объектов к константным (как в правиле 3), int к double и т. п.). Он также может быть использован для выполнения обратных преобразований (например, указателей void* к типизированным указателям, указателей на базовый класс к указателю на производный). Но привести константный объект к неконстантному этот оператор не может (это вотчина const_cast).</p>
<p>Применение приведений в старом стиле остается вполне законным, но новые формы предпочтительнее. Во-первых, их гораздо легче найти в коде (и для человека, и для инструмента, подобного grep), что упрощает процесс поиска в коде тех мест, где система типизации подвергается опасности. Во-вторых, более узко специализированное назначение каждого оператора приведения дает возможность компиляторам диагностировать ошибки их использования. Например, если вы попытаетесь избавиться от константности, используя любой оператор приведения в стиле C++, кроме const_cast, то ваш код не откомпилируется.</p>
<p>Я использую приведение в старом стиле только тогда, когда хочу вызвать explicit конструктор, чтобы передать объект в качестве параметра функции. Например:</p>
<empty-line/><p><code>class Widget {</code></p>
<p><code>public:</code></p>
<p><code>explicit Widget(int size);</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>void doSomeWork(const Widget&amp; w);</code></p>
<p><code>doSomeWork(Widget(15)); // создать Widget из int</code></p>
<p><code>// с функциональным приведением</code></p>
<p><code>doSomeWork(static_cast&lt;Widget&gt;(15)); // создать Widget из int</code></p>
<p><code>// с приведением в стиле C++</code></p>
<empty-line/><p>Но намеренное создание объекта не «ощущается» как приведение типа, поэтому в данном случае, наверное, лучше применить функциональное приведение вместо static_cast. Да и вообще, код, ведущий к аварийному завершению, обычно выглядит совершенно разумным, когда вы его пишете, поэтому лучше не обращать внимания на ощущения и всегда пользоваться приведениями в новом стиле.</p>
<p>Многие программисты полагают, что приведение типа всего лишь говорит компилятору, что нужно трактовать один тип как другой, но они заблуждаются. Преобразования типа любого рода (как явные, посредством приведения, так и неявные, выполняемые самим компилятором) часто приводят к появлению кода, исполняемого во время работы программы. Рассмотрим пример:</p>
<empty-line/><p><code>int x, y;</code></p>
<p><code>...</code></p>
<p><code>double d = static_cast&lt;double&gt;(x)/y; // деление x на y с использованием</code></p>
<p><code>// деления с плавающей точкой</code></p>
<empty-line/><p>Приведение int x к типу double почти наверняка порождает исполняемый код, потому что в большинстве архитектур внутреннее представление int отличается от представления double. Если это вас не особенно удивило, но взгляните на следующий пример:</p>
<empty-line/><p><code>class Base {...};</code></p>
<p><code>class Derived: public Base {...};</code></p>
<p><code>Derived d;</code></p>
<p><code>Base *pb = &amp;d; // неявное преобразование Derived*</code></p>
<p><code>// в Base*</code></p>
<empty-line/><p>Здесь мы всего лишь создали указатель базового класса на объект производного, но <strong>иногда</strong> эти два указателя указывают вовсе не на одно и то же. В таком случае <emphasis>во время исполнения</emphasis> к указателю Derived* прибавляется смещение, чтобы получить правильное значение указателя Base*.</p>
<p>Последний пример демонстрирует, что один и тот же объект (например, объект типа Derived) может иметь более одного адреса (например, адрес при указании на него как на Base* отличается от адреса при указании как на Derived*). Такое невозможно в C. Такое невозможно в Java. Такого не бывает в C#. Но это случается в C++. Фактически, когда применяется множественное наследование, такое случается сплошь и рядом, но может произойти и при одиночном наследовании. Это ко всему прочему означает, что, программируя на C++, вы не должны строить предположений о том, как объекты располагаются в памяти, и уж тем более не должны выполнять приведение типов на базе этих предположений. Например, приведение адреса объекта к типу char* и последующее использование арифметических операций над указателями почти всегда становятся причиной неопределенного поведения.</p>
<p>Заметьте, я сказал, что смещение требуется прибавлять «иногда». Способы размещения объектов в памяти и способы вычисления их адресов изменяются от компилятора к компилятору. А значит, из того, что «вы знаете, как хранится объект в памяти» на одной платформе, вовсе не следует, что на других все будет устроено точно так же. Мир полон программистов, которые усвоили этот урок, заплатив слишком высокую цену.</p>
<p>Интересный момент, касающийся приведений, – еще в том, что легко написать код, который выглядит правильным (и может быть правильным на других языках), но на самом деле правильным не является. Например, во многих каркасах для разработки приложений требуется, чтобы виртуальные функции-члены, определенные в производных классах, вначале вызывали соответствующие функции из базовых классов. Предположим, что у нас есть базовый класс Window и производный от него класс SpecialWindow, причем в обоих определена виртуальная функция onResize. Далее предположим, что onResize из SpecialWindow будет вызывать сначала onResize из Window. Следующая реализация выглядит хорошо, но по сути неправильна:</p>
<empty-line/><p><code>class Window { // базовый класс</code></p>
<p><code>public:</code></p>
<p><code>virtual void onResize() {...} // реализация onResize в базовом</code></p>
<p><code>... // классе</code></p>
<p><code>};</code></p>
<p><code>class SpecialWindow: public Window { // производный класс</code></p>
<p><code>public:</code></p>
<p><code>virtual void onResize() { // реализация onResize</code></p>
<p><code>static_cast&lt;Window&gt;(*this).onResize(); // в производном классе;</code></p>
<p><code>// приведение *this к Window,</code></p>
<p><code>// затем вызов его onResize;</code></p>
<p><code>// <emphasis>это не работает!</emphasis></code></p>
<p><code>... // выполнение специфической для</code></p>
<p><code>} // SpecialWindow части onResize</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Я выделил в этом коде приведение типа. (Это приведение в новом стиле, но использование старого стиля ничего не меняет.) Как и ожидается, *this приводит к типу Window. Поэтому обращение к onResize приводит к вызову Window::onResize. Вот только эта функция не будет вызвана для текущего объекта! Неожиданно, не правда ли? Вместо этого оператор приведения создаст новую, временную копию части базового класса *this и вызовет onResize для этой копии! Приведенный выше код не вызовет Window::onResize для текущего объекта с последующим выполнением специфичных для SpecialWindow действий – он выполнит Window::onResize для <emphasis>копии части базового класса</emphasis> текущего объекта перед выполнением специфичных для SpecialWindow действий для данного объекта. Если Window::onResize модифицирует объект (что вполне возможно, так как onResize – не константная функция-член), то текущий объект не будет модифицирован. Вместо этого будет модифицирована <emphasis>копия</emphasis> этого объекта. Однако если SpecialWindow::onResize модифицирует объект, то будет модифицирован именно текущий объект. И в результате текущий объект остается в несогласованном состоянии, потому что модификация той его части, что принадлежит базовому классу, не будет выполнена, а модификация части, принадлежащей производному классу, будет.</p>
<p>Решение проблемы в том, чтобы исключить приведение типа, заменив его тем, что вы действительно имели в виду. Нет необходимости выполнять какие-то трюки с компилятором, заставляя его интерпретировать *this как объект базового класса. Вы хотите вызвать версию onResize базового класса для текущего объекта. Так поступите следующим образом:</p>
<empty-line/><p><code>class SpecialWindow: public Window {</code></p>
<p><code>public:</code></p>
<p><code>virtual void onResize() {</code></p>
<p><code>Window::onResize(); // вызов Window::onResize на *this</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Приведенный пример также демонстрирует, что коль скоро вы ощущаете желание выполнить приведение типа, это знак того, что вы, возможно, на ложном пути. Особенно это касается оператора dynamic_cast.</p>
<p>Прежде чем вдаваться в детали dynamic_cast, стоит отметить, что большинство реализаций этого оператора работают довольно медленно. Так, по крайней мере, одна из распространенных реализаций основана на сравнении имен классов, представленных строками. Если вы выполняете dynamic_cast для объекта класса, принадлежащего иерархии с одиночным наследованием глубиной в четыре уровня, то каждое обращение к dynamic_cast в такой реализации может обойтись вам в четыре вызова strcmp для сравнения имен классов. Для более глубокой иерархии или такой, в которой имеется множественное наследование, эта операция окажется еще более дорогостоящей. Есть причины, из-за которых некоторые реализации работают подобным образом (потому что они должны поддерживать динамическую компоновку). Таким образом, в дополнение к настороженности по отношению к приведениям типов в принципе вы должны проявлять особый скептицизм, когда речь идет о применении dynamic_cast в части программы, для которой производительность стоит на первом месте.</p>
<p>Необходимость в dynamic_cast обычно появляется из-за того, что вы хотите выполнить операции, определенные в производном классе, для объекта, который, как вы полагаете, принадлежит производному классу, но при этом у вас есть только указатель или ссылка на базовый класс, посредством которой нужно манипулировать объектом. Есть два основных способа избежать этой проблемы.</p>
<p>Первый – используйте контейнеры для хранения указателей (часто «интеллектуальных», см. правило 13) на сами объекты производных классов, тогда отпадет необходимость манипулировать этими объектами через интерфейсы базового класса. Например, если в нашей иерархии Window/SpecialWindow только SpecialWindow поддерживает мерцание (blinking), то вместо:</p>
<empty-line/><p><code>class Window { ...};</code></p>
<p><code>class SpecialWindow {</code></p>
<p><code>public:</code></p>
<p><code>void blink();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>typedef // см. правило 13</code></p>
<p><code>std::vector&lt;std::tr1::shared_ptr&lt;Window&gt;&gt;VPW; // о tr1::shared_ptr</code></p>
<p><code>VPW winPtrs;</code></p>
<p><code>...</code></p>
<p><code>for (VPW::iterator iter = winPtrs.begin(); // нежелательный код:</code></p>
<p><code>iter!=winPtrs.end(); // применяется dynamic_cast</code></p>
<p><code>++iter){</code></p>
<p><code>if(SpecialWindow psw = dynamic_cast&lt;SpecialWindow&gt;(iter-&gt;get()))</code></p>
<p><code>psw-&gt;blink();</code></p>
<p><code>}</code></p>
<empty-line/><p>попробуйте сделать так:</p>
<empty-line/><p><code>typedef std::vector&lt;std::tr1::shared_ptr&lt;SpecialWindow&gt;&gt; VPSW;</code></p>
<p><code>VPSW winPtrs;</code></p>
<p><code>...</code></p>
<p><code>for (VPSW::iterator iter = winPtrs.begin(); // это лучше:</code></p>
<p><code>iter != winPtrs.end(); // не использует dynamic_cast</code></p>
<p><code>++iter)</code></p>
<p><code>(*iter)-&gt;blink();</code></p>
<empty-line/><p>Конечно, такой подход не позволит вам хранить указатели на объекты всех возможных производных от Window классов в одном и том же контейнере. Чтобы работать с разными типами окон и обеспечить безопасность по отношению к типам, вам может понадобиться несколько контейнеров.</p>
<p>Альтернатива, которая позволит манипулировать объектами всех возможных производных от Window классов через интерфейс базового класса, – это предусмотреть виртуальные функции в базовом классе, которые позволят вам делать именно то, что вам нужно. Например, хотя только SpecialWindow умеет мерцать, может быть, имеет смысл объявить функцию в базовом классе и обеспечить там реализацию по умолчанию, которая не делает ничего:</p>
<empty-line/><p><code>class Window {</code></p>
<p><code>public:</code></p>
<p><code>virtual void blink() {} // реализация по умолчанию – пустая</code></p>
<p><code>... // операция, см. в правиле 34 – почему</code></p>
<p><code>}; // наличие реализации по умолчанию</code></p>
<p><code>// может оказаться неудачной идеей</code></p>
<p><code>class SpecialWindow: public Window {</code></p>
<p><code>public:</code></p>
<p><code>virtual void blink() {...}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>typedef std::vector&lt;std::tr1::shared_ptr&lt;Window&gt;&gt;VPW;</code></p>
<p><code>VPW winPtrs; // контейнер содержит</code></p>
<p><code>// (указатели на) все возможные</code></p>
<p><code>... // типы окон</code></p>
<p><code>for(VPW::iterator iter = winPtrs.begin();</code></p>
<p><code>iter != winPtrs.end();</code></p>
<p><code>++iter) // dynamic_cast не используется</code></p>
<p><code>(*iter)-&gt;blink();</code></p>
<empty-line/><p>Ни один из этих подходов – с применением безопасных по отношению к типам контейнеров или перемещением виртуальной функции вверх по иерархии – не является универсально применимым, но во многих случаях они представляют полезную альтернативу dynamic_cast. Пользуйтесь ими, когда возможно.</p>
<p>Но вот чего стоит избегать всегда – это каскадов из операторов dynamic_cast, то есть чего-то вроде такого кода:</p>
<empty-line/><p><code>class Window {...};</code></p>
<p><code>... // здесь определены производные классы</code></p>
<p><code>typedef std::vector&lt;std::tr1::shared_ptr&lt;Window&gt;&gt; VPW;</code></p>
<p><code>VPW winPtrs;</code></p>
<p><code>...</code></p>
<p><code>for (VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter)</code></p>
<p><code>{</code></p>
<p><code>if (SpecialWindow1 *psw1=</code></p>
<p><code>dynamic_cast&lt;SpecialWindow1&gt;(iter-&gt;get())) {...}</code></p>
<p><code>else if (SpecialWindow2 *psw2=</code></p>
<p><code>dynamic_cast&lt;SpecialWindow2&gt;(iter-&gt;get())) {...}</code></p>
<p><code>else if (SpecialWindow2 *psw2=</code></p>
<p><code>dynamic_cast&lt;SpecialWindow2&gt;(iter-&gt;get())) {...}</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>В этом случае генерируется объемный и медленный код, к тому же он нестабилен, потому что при каждом изменении иерархии классов Window весь этот код нужно пересмотреть на предмет обновления. Например, если добавится новый производный класс, то вероятно, придется добавить еще одну ветвь в предложение if. Подобный код почти всегда должен быть заменен чем-то на основе вызова виртуальных функций.</p>
<p>В хорошей программе на C++ приведения типов используются очень редко, но полностью отказываться от них тоже не стоит. Так, показанное выше приведение int к double является разумным, хотя и не абсолютно необходимым (код может быть переписан с объявлением новой переменной типа double, инициируемой значением x). Как и большинство сомнительных конструкций, приведения типов должны быть изолированы насколько возможно. Обычно они помещаются внутрь функций, чей интерфейс скрывает от пользователей те некрасивые дела, что творятся внутри.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Избегайте насколько возможно приведений типов, особенно dynamic_cast, в критичном по производительности коде. Если дизайн требует приведения, попытайтесь разработать альтернативу, где такой необходимости не возникает.</p>
<p>• Когда приведение типа необходимо, постарайтесь скрыть его внутри функции. Тогда пользователи смогут вызывать эту функцию вместо помещения приведения в их собственный код.</p>
<p>• Предпочитайте приведения в стиле C++ старому стилю. Их легче увидеть, и они более избирательны.</p>
</section><section><title><p>Правило 28: Избегайте возвращения «дескрипторов» внутренних данных</p>
</title><p>Представим, что вы работаете над приложением, имеющим дело с прямоугольниками. Каждый прямоугольник может быть представлен своим левым верхним углом и правым нижним. Чтобы объект Rectangle оставался компактным, вы можете решить, что описание определяющих его точек следует вынести из Rectangle во вспомогательную структуру:</p>
<empty-line/><p><code>class Point { // класс, представляющий точки</code></p>
<p><code>public:</code></p>
<p><code>Point(int x, int y);</code></p>
<p><code>...</code></p>
<p><code>void setX(int newVal);</code></p>
<p><code>void setY(int newVal);</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>struct RectData { // точки, определяющие Rectangle</code></p>
<p><code>Point ulhc; // ulhc – верхний левый угол</code></p>
<p><code>Point lrhc; // lrhc – нижний правый угол</code></p>
<p><code>};</code></p>
<p><code>class Rectangle {</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>std::tr1::shared_ptr&lt;RectData&gt; pData; // см. в правиле 13</code></p>
<p><code>}; // информацию о tr1::shared_ptr</code></p>
<empty-line/><p>Поскольку пользователям класса Rectangle понадобится определять его координаты, то класс предоставляет функции upperLeft и lowerRight. Однако Point – это определенный пользователем тип, поэтому, помня о том, что передача таких типов по ссылке обычно более эффективна, чем передача по значению (см. правило 20), эти функции возвращают ссылки на внутренние объекты Point:</p>
<empty-line/><p><code>class Rectangle {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>Point&amp; upperLeft() const { return pData-&gt;ulhc;}</code></p>
<p><code>Point&amp; lowerRight() const { return pData-&gt;lrhc;}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Такой вариант откомпилируется, но он неправильный! Фактически он внутренне противоречив. С одной стороны, upperLeft и lowerRight объявлены как константные функции-члены, поскольку они предназначены только для того, чтобы предоставить клиенту способ получить информацию о точках Rectangle, не давая ему возможности модифицировать объект Rectangle (см. правило 3). С другой стороны, обе функции возвращают ссылки на закрытые внутренние данные – ссылки, которые пользователь может затем использовать для модификации этих внутренних данных! Например:</p>
<empty-line/><p><code>Point coord1(0, 0);</code></p>
<p><code>Point coord2(100,100);</code></p>
<p><code>const Rectangle rec(coord1, coord2); // rec – константный прямоугольник</code></p>
<p><code>// от (0, 0) до (100, 100)</code></p>
<p><code>rec.upperLeft().setX(50); // теперь rec лежит между</code></p>
<p><code>// (50, 0) и (100, 100)!</code></p>
<empty-line/><p>Обратите внимание, что пользователь функции upperLeft может использовать возвращенную ссылку на один из данных-членов внутреннего объекта Point для модификации этого члена. Но ведь ожидается, что rec – константа!</p>
<p>Из этого примера следует извлечь два урока. Первый – член данных инкапсулирован лишь настолько, насколько доступна функция, возвращающая ссылку на него. В данном случае хотя ulhc и lrhc объявлены закрытыми, но на самом деле они открыты, потому что на них возвращают ссылки открытые функции upperLeft и lowerRight. Второй урок в том, что если константная функция-член возвращает ссылку на данные, ассоциированные с объектом, но хранящиеся вне самого объекта, то код, вызывающий эту функцию, может модифицировать данные. (Все это последствия ограничений побитовой константности – см. правило 3.)</p>
<p>Такой результат получился, когда мы использовали функции-члены, возвращающие ссылки, но если они возвращают указатели или итераторы, проблема остается, и причины те же. Ссылки, указатели и итераторы – все это «дескрипторы» (handles), и возвращение такого «дескриптора» внутренних данных объекта – прямой путь к нарушению принципов инкапсуляции. Как мы только что видели, это может привести к тому, что константные функции-члены позволят модифицировать состояние объекта.</p>
<p>Обычно, говоря о внутреннем устройстве объекта, мы имеем в виду его данные-члены, но функции-члены, к которым нет открытого доступа (то есть объявленные в секции private или protected), также являются частью внутреннего устройства. Поэтому возвращать их «дескрипторы» тоже не следует. Иными словами, нельзя, чтобы функция-член возвращала указатель на менее доступную функцию-член. В противном случае реальный уровень доступа будет определять более доступная функция, потому что клиенты смогут получить указатель на менее доступную функцию и вызвать ее через такой указатель.</p>
<p>Впрочем, функции, которые возвращают указатели на функции-члены, встречаются нечасто, поэтому вернемся к классу Rectangle и его функциям-членам upperLeft и lowerRight. Обе проблемы, которые мы идентифицировали для этих функций, могут быть исключены простым применением квалификатора const к их возвращаемому типу:</p>
<empty-line/><p><code>class Rectangle {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>const Point&amp; upperLeft() const { return pData-&gt;ulhc;}</code></p>
<p><code>const Point&amp; lowerRight() const { return pData-&gt;lrhc;}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>В результате такого изменения пользователи смогут читать объекты Point, определяющие прямоугольник, но не смогут изменять их. Это значит, что объявление константными функций upperLeft и lowerRight больше не является ложью, так как они более не позволяют клиентам модифицировать состояние объекта. Что касается проблемы инкапсуляции, то мы с самого начала намеревались дать клиентам возможность видеть объекты Point, определяющие Rectangle, поэтому в данном случае ослабление инкапсуляции намеренное. К тому же это лишь <emphasis>частичное</emphasis> ослабление: рассматриваемые функции дают только доступ для чтения. Доступ для записи по-прежнему запрещен.</p>
<p>Но даже и так upperLeft и lowerRight по-прежнему возвращают «дескрипторы» внутренних данных объекта, и это может вызвать проблемы иного свойства. В частности, возможно появление «висячих дескрипторов» (dangling handles), то есть дескрипторов, ссылающихся на части уже не существующих объектов. Наиболее типичный источник таких исчезнувших объектов – значения, возвращаемые функциями. Например, рассмотрим функцию, которая возвращает ограничивающий прямоугольник объекта GUI:</p>
<empty-line/><p><code>class GUIObject {...};</code></p>
<p><code>const Rectangle // возвращает прямоугольник по значению;</code></p>
<p><code>boundBox(const GUIObject&amp; obj); // см. в правиле 3, почему const</code></p>
<empty-line/><p>Теперь посмотрим, как пользователь может применить эту функцию:</p>
<empty-line/><p><code>GUIObject *pgo; // pgo указывает на некий объект</code></p>
<p><code>... // GUIObject</code></p>
<p><code>const Point *pUpperLeft = // получить указатель на верхний левый</code></p>
<p><code>&amp;(boundingBox(*pgo).upperLeft()); // угол его рамки</code></p>
<empty-line/><p>Вызов boundingBox вернет новый временный объект Rectangle. Этот объект не имеет имени, поэтому назовем его <emphasis>temp.</emphasis> Затем вызывается функция-член <emphasis>upperLeft</emphasis> объекта <emphasis>temp,</emphasis> и этот вызов возвращает ссылку на внутренние данные <emphasis>temp,</emphasis> в данном случае на один из объектов Point. В результате pUpperLeft указывает на этот объект Point. До сих пор все шло хорошо, но мы еще не закончили, поскольку в конце предложения возвращенное boundingBox значение – <emphasis>temp</emphasis> – будет разрушено, а это приведет к разрушению объектов Point, принадлежавших <emphasis>temp.</emphasis> То есть pUpperLeft теперь указывает на объект, который более не существует. Указатель PUpperLeft становится «висячим» уже в конце предложения, где он создан!</p>
<p>Вот почему опасна любая функция, которая возвращает «дескриптор» внутренних данных объекта. При этом не важно, является ли «дескриптор» ссылкой, указателем или итератором. Не важно, что она квалифицирована const. Не важно, что сама функция-член, возвращающая «дескриптор», является константной. Имеет значение лишь тот факт, что «дескриптор» возвращен, поскольку возникает опасность, что он «переживет» объект, с которым связан.</p>
<p>Это не значит, что <emphasis>никогда</emphasis> не следует писать функции-члены, возвращающие дескрипторы. Иногда это бывает необходимо. Например, operator[] позволяет вам обращаться к отдельному элементу строки или вектора, и работает он, возвращая ссылку на данные в контейнере (см. правило 3), которые уничтожаются вместе с контейнером. Но все же такие функции – скорее исключение, чем правило.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Избегайте возвращать «дескрипторы» (ссылки, указатели, итераторы) внутренних данных объекта. Это повышает степень инкапсуляции, помогает константным функциям-членам быть константными и минимизирует вероятность появления «висячих дескрипторов».</p>
</section><section><title><p>Правило 29: Стремитесь, чтобы программа была безопасна относительно исключений</p>
</title><p>Безопасность исключений в чем-то подобна беременности… но пока отложим эту мысль в сторонку. Нельзя всерьез говорить о репродуктивной функции, пока не завершился этап ухаживания.</p>
<p>Предположим, что у нас есть класс, представляющий меню с фоновыми картинками в графическом интерфейсе пользователя. Этот класс предназначен для использования в многопоточной среде, поэтому он включает мьютекс для синхронизации доступа:</p>
<empty-line/><p><code>class PrettyMenu {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>void changeBackground(std::istream&amp; imgSrc); // сменить фоновую</code></p>
<p><code>... // картинку</code></p>
<p><code>private:</code></p>
<p><code>Mutex mutex; // мьютекс объекта</code></p>
<p><code>Image *bgImage; // текущая фоновая картинка</code></p>
<p><code>int imageChanges; // сколько раз картинка менялась</code></p>
<p><code>};</code></p>
<empty-line/><p>Рассмотрим следующую возможную реализацию функции-члена change-Background:</p>
<empty-line/><p><code>void PrettyMenu::changeBackground(std::istream&amp; imgSrc)</code></p>
<p><code>{</code></p>
<p><code>lock(&amp;mutex); // захватить мьютекс</code></p>
<p><code>delete bgImage; // избавиться от старой картинки</code></p>
<p><code>++imageChanges; // обновить счетчик изменений картинки</code></p>
<p><code>bgImage = new Image(imgSrc); // установить новый фон</code></p>
<p><code>unlock(&amp;mutex); // освободить мьютекс</code></p>
<p><code>}</code></p>
<empty-line/><p>С точки зрения безопасности исключений, эта функция настолько плоха, насколько вообще возможно. К безопасности исключений предъявляется два требования, и она не удовлетворяет ни одному из них.</p>
<p>Когда возбуждается исключение, то безопасная относительно исключений функция:</p>
<p>• <strong>Не допускает утечки ресурсов.</strong> Приведенный код не проходит этот тест, потому что если выражение «new Image(imgSrc)» возбудит исключение, то вызов unlock никогда не выполнится, и мьютекс окажется захваченным навсегда.</p>
<p>• <strong>Не допускает повреждения структур данных.</strong> Если «new Image(imgSrc)» возбудит исключение, в bgImage останется указатель на удаленный объект. Кроме того, счетчик imageChanges увеличивается, несмотря на то что новая картинка не установлена. (С другой стороны, старая картинка уже полностью удалена, так что трудно сделать вид, будто ничего не изменилось.)</p>
<p>Справиться с утечкой ресурсов легко – в правиле 13 объяснено, как пользоваться объектами, управляющими ресурсами, а в правиле 14 представлен класс Lock, гарантирующий своеременное освобождение мьютексов:</p>
<empty-line/><p><code>void PrettyMenu::changeBackground(std::istream&amp; imgSrc)</code></p>
<p><code>{</code></p>
<p><code>Lock ml(mutex); // из правила 14: захватить мьютекс</code></p>
<p><code>// и гарантировать его последующее освобождение</code></p>
<p><code>delete bgImage;</code></p>
<p><code>++imageChanges;</code></p>
<p><code>bgImage = new Image(imgSrc);</code></p>
<p><code>}</code></p>
<empty-line/><p>Одним из преимуществ классов для управления ресурсами, подобных Lock, является то, что обычно они уменьшают размер функций. Заметили, что вызов unlock уже не нужен? Общее правило гласит: чем меньше кода, тем лучше, потому что меньше возможностей для ошибок и меньше путаницы при внесении изменений.</p>
<p>От утечки ресурсов перейдем к проблеме возможного повреждения данных. Здесь у нас есть выбор, но прежде чем его сделать, нужно уточнить терминологию.</p>
<p>Безопасные относительно исключений функции предоставляют одну из трех гарантий.</p>
<p>• Функции, предоставляющие <strong>базовую гарантию,</strong> обещают, что если исключение будет возбуждено, то все в программе остается в корректном состоянии. Никакие объекты или структуры данных не повреждены, и все объекты находятся в непротиворечивом состоянии (например, все инварианты классов не нарушены). Однако точное состояние программы может быть непредсказуемо. Например, мы можем написать функцию change-Background так, что при возникновении исключения объект PrettyMenu сохранит старую фоновую картинку либо у него будет какой-то фон по умолчанию, но пользователи не могут заранее знать, какой. (Чтобы выяснить это, им придется вызвать какую-то функцию-член, которая сообщит, какая сейчас используется картинка.)</p>
<p>• Функции, предоставляющие <strong>строгую гарантию,</strong> обещают, что если исключение будет возбуждено, то состояние программы не изменится. Вызов такой функции является атомарным; если он завершился успешно, то все запланированные действия выполнены до конца, если же нет, то программа останется в таком состоянии, как будто функция никогда не вызывалась.</p>
<p>Работать с функциями, представляющими такую гарантию, проще, чем с функциями, которые дают только базовую гарантию, потому что после их вызова может быть только два состояния программы: то, которое ожидается в результате ее успешного завершения, и то, которое было до ее вызова. Напротив, если исключение возникает в функции, представляющей только базовую гарантию, то программа может оказаться в <emphasis>любом</emphasis> корректном состоянии.</p>
<p>• Функции, предоставляющие <strong>гарантию отсутствия исключений,</strong> обещают никогда не возбуждать исключений, потому что всегда делают то, что должны делать. Все операции над встроенными типами (например, целыми, указателями и т. п.) обеспечивают такую гарантию. Это основной строительный блок безопасного относительно исключений кода. Разумно предположить, что функции с пустой спецификацией исключений не возбуждают их, но это не всегда так. Например, рассмотрим следующую функцию:</p>
<empty-line/><p><code>int doSomething() throw(); // обратите внимание на пустую</code></p>
<p><code>// спецификацию исключений</code></p>
<empty-line/><p>Это объявление не говорит о том, что doSomething никогда не возбуждает исключений. Утверждается лишь, что <emphasis>если</emphasis> doSomething возбудит исключение, значит, произошла серьезная ошибка и должна быть вызвана функция unexpected<a type="note" l:href="#n_3">[3]</a>. Фактически doSomething может вообще не представлять никаких гарантий относительно исключений. Объявление функции (включающее ее спецификацию исключений) ничего не сообщает относительно того, является ли она корректной, переносима, эффективной, какие гарантии безопасности исключений она предоставляет и предоставляет ли их вообще. Все эти характеристики определяются реализацией функции, а не ее объявлением.</p>
<p>Безопасный относительно исключений код должен представлять одну из трех описанных гарантий. Если он этого не делает, он не является безопасным. Выбор, таким образом, в том, чтобы определить, какой тип гарантии должна представлять каждая из написанных вами функций. Если не считать унаследованный код, небезопасный относительно исключений (об этом мы поговорим далее в настоящем правиле), то отсутствие гарантий допустимо лишь, если в результате анализа требований было решено, что приложение просто обязано допускать утечку ресурсов и работать с поврежденными структурами данных.</p>
<p>Вообще говоря, нужно стремиться предоставить максимально строгие гарантии. С точки зрения безопасности исключений функции, не возбуждающие исключений, чудесны, но очень трудно, не оставаясь в рамках языка C, обойтись без вызова функций, возбуждающих исключения. Любой класс, в котором используется динамическое распределение памяти (например, STL-контейнеры), может возбуждать исключение bad_alloc, когда не удается найти достаточного объема свободной памяти (см. правило 49). Предоставляйте гарантии отсутствия исключений, когда можете, но для большинства функций есть только выбор между базовой и строгой гарантией.</p>
<p>Для функции changeBackground предоставить <emphasis>почти</emphasis> строгую гарантию нетрудно. Во-первых, измените тип данных bgImage в классе PrettyMenu со встроенного указателя *Image на один из «интеллектуальных» управляющих ресурсами указателей, описанных в правиле 13. Откровенно говоря, это в любом случае неплохо, поскольку позволяет избежать утечек ресурсов. Тот факт, что это заодно помогает обеспечить строгую гарантию безопасности исключений, просто подтверждает приведенные в правиле 13 аргументы в пользу применения объектов (наподобие интеллектуальных указателей) для управления ресурсами. Ниже я воспользовался классом tr1::shared_ptr, потому что он ведет себя более естественно при копировании, чем auto_ptr.</p>
<p>Во-вторых, нужно изменить порядок предложений в функции changeBackground так, чтобы значение счетчика imageChanges не увеличивалось до тех пор, пока картинка не будет заменена. Общее правило таково: помечайте в объекте, что произошло некоторое изменение, только после того, как это изменение действительно выполнено.</p>
<p>Вот что получается в результате:</p>
<empty-line/><p><code>class PrettyMenu {</code></p>
<p><code>...</code></p>
<p><code>std::tr1::shared_ptr&lt;Image&gt; bgImage;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>void PrettyMenu::changeBackground(std::istream&amp; imgSrc)</code></p>
<p><code>{</code></p>
<p><code>Lock ml(mutex);</code></p>
<p><code>BgImage.reset(new Image(imgSrc)); // заменить внутренний указатель</code></p>
<p><code>// bgImage результатом выражения</code></p>
<p><code>// “new Image”</code></p>
<p><code>++imageChanges;</code></p>
<p><code>}</code></p>
<empty-line/><p>Отметим, что больше нет необходимости вручную удалять старую картинку, потому что это делает «интеллектуальный» указатель. Более того, удаление происходит только в том случае, если новая картинка успешно создана. Точнее говоря, функция tr1::shared_ptr::reset будет вызвана, только в том случае, когда ее параметр (результат вычисления «new Image(imgSrc)») успешно создан. Оператор delete используется только внутри вызова reset, поэтому если функция не получает управления, то и delete не вызывается. Отметим также, что использование объекта (tr1::shared_ptr) для управления ресурсом (динамически выделенным объектом Image) ко всему прочему уменьшает размер функции changeBackground.</p>
<p>Как я сказал, эти два изменения позволяют changeBackground предоставлять <emphasis>почти</emphasis> строгую гарантию безопасности исключений. Так чего же не хватает? Дело в параметре imgSrc. Если конструктор Image возбудит исключение, может случиться, что указатель чтения из входного потока сместится, и такое смещение может оказаться изменением состояния, видимым остальной части программы. До тех пор пока у функции changeBackground есть этот недостаток, она предоставляет только базовую гарантию безопасности исключений.</p>
<p>Но оставим в стороне этот нюанс и будем считать, что changeBackground представляет строгую гарантию безопасности. (По секрету сообщу, что есть способ добиться этого, изменив тип параметра с istream на имя файла, содержащего данные картинки.) Существует общая стратегия проектирования, которая обеспечивает строгую гарантию, и важно ее знать. Стратегия называется «скопировать и обменять» (copy and swap). В принципе, это очень просто. Сделайте копию объекта, который собираетесь модифицировать, затем внесите все необходимые изменения в копию. Если любая из операций модификации возбудит исключение, исходный объект останется неизменным. Когда все изменения будут успешно внесены, обменяйте модифицированный объект с исходным с помощью операции, не возбуждающей исключений.</p>
<p>Обычно это реализуется помещением всех имеющих отношение к объекту данных из «реального» объекта в отдельный внутренний объект, на который в «реальном» объекте имеется указатель. Часто этот прием называют «идиома pimpl», и в правиле 31 он описывается более подробно. Для класса PrettyMenu это может выглядеть примерно так:</p>
<empty-line/><p><code>struct PMImpl { // PMImpl = “PrettyMenu Impl”:</code></p>
<p><code>std::tr1::shared_ptr&lt;Image&gt; bgImage; // см. далее – почему это</code></p>
<p><code>int imageChanges; // структура, а не класс</code></p>
<p><code>}</code></p>
<p><code>class PrettyMenu {</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>Mutex mutex;</code></p>
<p><code>std::tr1::shared_ptr&lt;PMImpl&gt; pimpl;</code></p>
<p><code>};</code></p>
<p><code>void PrettyMenu::changeBackground(std::istream&amp; imgSrc)</code></p>
<p><code>{</code></p>
<p><code>using std::swap; // см. правило 25</code></p>
<p><code>Lock ml(&amp;mutex); // захватить мьютекс</code></p>
<p><code>std::tr1::shared_ptr&lt;PMImpl&gt; // копировать данные obj</code></p>
<p><code>pNew(new PMImpl(*pimpl));</code></p>
<p><code>pNew-&gt;bgImage.reset(new Image(imgSrc)); // модифицировать копию</code></p>
<p><code>++pNew-&gt;imageChanges;</code></p>
<p><code>swap(pimpl, pNew); // обменять значения</code></p>
<p><code>} // освободить мьютекс</code></p>
<empty-line/><p>В этом примере я решил сделать PMImpl структурой, а не классом, потому что инкапсуляция данных PrettyMenu достигается за счет того, что член pImpl объявлен закрытым. Объявить PMImpl классом было бы ничем не хуже, хотя и менее удобно (зато поборники «объектно-ориентированной чистоты» были бы довольны). Если нужно, PMImpl можно поместить внутрь PrettyMenu, но такое перемещение никак не влияет на написание безопасного относительно исключений кода.</p>
<p>Стратегия копирования и обмена – это отличный способ внести изменения в состояние объекта по принципу «все или ничего», но в общем случае при этом не гарантируется, что вся функция в целом строго безопасна относительно исключений. Чтобы понять почему, абстрагируемся от функции changeBackground и рассмотрим вместо нее некоторую функцию someFunc, которая использует копирование с обменом, но еще и обращается к двум другим функциям: f1 и f2.</p>
<empty-line/><p><code>void someFunc()</code></p>
<p><code>{</code></p>
<p><code>... // скопировать локальное состояние</code></p>
<p><code>f1();</code></p>
<p><code>f2();</code></p>
<p><code>... // обменять модифицированное состояние с копией</code></p>
<p><code>}</code></p>
<empty-line/><p>Должно быть ясно, что если f1 или f2 не обеспечивают строгих гарантий безопасности исключений, то будет трудно обеспечить ее и для someFunc в целом. Например, предположим, что f1 обеспечивает только базовую гарантию. Чтобы someFunc обеспечивала строгую гарантию, необходимо написать код, определяющий состояние всей программы до вызова f1, перехватить все исключения, которые может возбудить f1, а затем восстановить исходное состояние.</p>
<p>Ситуация не становится существенно лучше, если и f1, и f2 обеспечивают строгую гарантию безопасности исключений. Ведь если f1 нормально доработает до конца, состояние программы может измениться произвольным образом, поэтому если f2 возбудит исключение, то состояние программы не будет тем же, как перед вызовом someFunc, даже если f2 не изменит ничего.</p>
<p>Проблема в побочных эффектах. До тех пор пока функция оперирует только локальным состоянием (то есть someFunc влияет только на состояние объекта, для которого вызвана), относительно легко обеспечить строгую гарантию. Но когда функция имеет побочные эффекты, затрагивающие нелокальные данные, все становится сложнее. Если, например, побочным эффектом вызова f1 является модификация базы данных, будет трудно обеспечить строгую гарантию для someFunc. Не существует способа отменить модификацию базы данных, которая уже была совершена: другие клиенты могли уже увидеть новое состояние.</p>
<p>Подобные ситуации могут помешать предоставлению строгой гарантии безопасности для функции, даже если вы хотели бы это сделать. Кроме того, надо принять во внимание эффективность. Смысл «копирования и обмена» в том, чтобы модифицировать копию данных объекта, а затем обменять модифицированные и исходные данные операцией, которая не возбуждает исключений. Для этого нужно сделать копию каждого объекта, который подлежит модификации, что потребует времени и памяти, которыми вы, возможно, не располагаете. Строгая гарантия весьма желательна, и вы должны обеспечивать ее, когда это разумно и практично, но не обязательно во всех случаях.</p>
<p>Когда невозможно предоставить строгую гарантию, вы должны обеспечить базовую. На практике может оказаться так, что для некоторых функций можно обеспечить строгую гарантию, тогда как для многих других это неразумно из соображений эффективности и сложности. Если вы сделали все возможное для обеспечения строгой гарантии там, где это оправдано, никто не вправе критиковать вас за то, что в остальных случаях вы представляете только базовую гарантию. Для многих функций базовая гарантия – совершенно разумный выбор.</p>
<p>Совсем другое дело, если вы пишете функцию, которая вообще не представляет никаких гарантий безопасности исключений. Тут вступает в силу презумпция виновности: подсудимый считается виновным, пока не докажет обратного. Вы <emphasis>должны</emphasis> писать код, безопасный относительно исключений. Однако у вас есть право на защиту. Рассмотрим еще раз реализацию функции someFunc, которая вызывает f1 и f2. Предположим, что f2 не представляет никаких гарантий безопасности исключений, даже базовой. Это значит, что если f2 возбудит исключение, то возможна утечка ресурсов внутри f2. Это также означает, что f2 может повредить структуры данных, например отсортированные массивы могут стать неотсортированными, объект, который копировался из одной структуры в другую, может потеряться и т. д. Функция someFunc ничего не может с этим поделать. Если вызываемые из someFunc функции не гарантируют безопасности относительно исключений, то и someFunc не может предоставить никаких гарантий.</p>
<p>Вот теперь мы можем вернуться к теме беременности. Женщина либо беременна, либо нет. Невозможно быть чуть-чуть беременной. Аналогично программная система является либо безопасной по исключениям, либо нет. Нет такого понятия, как частично безопасная система. Если система имеет всего одну небезопасную относительно исключений функцию, то она небезопасна и в целом, потому что вызов этой функции может привести к утечке ресурсов и повреждению структур данных. К несчастью, большинство унаследованного кода на C++ было написано без учета требований безопасности исключений, поэтому многие системы на сегодня являются в этом отношении небезопасными. Они включают код, написанный в небезопасной манере.</p>
<p>Но нет причин сохранять такое положение дел навсегда. При написании нового кода или модификации существующего тщательно продумывайте способы достижения безопасности исключений. Начните с применения объектов управления ресурсами (см. правило 13). Это предотвратит утечку ресурсов. Затем определите, какую максимальную из трех гарантий безопасности исключений вы можете обеспечить для разрабатываемых функций, оставляя их небезопасными только в том случае, когда вызовы унаследованного кода не оставляют другого выбора. Документируйте ваши решения как для пользователей ваших функций, так и для сопровождения в будущем. Гарантия безопасности исключений функции – это видимая часть ее интерфейса, поэтому вы должны подходить к ней столь же ответственно, как и к другим аспектам интерфейса.</p>
<p>Сорок лет назад код, изобилующий операторами goto, считался вполне приемлемым. Теперь же мы стараемся писать структурированные программы. Двенадцать лет назад глобальные данные ни у кого не вызывали возражений. Теперь мы стремимся данные инкапсулировать. Десять лет назад написание функций без учета влияния исключений было нормой. А сейчас мы боремся за достижение безопасности относительно исключений.</p>
<p>Времена меняются. Мы живем. Мы учимся.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Безопасные относительно исключений функции не допускают утечки ресурсов и повреждения структур данных, даже в случае возбуждения исключений. Такие функции предоставляют базовую гарантию, строгую гарантию либо гарантию полного отсутствия исключений.</p>
<p>• Строгая гарантия часто может быть реализована посредством копирования и обмена, но предоставлять ее для всех функций непрактично.</p>
<p>• Функция обычно может предоставить гарантию не строже, чем самая слабая гарантия, обеспечиваемая вызываемыми из нее функциями.</p>
</section><section><title><p>Правило 30: Тщательно обдумывайте использование встроенных функций</p>
</title><p>Встроенные функции – какая <emphasis>замечательная</emphasis> идея! Они выглядят подобно функциям, они работают подобно функциям, они намного лучше макросов (см. правило 2). Их можно вызывать, не опасаясь накладных расходов, связанных с вызовом обычных функций. Чего еще желать?</p>
<p>В действительности вы получаете больше, чем рассчитывали, потому что возможность избежать затрат на вызов функции – это только полдела. Оптимизация, выполняемая компилятором, обычно наиболее эффективна на участке кода, не содержащем вызовов функций. Таким образом, вы даете компилятору возможность оптимизации тела встроенной функции в зависимости от объемлющего контекста. При использовании «обычного» функционального вызова большинство компиляторов такой оптимизации на обычных не выполняют.</p>
<p>Все же давайте не будем слишком увлекаться. В программировании, как и в реальной жизни, не бывает «бесплатных завтраков», и встроенные функции – не исключение. Идея их использования состоит в замене каждого вызова такой функции ее телом. Не нужно быть доктором математических наук, чтобы заметить, что это увеличит общий размер вашего объектного кода. Слишком частое применение встроенных функций на машинах с ограниченной памятью может привести к созданию программы, которая превосходит доступную память. Даже при наличии виртуальной памяти «разбухание» кода, вызванное применением встроенных функций, может привести к дополнительному обмену с диском, уменьшить коэффициент попадания команд в кэш и, следовательно, снизить производительность программы.</p>
<p>С другой стороны, если тело встроенной функции <emphasis>очень</emphasis> короткое, то сгенерированный для нее код может быть короче кода, сгенерированного для вызова функции. В таком случае встраивание функции может привести к <emphasis>уменьшению</emphasis> объектного кода и повышению коэффициента попаданий в кэш!</p>
<p>Имейте в виду, что директива inline – это <emphasis>совет,</emphasis> а не команда компилятору. Совет может быть сформулирован явно или неявно. Неявный способ заключается в определении встроенной функции внутри определения класса:</p>
<empty-line/><p><code>class Person {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>int age() const { return theAge;} // неявный запрос на встраивание;</code></p>
<p><code>... // функция age определена внутри класса</code></p>
<p><code>private:</code></p>
<p><code>int theAge;</code></p>
<p><code>};</code></p>
<empty-line/><p>Такие функции обычно являются функциями-членами, но в правиле 46 объясняется, что функции-друзья тоже могут быть определены внутри класса. В этом случае они также неявно считаются встроенными.</p>
<p>Явно объявить встроенную функцию можно, предварив ее определение ключевым словом inline. Например, вот как обычно реализован стандартный шаблон max (из заголовочного файла &lt;algorithm&gt;):</p>
<empty-line/><p><code>template &lt;typename T&gt; // явный запрос на</code></p>
<p><code>inline const T&amp; std::max(const T&amp; a, const T&amp; b) // встраивание: функции</code></p>
<p><code>{ return a &lt; b ? b : c;} // std::max предшествует</code></p>
<p><code>// слово inline</code></p>
<empty-line/><p>Тот факт, что max – это шаблон, наводит на мысль, что встроенные функции и шаблоны обычно объявляются в заголовочных файлах. Некоторые программисты делают из этого вывод, что шаблоны функций обязательно должны быть встроенными. Это заключение одновременно неверно и потенциально опасно, поэтому рассмотрим его внимательнее.</p>
<p>Встроенные функции обычно должны находиться в заголовочных файлах, поскольку большинство разработки программ выполняют встраивание во время компиляции. Чтобы заменить вызовы функции встраиванием ее тела, компилятор должен увидеть эту функцию. (Некоторые среды могут встраивать функции во время компоновки, а есть и такие – например, среды разработки на базе. NET Common Language Infrastructure (CLI), – которые осуществляют встраивание во время исполнения. Но это скорее исключение, чем правило. Встраивание функций в большинстве программ на C++ происходит во время компиляции.)</p>
<p>Шаблоны обычно находятся в заголовочных файлах, потому что компилятор должен знать, как шаблон выглядит, чтобы конкретизировать его в момент использования. (Но и это правило не является универсальным. Некоторые среды разработки выполняют конкретизацию шаблонов во время компоновки. Однако конкретизация на этапе компиляции встречается чаще.)</p>
<p>Конкретизация шаблонов никак не связана со встраиванием. Если вы полагаете, что все функции, конкретизированные из вашего шаблона, должны быть встроенными, объявите шаблон встроенным (inline); именно так разработчики стандартной библиотеки поступили с шаблоном std::max (см. пример выше). Но если вы пишете шаблон для функции, которую нет смысла делать встроенной, не объявляйте встроенным и ее шаблон (явно или неявно). Встраивание обходится дорого, и вряд ли вы захотите платить за это без должного размышления. Мы уже упоминали, что встраивание раздувает код (особенно это важно при разработке шаблонов – см. правило 44), но есть и другие затраты, которые мы скоро обсудим.</p>
<p>Но прежде напомним, что встраивание – это совет, который компилятор может проигнорировать. Большинство компиляторов отвергают встраивание функций, которые представляются слишком сложными (например, содержат циклы или рекурсию), и за исключением наиболее тривиальных случаев, вызов виртуальной функции отменяет встраивание. В этом нет ничего удивительного: virtual означает «какую точно функцию вызвать, определяется в момент исполнения», а inline – «перед исполнением заменить вызов функции ее кодом». Если компилятор не знает, какую функцию вызывать, то трудно винить его в том, что он отказывается делать встраивание.</p>
<p>Все это в конечном счете сводится к следующему: от реализации используемого компилятора зависит, встраивается ли в действительность встроенная функция. К счастью, большинство компиляторов обладают достаточными диагностическими возможностями и выдают предупреждение (см. правило 53), если не могут выполнить запрошенное вами встраивание.</p>
<p>Иногда компилятор генерирует тела встроенной функции, даже если ничто не мешает ее встроить. Например, если ваша программа получает адрес встроенной функции, то компилятор, как правило, должен сгенерировать настоящее тело функции. Как иначе он может получить адрес функции, если ее не существует? В совокупности с тем фактом, что обычно компиляторы не выполняют встраивание, если функция вызывается по указателю, это значит, что вызовы встроенных функций могут встраиваться или не встраиваться в зависимости от того, как к ней производится обращение:</p>
<empty-line/><p><code>inline void f() {...} // предположим, что компилятор может встроить вызовы f</code></p>
<p><code>void (*pf)() = f; // pf указывает на f</code></p>
<p><code>...</code></p>
<p><code>f(); // этот вызов будет встроенным, потому что он</code></p>
<p><code>// «нормальный»</code></p>
<p><code>pf(); // этот вызов, вероятно, не будет встроен, потому что</code></p>
<p><code>// функция вызвана по указателю</code></p>
<empty-line/><p>Призрак невстраиваемых inline-функций может преследовать вас, даже если вы никогда не используете указателей на функции, потому что указатели на функции может запрашивать не только программист. Иногда компилятор генерирует невстраиваемые копии конструкторов и деструкторов так, что они запрашивают указатели на функции во время конструирования и разрушения объектов в массивах.</p>
<p>Фактически конструкторы и деструкторы часто являются наихудшими кандидатами для встраивания. Например, рассмотрим конструктор класса Derived:</p>
<empty-line/><p><code>class Base {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>std::string bm1, bm2; // члены базового класса 1 и 2</code></p>
<p><code>};</code></p>
<p><code>class Derived: public Base {</code></p>
<p><code>public:</code></p>
<p><code>Derived(){} // конструктор Derived пуст – не так ли?</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>std::string dm1, dm2, dm3; // члены производного класса 1–3</code></p>
<p><code>};</code></p>
<empty-line/><p>Этот конструктор выглядит как отличный кандидат на встраивание, поскольку он не содержит никакого кода. Но впечатление обманчиво.</p>
<p>C++ дает различные гарантии о том, что должно происходить при конструировании и разрушении объектов. Например, когда вы используете оператор new, динамически создаваемые объекты автоматически инициализируются своими конструкторами, а при обращении к delete вызываются соответствующие деструкторы. Когда вы создаете объект, то автоматически конструируются члены всех его базовых классов, а равно его собственные данные-члены, а во время удаления объекта автоматически происходит обратный процесс. Если во время конструирования объекта возбуждается исключение, то все части объекта, которые были к этому моменту сконструированы, автоматически разрушаются. Во всех этих случаях C++ говорит, <emphasis>что</emphasis> должно случиться, но не говорит – <emphasis>как.</emphasis> Это зависит от реализации компилятора, но должно быть понятно, что такие вещи не происходят сами по себе. В вашей программе должен быть какой-то код, который все это реализует, и этот код, который генерируется компилятором и вставляется в вашу программу, должен где-то находиться. Иногда он помещается в конструкторы и деструкторы, поэтому можем представить себе следующую реализацию сгенерированного кода в якобы пустом конструкторе класса Derived:</p>
<empty-line/><p><code>Derived::Derived() // концептуальная реализация</code></p>
<p><code>{ // «пустого» конструктора класса Derived</code></p>
<p><code>Base::Base(); // инициализировать часть Base</code></p>
<p><code>try {dm1.std::string::string();} // попытка сконструировать dm1</code></p>
<p><code>catch(…) { // если возбуждается исключение,</code></p>
<p><code>Base::~Base(); // разрушить часть базового класса</code></p>
<p><code>throw; // распространить исключение выше</code></p>
<p><code>}</code></p>
<p><code>try {dm2.std::string::string();} // попытка сконструировать dm2</code></p>
<p><code>catch(…){ // если возбуждается исключение,</code></p>
<p><code>dm1.std::string::~string(); // разрушить dm1</code></p>
<p><code>Base::~Base(); // разрушить часть базового класса</code></p>
<p><code>throw; // распространить исключение</code></p>
<p><code>}</code></p>
<p><code>try {dm3.std::string::string();} // сконструировать dm3</code></p>
<p><code>catch(…){ // если возбуждается исключение,</code></p>
<p><code>dm2.std::string::~string(); // разрушить dm2</code></p>
<p><code>dm1.std::string::~string(); // разрушить dm1</code></p>
<p><code>Base::~Base(); // разрушить часть базового класса</code></p>
<p><code>throw; // распространить исключение</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/><p>В действительности это не совсем тот код, который порождает компилятор, потому что реальные компиляторы обрабатывают исключения более сложным образом. И все же этот пример довольно точно отражает поведение «пустого» конструктора класса Derived. Независимо от того, насколько хитроумно обходится с исключениями компилятор, конструктор Derived должен, по крайней мере, вызывать конструкторы своих данных-членов и базового класса, и эти вызовы (которые сами по себе могут быть встроенными) могут свести преимущества встраивания на нет.</p>
<p>То же самое относится и к конструктору класса Base, поэтому если он встроенный, то весь вставленный в него код вставляется также и в конструктор Derived (поскольку конструктор Derived вызывает конструктор Base). И если конструктор класса string тоже окажется встроенным, то в конструктор Derived его код войдет <emphasis>пять</emphasis> раз – по одному для каждой из пяти имеющихся в классе Derived строк (две унаследованные и три, объявленные в нем самом). Наверное, теперь вам ясно, почему решений о встраивании конструктора Derived не стоит принимать с легким сердцем. Аналогично обстоят дела и с деструктором класса Derived, который каким-то образом должен гарантировать правильное уничтожение всех объектов, инициализированных конструктором.</p>
<p>Разработчики библиотек должны принимать во внимание, что произойдет при объявлении функций встроенными, потому что невозможно предоставить двоичное обновление видимых клиенту встроенных библиотечных функций. Другими словами, если f – встроенная библиотечная функция, то пользователи этой библиотеки встраивают ее тело в свои приложения. Если разработчик библиотеки позднее решит изменить f, то все программы, которые ее использовали, придется откомпилировать заново. Часто это нежелательно. С другой стороны, если f не будет встроенной функцией, то после ее модификации клиентские программы нужно будет лишь заново компоновать с библиотекой. Это ощутимо быстрее, чем перекомпиляция, а если библиотека, содержащая функцию, является динамической, то изменения в ней вообще будут прозрачны для пользователей.</p>
<p>При разработке программ важно иметь в виду все эти соображения, но с практической точки зрения наиболее существен следующий факт: у большинства отладчиков возникают проблемы со встроенными функциями. Это совсем не удивительно. Как установить точку остановки в функции, которой не существует? Хотя некоторые среды разработки ухитряются поддерживать отладку встроенных функций, во многих встраивание для отладочных версий просто отключается.</p>
<p>Это приводит нас к следующей стратегии выбора функций, подходящих для встраивания. Поначалу откажитесь от встроенных функций вовсе, или, по крайней мере, ограничьтесь теми, которые обязаны быть встроенными (см. правило 46) либо являются тривиальными (такие как Person::age выше). Применяя встроенные функции с должной аккуратностью, вы не только получаете возможность пользоваться отладчиком, но и определяете встраиванию подобающее место: тонкая оптимизация вручную. Не забывайте об эмпирическом правиле «80–20», которое утверждает, что типичная программа тратит 80 % времени на исполнение 20 % кода. Это важное правило, поскольку оно напоминает, что цель разработчика программного обеспечения – идентифицировать те 20 % кода, которые действительно способны повысить производительность программы. Можно до бесконечности оптимизировать и объявлять функции inline, но все это будет пустой тратой времени, если только вы не сосредоточите усилия на <emphasis>нужных</emphasis> функциях.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Делайте встраиваемыми только небольшие, часто вызываемые функции. Это облегчит отладку, даст возможность выполнять обновления библиотек на двоичном уровне, уменьшит эффект «разбухания» кода и поможет повысить быстродействие программы.</p>
<p>• Не объявляйте шаблоны функций встроенными только потому, что они появляются в заголовочных файлах.</p>
</section><section><title><p>Правило 31: Уменьшайте зависимости файлов при компиляции</p>
</title><p>Рассмотрим самую обыкновенную ситуацию. Вы открываете свою программу на C++ и вносите незначительные изменения в реализацию класса. Заметьте, не в интерфейс класса, а просто в реализацию – только в закрытые члены. После этого вы начинаете заново собирать программу, рассчитывая, что это займет лишь несколько секунд. В конце концов, ведь вы модифицировали всего один класс. Вы щелкаете по кнопке Build или набираете make (либо какой-то эквивалент), и… удивлены, а затем – подавлены, когда обнаруживаете, что перекомпилируется и заново компонуется весь <emphasis>мир!</emphasis> Не правда ли, вам это скоро надоест?</p>
<p>Проблема связана с тем, что C++ не проводит сколько-нибудь значительного различия между интерфейсом и реализацией. В частности, определения классов включают в себя не только спецификацию интерфейса, но также и целый ряд деталей реализации. Например:</p>
<empty-line/><p><code>class Person {</code></p>
<p><code>public:</code></p>
<p><code>Person(const std::string&amp; name, const Date&amp; birthday,</code></p>
<p><code>const Address&amp; addr);</code></p>
<p><code>std::string name() const;</code></p>
<p><code>std::string birthDate() const;</code></p>
<p><code>std::string address() const;</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>std::string theName; // деталь реализации</code></p>
<p><code>Date theBirthDate; // деталь реализации</code></p>
<p><code>Address theAddress; // деталь реализации</code></p>
<p><code>};</code></p>
<empty-line/><p>Класс Person нельзя скомпилировать, не имея доступа к определению классов, с помощью которых он реализуется, а именно string, Date и Address. Такие определения обычно предоставляются посредством директивы #include, поэтому весьма вероятно, что в начале файла, определяющего класс Person, вы найдете нечто вроде:</p>
<empty-line/><p><code>#include &lt;string&gt;</code></p>
<p><code>#include “date.h”</code></p>
<p><code>#include “address.h”</code></p>
<empty-line/><p>К сожалению, это устанавливает зависимости времени компиляции между файлом определения Person и включаемыми файлами. Если изменится любой из этих файлов либо любой из файлов, от которых <emphasis>они</emphasis> зависят, то должен быть перекомпилирован файл, содержащий определение Person, а равно и все файлы, которые класс Person используют. Такие каскадные зависимости могут быть весьма обременительны для пользователей.</p>
<p>Можно задаться вопросом, почему C++ настаивает на размещении деталей реализации класса в определении класса. Например, почему нельзя определить Person следующим образом:</p>
<empty-line/><p><code>namespace std {</code></p>
<p><code>class string; // опережающее объявление</code></p>
<p><code>} // (некорректно – см. далее)</code></p>
<p><code>class Date; // опережающее объявление</code></p>
<p><code>class Address; // опережающее объявление</code></p>
<p><code>class Person {</code></p>
<p><code>public:</code></p>
<p><code>Person(const std::string&amp; name, const Date&amp; birthday,</code></p>
<p><code>const Address&amp; addr);</code></p>
<p><code>std::string name() const;</code></p>
<p><code>std::string birthDate() const;</code></p>
<p><code>std::string address() const;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Если бы такое было возможно, то пользователи класса Person должны были перекомпилировать свои программы только при изменении его интерфейса.</p>
<p>Увы, при реализации этой идеи мы наталкиваемся на две проблемы. Первая: string – это не класс, а typedef (синоним шаблона basic_string&lt;char&gt;). Поэтому опережающее объявление string некорректно. Правильное объявление гораздо сложнее, так как в нем участвуют дополнительные шаблоны. Впрочем, это не важно, потому что вы в любом случае не должны вручную объявлять какие-либо части стандартной библиотеки. Вместо этого просто включите с помощью #include правильные заголовки и успокойтесь. Стандартные заголовки вряд ли станут узким местом при компиляции, особенно если ваша среда разработки поддерживает предкомпилированные заголовочные файлы. Если на компиляцию стандартных заголовков все же уходит много времени, то может понадобиться изменить дизайн и избежать использования тех частей стандартной библиотеки, которые включать нежелательно.</p>
<p>Вторая (и более существенная) неприятность, связанная с опережающим объявлением, состоит в том, что компилятору необходимо знать размер объектов во время компиляции. Рассмотрим пример:</p>
<empty-line/><p><code>int main()</code></p>
<p><code>{</code></p>
<p><code>int x; // определяем int</code></p>
<p><code>Person p(<emphasis>params</emphasis>); // определяем Person</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>Когда компилятор видит определение x, он понимает, что должен выделить достаточно места (обычно в стеке) для размещения int. Нет проблем: каждый компилятор знает, какова длина int. Встречая определение p, компилятор учитывает, что нужно выделить место для Person, но откуда ему знать, сколько именно места потребуется? Единственный способ получить эту информацию – справиться в определении класса, но если бы в определениях классов можно было опускать детали реализации, как компилятор выяснил бы, сколько памяти необходимо выделить?</p>
<p>Такой вопрос не возникает в языках типа SmallTalk или Java, потому что при определении объекта компиляторы выделяют только память, достаточную для хранения <emphasis>указателя</emphasis> на этот объект. Иначе говоря, эти языки интерпретируют вышеприведенный код, как если бы он был написан следующим образом:</p>
<empty-line/><p><code>int main()</code></p>
<p><code>{</code></p>
<p><code>int x; // определяем int</code></p>
<p><code>Person *p; // определяем указатель на Person</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>Это вполне законная конструкция на C++, поэтому вы и сами сможете имитировать «сокрытие реализации объекта за указателем». В случае класса Person это можно сделать, например, разделив его на два класса: один – для представления интерфейса, а другой – для его реализации. Если класс, содержащий реализацию, назвать Personlmpl, то Person должен быть написан следующим образом:</p>
<empty-line/><p><code>#include &lt;string&gt; // компоненты стандартной библиотеки</code></p>
<p><code>// не могут быть объявлены предварительно</code></p>
<p><code>#include &lt;memory&gt; // для tr1::shared_ptr; см. далее</code></p>
<p><code>class PersonImpl; // опережающее объявление PersonImpl</code></p>
<p><code>class Date; // опережающее объявление классов,</code></p>
<p><code>class Address; // используемых в интерфейсе Person</code></p>
<p><code>class Person {</code></p>
<p><code>public:</code></p>
<p><code>Person(const std::string&amp; name, const Date&amp; birthday,</code></p>
<p><code>const Address&amp; addr);</code></p>
<p><code>std::string name() const;</code></p>
<p><code>std::string birthDate() const;</code></p>
<p><code>std::string address() const;</code></p>
<p><code>...</code></p>
<p><code>private: // указатель на реализацию:</code></p>
<p><code>std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl; // см. в правиле 13 информацию</code></p>
<p><code>}; // о std::tr1::shared_ptr</code></p>
<empty-line/><p>Здесь главный класс (Person) не содержит никаких данных-членов, кроме указателя (в данном случае tr1::shared_ptr – см. правило 13) на свой класс реализации (Personlmpl). Такой дизайн часто называют «идиомой pimpl» («pointer to implementation» – указатель на реализацию). В подобных классах указатели часто называют pImpl, как в приведенном примере.</p>
<p>При таком дизайне пользователи класса Person не видят никаких деталей – дат, адресов и имен. Реализация может быть модифицирована как угодно, при этом перекомпилировать программы, в которых используется Person, не придется. Кроме того, поскольку пользователи не знают деталей реализации Person, они вряд ли напишут код, который каким-то образом будет зависеть от этих деталей. Вот это я и называю отделением интерфейса от реализации.</p>
<p>Ключом к этому разделению служит замена зависимости от <emphasis>определения</emphasis> (definition) на зависимость от <emphasis>объявления</emphasis> (declaration). Это и есть сущность минимизации зависимостей на этапе компиляции: когда это целесообразно, делайте заголовочные файлы самодостаточными; в противном случае используйте зависимость от объявлений, а не от определений. Все остальное вытекает из только что изложенной стратегии проектирования. Сформулируем три практических следствия:</p>
<p>• <strong>Избегайте использования объектов, если есть шанс обойтись ссылками или указателями.</strong> Вы можете определить ссылки и указатели, имея только <emphasis>объявление</emphasis> типа. Определение <emphasis>объектов</emphasis> требует наличия <emphasis>определения</emphasis> типа.</p>
<p>• <strong>По возможности используйте зависимость от объявления, а не от определения класса.</strong> Отметим, что для объявления функции, использующей некоторый класс, <emphasis>никогда</emphasis> не требуется определение этого класса, даже если функция принимает или возвращает объект класса по значению:</p>
<empty-line/><p><code>class Date; // объявление класса</code></p>
<p><code>Date today(); // правильно, необходимость</code></p>
<p><code>void clearAppointments(Date d); // в определении Date отсутствует</code></p>
<empty-line/><p>Конечно, передача по значению – не очень хорошая идея (см. правило 20), но если по той или иной причине вы будете вынуждены ею воспользоваться, это никак не оправдает введения ненужных зависимостей. Не исключено, что возможность объявить функции today и clearAppoinments без определения Date повергла вас в удивление, но на самом деле это не так уж странно. Определение Date должно быть доступно в момент вызова этих функций. Да, я знаю, о чем вы думаете: зачем объявлять функции, которых никто не вызывает? Ответ прост. Дело не в том, что <emphasis>никто</emphasis> не вызывает их, а в том, что их вызывают <emphasis>не все.</emphasis> Например, если имеется библиотека, содержащая десятки объявлений функций, то маловероятно, что каждый пользователь вызывает каждую функцию. Перенося бремя ответственности за предоставление определений класса с ваших заголовочных файлов, содержащих <emphasis>объявления</emphasis> функций, на пользовательские файлы, содержащие их вызовы, вы исключаете искусственную зависимость пользователя от определений типов, которые им в действительности не нужны.</p>
<p>• <strong>Размещайте объявления и определения в разных заголовочных файлах. </strong>Чтобы было проще придерживаться описанных выше принципов, файлы заголовков должны поставляться парами: один – для объявлений, второй – для определений. Конечно, нужно, чтобы эти файлы были согласованы. Если объявление изменяется в одном месте, то нужно изменить его и во втором. В результате пользователи библиотеки всегда должны включать файл объявлений, а не писать самостоятельно опережающие объявления, тогда как авторы библиотек должны поставлять оба заголовочных файла.</p>
<p>Например, если пользователь класса Date захочет объявить функции today и clearAppointments, ему не следует вручную включать опережающее объявление класса Date, как было показано выше. Вместо этого он должен включить директивой #include соответствующий файл с объявлениями:</p>
<empty-line/><p><code>#include “datefwd.h” // заголочный файл, в котором объявлен</code></p>
<p><code>// (но не определен) класс Date</code></p>
<p><code>Date today(); // как раньше</code></p>
<p><code>void clearAppointments(Date d);</code></p>
<empty-line/><p>Файл с объявлениями назван «datefwd.h» по аналогии с заголовочным файлом &lt;iosfwd&gt; из стандартной библиотеки C++ (см. правило 54). &lt;iosfwd&gt; содержит объявления компонентов iostream, определения которых находятся в нескольких разных заголовках, включая &lt;sstream&gt;, &lt;streambuf&gt;, &lt;fstream&gt; и &lt;iostream&gt;.</p>
<p>Пример &lt;iosfwd&gt; поучителен еще и по другой причине. Из него следует, что совет этого правила относится в равной мере к шаблонным и обычным классам. Хотя в правиле 30 объяснено, что во многих средах разработки программ определения шаблонов обычно находятся в заголовочных файлах, но в некоторых продуктах допускается размещение определений шаблонов и в других местах, поэтому все же имеет смысл предоставить заголовочные файлы, содержащие только объявления, и для шаблонов. &lt;iosfwd&gt; – как раз пример такого файла.</p>
<p>В C++ есть также ключевое слово export, позволяющее отделить объявления шаблонов от их определений. К сожалению, поддержка компиляторами этой возможности ограничена, а практический опыт его применения совсем невелик. Сейчас еще слишком рано говорить, какую роль будет играть слово export в эффективном программировании на C++. Классы, подобные Person, в которых используется идиома pimpl, часто называют <emphasis>классами-дескрипторами</emphasis> (handle classes). Ответ на вопрос, каким образом работают такие классы, прост: они переадресовывают все вызовы функций соответствующим классам реализаций, которые и выполняют всю реальную работу. Например, вот как могут быть реализованы две функции-члена Person:</p>
<empty-line/><p><code>#include “Person.h” // поскольку мы реализуем класс Person,</code></p>
<p><code>// то должны включить его определение</code></p>
<p><code>#include “PersonImpl.h” // мы должны также включить определение класса</code></p>
<p><code>// PersonImpl, иначе не сможем вызывать его</code></p>
<p><code>// функции-члены; отметим, что PersonImpl имеет</code></p>
<p><code>// в точности те же функции-члены, что и</code></p>
<p><code>// Person: их интерфейсы идентичны</code></p>
<p><code>Person::Person(const std::string&amp; name, const Date&amp; birthday,</code></p>
<p><code>const Address&amp; addr)</code></p>
<p><code>: pImpl(new Person(name, birthday, addr))</code></p>
<p><code>{}</code></p>
<p><code>std::string Person::name() const</code></p>
<p><code>{</code></p>
<p><code>return pImpl-&gt;name();</code></p>
<p><code>}</code></p>
<empty-line/><p>Обратите внимание на то, как конструктор Person вызывает конструктор Personlmpl (используя new – см. правило 16), и как Person::name вызывает PersonImpl::name. Это важный момент. Превращение Person в класс-дескриптор не меняет его поведения – изменяется только место, в котором это поведение реализовано.</p>
<p>Альтернативой подходу с использованием класса-дескриптора – сделать Person абстрактным базовым классом специального вида, называемым <emphasis>интерфейсным классом.</emphasis> Его назначение – специфицировать интерфейс для производных классов (см. правило 34). В результате он обычно не содержит ни данных-членов, ни конструкторов, но имеет виртуальный деструктор (см. правило 7) и набор чисто виртуальных функций, определяющих интерфейс.</p>
<p>Интерфейсные классы сродни интерфейсам Java и. NET, но C++ не накладывают на интерфейсные классы тех ограничений, которые присущи этим языкам. Например, ни Java, ни. NET не допускают в интерфейсах наличия членов-данных и реализаций функций-членов. C++ этого не запрещает. Большая гибкость C++ в этом отношении может оказаться кстати. Как объясняется в правиле 36, реализация невиртуальных функций должна быть одинаковой для всех классов в иерархии, поэтому имеет смысл реализовать такие функции, как часть интерфейсного класса, в котором они объявлены.</p>
<p>Интерфейсный класс Person может выглядеть примерно так:</p>
<empty-line/><p><code>class Person {</code></p>
<p><code>public:</code></p>
<p><code>virtual ~Person();</code></p>
<p><code>virtual std::string name() const = 0;</code></p>
<p><code>virtual std::string birthDate() const = 0;</code></p>
<p><code>virtual std::string address() const = 0;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Пользователи этого класса должны программировать в терминах указателей и ссылок на Person, потому что невозможно создать экземпляр класса, содержащего чисто виртуальные функции (однако можно создавать экземпляры классов, производных от Person – см. далее). Пользователям интерфейсных классов, как и пользователям классов-дескрипторов, нет нужды проводить перекомпиляцию до тех пор, пока не изменяется интерфейс.</p>
<p>Конечно, пользователи интерфейсных классов должны иметь способ создавать новые объекты. Обычно они делают это, вызывая функцию, играющую роль конструктора для производных классов, экземпляры которых необходимо создать. Такие функции часто называют функциями-фабриками (см. правило 13), или <emphasis>виртуальными конструкторами.</emphasis> Они возвращают указатели (и лучше бы интеллектуальные, см. правило 18) на динамически распределенные объекты, которые поддерживают интерфейс интерфейсного класса. Нередко подобные функции объявляют как статические внутри интерфейсного класса:</p>
<empty-line/><p><code>class Person {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>static std::tr1::shared_ptr&lt;Person&gt; // возвращает tr1::shared_ptr</code></p>
<p><code>create(const std::string&amp; name, // на новый экземпляр Person,</code></p>
<p><code>const Date&amp; birthday, // инициализированный заданными</code></p>
<p><code>const Address&amp; addr); // параметрами: см. в правиле 18,</code></p>
<p><code>... // почему возвращается</code></p>
<p><code>}; // tr1::shared_ptr</code></p>
<empty-line/><p>а используют так:</p>
<empty-line/><p><code>std::string name;</code></p>
<p><code>Date datefBirth;</code></p>
<p><code>Address address;</code></p>
<p><code>...</code></p>
<p><code>// создать объект, поддерживающий интерфейс Person</code></p>
<p><code>std::tr1::shared_ptr&lt;Person&gt; pp(Person::create(name, dateOfBrth, address));</code></p>
<p><code>...</code></p>
<p><code>std::cout &lt;&lt; pp-&gt;name() // использовать объект через</code></p>
<p><code>&lt;&lt; “ родился ” // интерфейс Person</code></p>
<p><code>&lt;&lt; pp-&gt;birthDate()</code></p>
<p><code>&lt;&lt; “ и теперь живет по адресу ”</code></p>
<p><code>&lt;&lt; pp-&gt;address();</code></p>
<p><code>... // объект автоматически</code></p>
<p><code>// удаляется, когда pp выходит</code></p>
<p><code>// из контекста – см. правило 13</code></p>
<empty-line/><p>Разумеется, где-то должны быть определены конкретные классы, поддерживающие интерфейс такого интерфейсного класса, и вызваны реальные конструкторы. Все это происходит «за кулисами», внутри файлов, содержащих реализацию виртуальных конструкторов. Например, интерфейсный класс Person может иметь конкретный производный класс RealPerson, предоставляющий реализацию унаследованных виртуальных функций:</p>
<empty-line/><p><code>class RealPerson public Person {</code></p>
<p><code>public:</code></p>
<p><code>RealPerson(const std::string&amp; name, const Date&amp; birthday,</code></p>
<p><code>const Address&amp; addr)</code></p>
<p><code>: theName(name), theBirthDate(birthday), theAddress(addr)</code></p>
<p><code>{}</code></p>
<p><code>virtual ~RealPerson() {}</code></p>
<p><code>std::string name() const; // реализация этих функций</code></p>
<p><code>std::string birthDate() const; // не показана, но ее</code></p>
<p><code>std::string address() const; // легко представить</code></p>
<p><code>private:</code></p>
<p><code>std::string theName;</code></p>
<p><code>Date theBirthDaye;</code></p>
<p><code>Address theAddress;</code></p>
<p><code>};</code></p>
<empty-line/><p>Имея класс RealPerson, очень легко написать Person::create:</p>
<empty-line/><p><code>std::tr1::shared_ptr&lt;Person&gt; create( const std::string&amp; name,</code></p>
<p><code>const Date&amp; birthday,</code></p>
<p><code>const Address&amp; addr)</code></p>
<p><code>{</code></p>
<p><code>return std::tr1::shared_ptr&lt;Person&gt;(new RealPerson(name, birthday, addr));</code></p>
<p><code>}</code></p>
<empty-line/><p>Более реалистическая реализация Person::create должна создавать разные типы объектов классов-наследников, в зависимости, например, от дополнительных параметров функции, данных, прочитанных из файла или базы данных, переменных окружения и т. п.</p>
<p>RealPerson демонстрирует один из двух наиболее распространенных механизмов реализации интерфейсных классов: он наследует спецификации своего интерфейса от интерфейсного класса Person, а затем реализует функции этого интерфейса. Второй способ реализации интерфейсного класса предполагает использование множественного наследования (см. правило 40).</p>
<p>Итак, классы-дескрипторы и интерфейсные классы отделяют интерфейс от реализации, уменьшая тем самым зависимости между файлами на этапе компиляции. Теперь, я уверен, вы ждете примечания мелким шрифтом: «Во сколько обойдется этот хитрый фокус?» Цена вполне обычная в мире программирования: некоторое уменьшение скорости выполнения программы плюс дополнительный расход памяти на каждый объект.</p>
<p>Применительно к классам-дескрипторам функции-члены должны использовать указатель на реализацию (pImpl), чтобы добраться до данных самого объекта. Для каждого обращения это добавляет один уровень косвенной адресации. Кроме того, к объему памяти, необходимому для хранения каждого объекта, нужно добавить размер указателя. И наконец, указатель на реализацию должен быть инициализирован (в конструкторе класса-дескриптора), чтобы он указывал на динамически распределенный объект реализации; следовательно, вы навлекаете на себя еще и накладные расходы, сопровождающие динамическое выделение памяти и последующее ее освобождение, а также возможность возникновения исключений bad_alloc (из-за недостатка памяти).</p>
<p>Для интерфейсных классов каждый вызов функции будет виртуальным, поэтому всякий раз вы платите за косвенный переход (см. правило 7). Кроме того, классы, производные от интерфейсного класса, должны содержать указатель на таблицу виртуальных функций (и снова см. правило 7). Этот указатель может увеличить объем памяти, необходимый для хранения объекта, в зависимости от того, является ли интерфейсный класс единственным источником виртуальных функций для объекта.</p>
<p>И наконец, ни классы-дескрипторы, ни интерфейсные классы не могут извлечь выгоду из использования встроенных функций. В правиле 30 объяснено, почему тела потенциально встраиваемых функций должны быть в заголовочных файлах, но классы-дескрипторы и интерфейсные классы специально предназначены для того, чтобы скрыть такие детали реализации, как тело функций.</p>
<p>Однако было бы серьезной ошибкой отказываться от классов-дескрипторов и интерфейсных классов только потому, что их использование связано с дополнительными расходами. То же самое можно сказать и о виртуальных функциях, но вы ведь не отказываетесь от их применения. (В противном случае вы читаете не ту книгу.) Рассмотрите возможность использования предлагаемых приемов по мере эволюции ваших программ. Применяйте классы-дескрипторы и интерфейсные классы в процессе разработки, чтобы уменьшить влияние изменений в реализации на пользователей. Если вы можете показать, что различие в скорости и/или размере программы настолько существенно, что во имя повышения эффективности оно оправдывает увеличение зависимости между классами, то на конечной стадии реализации заменяйте их конкретными классами.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Основная идея уменьшения зависимостей на этапе компиляции состоит в том, чтобы заменить зависимость от определения зависимостью от объявления. Эта идея лежит в основе двух подходов: классов-дескрипторов и интерфейсных классов.</p>
<p>• Заголовочные файлы библиотек должны существовать в обеих формах: полной и содержащей только объявления. Это справедливо независимо от того, включают они шаблоны или нет.</p>
</section></section><section><title><p>Глава 6</p>
<p>Наследование и объектно-ориентированное проектирование</p>
</title><section><p>Объектно-ориентированное программирование (ООП) существует почти 20 лет, поэтому, вероятно, вы имеете некоторое представление о наследовании, производных классах и виртуальных функциях. Даже если вы программировали только на C, ничего не слышать об ООП вы просто не могли.</p>
<p>И все же ООП в C++, скорее всего, несколько отличается от того, к чему вы привыкли. Наследование может быть одиночным и множественным, а отдельный путь наследования может быть открытым (public), защищенным (protected) или закрытым (private). Путь также может быть виртуальным или невиртуальным. Для функций-членов тоже есть варианты. Виртуальные? Невиртуальные? Чисто виртуальные? Добавьте сюда взаимодействие с другими средствами языка. Как соотносятся параметры по умолчанию с виртуальными функциями? Как влияет наследование на правила разрешения имен в C++? И что можно сказать по поводу методов проектирования? Если поведение класса должно быть модифицируемым, являются ли виртуальные функции лучшим способом достижения этого?</p>
<p>Обо всем этом пойдет речь в настоящей главе. Я объясню, что на самом деле стоит за теми или иными возможностями C++: какую мысль вы <emphasis>выражаете,</emphasis> когда используете некоторую конструкцию. Например, открытое наследование моделирует отношение «является», и если вы попытаетесь придать ему какую-то иную семантику, то столкнетесь с проблемой. Аналогично, виртуальная функция означает «должен быть унаследован интерфейс», в то время как невиртуальная функция означает «должны наследоваться и интерфейс, и реализация». Если не делать различий между этими смыслами, то неприятностей не миновать.</p>
<p>Когда вы поймете истинное назначение различных средств C++, то обнаружите, что ваш взгляд на ООП изменился. Вместо простого упражнения в нахождении отличий между языками это станет средством выражения того, что вы хотите сказать о своей программной системе. А поняв, что же вы в действительности имеете в виду, уже не составит большого труда перевести свои мысли этого на C++.</p>
</section><section><title><p>Правило 32: Используйте открытое наследование для моделирования отношения «является»</p>
</title><p>Вильям Демент (William Dement) в своей книге «Кто-то должен бодрствовать, пока остальные спят» (W. H. Freeman and Company, 1974) рассказывает о том, как он пытался донести до студентов наиболее важные идеи своего курса. Утверждается, говорил он своей группе, что средний британский школьник помнит из уроков истории лишь то, что битва при Хастингсе произошла в 1066 году. Даже если ученик почти ничего не запомнил из курса истории, подчеркивает Демент, 1066 год остается в его памяти. Демент пытался внушить слушателям несколько основных идей, в частности ту любопытную истину, что снотворное вызывает бессонницу. Он призывал своих студентов запомнить ряд ключевых фактов, даже если забудется все, что обсуждалось на протяжении курса, и в течение семестра возвращался к нескольким фундаментальным заповедям.</p>
<p>Последним на заключительном экзамене был вопрос: «Напишите, какой факт из тех, что обсуждались на лекциях, вы запомните на всю жизнь». Проверяя работы, Демент был ошеломлен. Почти все упомянули 1066 год.</p>
<p>Теперь я с трепетом хочу провозгласить, что самое важное правило в объектно-ориентированном программировании на C++ звучит так: открытое наследование означает «является». Твердо запомните это.</p>
<p>Если вы пишете класс D (derived – «производный») открыто наследует классу B («base» – «базовый»), то тем самым сообщаете компилятору C++ (а заодно и людям, читающим ваш код), что каждый объект типа D является также объектом типа B, но <emphasis>не наоборот.</emphasis> Вы говорите, что B представляет собой более общую концепцию, чем D, а D – более конкретную концепцию, чем B. Вы утверждаете, что везде, где может быть использован объект B, можно использовать также объект D, потому что D является объектом типа B. С другой стороны, если вам нужен объект типа D, то объект B не подойдет, поскольку каждый D «является разновидностью» B, но не наоборот.</p>
<p>Такой интерпретации открытого наследования придерживается C++. Рассмотрим следующий пример:</p>
<empty-line/><p><code>class Person {...};</code></p>
<p><code>class Student: public Person {...};</code></p>
<empty-line/><p>Здравый смысл и опыт подсказывают нам, что каждый студент – человек, но не каждый человек – студент. Именно такую связь подразумевает данная иерархия. Мы ожидаем, что всякое утверждение, справедливое для человека – например, что у него есть дата рождения, – справедливо и для студента, но не все, что верно для студента – например, что он учится в каком-то определенном институте, – верно для человека в общем случае.</p>
<p>Применительно к C++ это выглядит следующим образом: любая функция, которая принимает аргумент типа Person (или указатель на Person, или ссылку на Person), примет объект типа Student (или указатель на Student, или ссылку на Student):</p>
<empty-line/><p><code>void eat(const Person&amp; p); // все люди могут есть</code></p>
<p><code>void study(const Student&amp; s); // только студент учится</code></p>
<p><code>Person p; // p – человек</code></p>
<p><code>Student s; // s – студент</code></p>
<p><code>eat(p); // правильно, p есть человек</code></p>
<p><code>eat(s); // правильно, s – это студент,</code></p>
<p><code>// и студент также является человеком</code></p>
<p><code>study(s); // правильно</code></p>
<p><code>study(p); // ошибка! p – не студент</code></p>
<empty-line/><p>Все сказанное верно только для <emphasis>открытого</emphasis> наследования. C++ будет вести себя так, как описано выше, только в случае, если Student открыто наследует Person. Закрытое наследование означает нечто совсем иное (см. правило 39), а смысл защищенного наследования ускользает от меня по сей день.</p>
<p>Идея тождества открытого наследования и понятия «является» кажется достаточно очевидной, но иногда интуиция нас подводит. Рассмотрим следующий пример: пингвин – это птица, птицы умеют летать. Если вы по наивности попытаетесь выразить это на C++, то вот что получится:</p>
<empty-line/><p><code>class Bird {</code></p>
<p><code>public:</code></p>
<p><code>virtual void fly(); // птицы умеют летать</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class Penguin: public Bird { // пингвины – птицы</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Неожиданно мы столкнулись с затруднением. Утверждается, что пингвины могут летать, что, как известно, неверно. В чем тут дело?</p>
<p>В данном случае нас подвела неточность разговорного языка. Когда мы говорим, что птицы умеют летать, то не имеем в виду, что <emphasis>все</emphasis> птицы летают, а только то, что обычно они обладают такой способностью. Если бы мы выбирали формулировки поточнее, то вспомнили бы, что существует несколько видов нелетающих птиц, и пришли к следующей иерархии, которая значительно лучше моделирует реальность:</p>
<empty-line/><p><code>class Bird {</code></p>
<p><code>... // функция fly не объявлена</code></p>
<p><code>};</code></p>
<p><code>class FlyingBird: public Bird {</code></p>
<p><code>public:</code></p>
<p><code>virtual void fly();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class Penguin: public Bird {</code></p>
<p><code>... // функция fly не объявлена</code></p>
<p><code>};</code></p>
<empty-line/><p>Данная иерархия гораздо точнее отражает реальность, чем первоначальная.</p>
<p>Но и теперь еще не все закончено с «птичьими делами», потому что для некоторых приложений может и не быть необходимости делать различие между летающими и нелетающими птицами. Так, если ваше приложение в основном имеет дело с клювами и крыльями и никак не отражает способность пернатых летать, вполне сойдет и исходная иерархия. Это наблюдение, сообственно, является лишь подтверждением того, что не существует идеального проекта, который подходил бы для всех видов программных систем. Выбор проекта зависит от того, что система должна делать – как сейчас, так и в будущем. Если ваше приложение никак не связано с полетами и не предполагается, что оно будет связано с ними в дальнейшем, то вполне можно не принимать во внимание различий между летающими и нелетающими птицами. На самом деле даже лучше не проводить таких различий, потому что его нет в мире, который вы пытаетесь моделировать. Существует другая школа, иначе относящаяся к рассматриваемой проблеме. Она предлагает переопределить для пингвинов функцию fly() так, чтобы во время исполнения она возвращала ошибку:</p>
<empty-line/><p><code>void error(const std::string&amp; msg); // определено в другом месте</code></p>
<p><code>class Penguin: public Bird {</code></p>
<p><code>public:</code></p>
<p><code>virtual void fly() {error(“Попытка заставить пингвина летать!”);}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Важно понимать, что это здесь имеется в виду не совсем то, что вам могло показаться. Мы не говорим: «Пингвины не могут летать», а лишь сообщаем: «Пингвины могут летать, но с их стороны было бы ошибкой это делать».</p>
<p>В чем разница? Во времени обнаружения ошибки. Утверждение «пингвины не могут летать» может быть поддержано на уровне компилятора, а соответствие утверждения «попытка полета ошибочна для пингвинов» реальному положению дел может быть обнаружено во время выполнения программы.</p>
<p>Чтобы обозначить ограничение «пингвины не могут летать – и точка», следует убедиться, что для объектов Penguin функция fly() не определена:</p>
<empty-line/><p><code>class Bird {</code></p>
<p><code>... // функция fly не объявлена</code></p>
<p><code>};</code></p>
<p><code>class Penguin: public Bird {</code></p>
<p><code>... // функция fly не объявлена</code></p>
<p><code>};</code></p>
<empty-line/><p>Если теперь вы попробуете заставить пингвина взлететь, компилятор сделает вам выговор за нарушение правил:</p>
<empty-line/><p><code>Penguin p;</code></p>
<p><code>p.fly(); // ошибка!</code></p>
<empty-line/><p>Это сильно отличается от поведения, которое получается, если применить подход, генерирующий ошибку времени исполнения. Ведь в таком случае компилятор ничего не может сказать о вызове p.fly(). В правиле 18 объясняется, что хороший интерфейс предотвращает компиляцию неверного кода, поэтому лучше выбрать проект, который отвергает попытки пингвинов полетать во время компиляции, а не во время исполнения.</p>
<p>Возможно, вы решите, что вам недостает интуиции орнитолога, но вполне можете положиться на свои познания в элементарной геометрии, не так ли? Тогда ответьте на следующий простой вопрос: должен ли класс Square (квадрат) открыто наследовать классу Rectangle (прямоугольник)?</p>
<image l:href="#i_002.png"/><p>«Конечно! – скажете вы. – Каждый знает, что квадрат – это прямоугольник, а обратное утверждение в общем случае неверно». Что ж, правильно, по крайней мере, для школы. Но мы ведь решаем задачи посложнее школьных.</p>
<empty-line/><p><code>class Rectangle {</code></p>
<p><code>public:</code></p>
<p><code>virtual void setHeight(int newHeight);</code></p>
<p><code>virtual void setWidth(int newWidth);</code></p>
<p><code>virtual int height() const; // возвращают текущие значения</code></p>
<p><code>virtual int width() const;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>void makeBigger(Rectangle&amp; r) // функция увеличивает площадь r</code></p>
<p><code>{</code></p>
<p><code>int oldHeight = r.height();</code></p>
<p><code>r.setWidth(r.width() + 10); // увеличить ширину r на 10</code></p>
<p><code>assert(r.height() == oldHeight); // убедиться, что высота r</code></p>
<p><code>} // не изменилась</code></p>
<empty-line/><p>Ясно, что утверждение assert никогда не должно нарушаться. Функция make-Bigger изменяет только ширину r. Высота остается постоянной.</p>
<p>Теперь рассмотрим код, который посредством открытого наследования позволяет рассматривать квадрат как частный случай прямоугольника:</p>
<empty-line/><p><code>class Square: public Rectangle {…};</code></p>
<p><code>Square s;</code></p>
<p><code>...</code></p>
<p><code>assert(s.width() == s.height()); // должно быть справедливо для</code></p>
<p><code>// всех квадратов</code></p>
<p><code>makeBigger(s); // из-за наследования, s является</code></p>
<p><code>// Rectangle, поэтому мы можем</code></p>
<p><code>// увеличить его площадь</code></p>
<p><code>assert(s.width() == s.height()); // По-прежнему должно быть справедливо</code></p>
<p><code>// для всех квадратов</code></p>
<empty-line/><p>Как и в предыдущем примере, что второе утверждение также никогда не должно быть нарушено. По определению, ширина квадрата равна его высоте.</p>
<p>Но теперь перед нами встает проблема. Как примирить следующие утверждения?</p>
<p>• Перед вызовом makeBigger высота s равна ширине.</p>
<p>• Внутри makeBigger ширина s изменяется, а высота – нет.</p>
<p>• После возврата из makeBigger высота s снова равна ширине (отметим, что s передается по ссылке, поэтому makeBigger модифицирует именно s, а не его копию).</p>
<p>Так что же?</p>
<p>Добро пожаловать в удивительный мир открытого наследования, где интуиция, приобретенная вами в других областях знания, включая математику, иногда оказывается плохим помощником. Основная трудность в данном случае заключается в том, что некоторые утверждения, справедливые для прямоугольника (его ширина может быть изменена независимо от высоты), не выполняются для квадрата (его ширина и высота должны быть одинаковы). Но открытое наследование предполагает, что все, что применимо к объектам базового класса, – <emphasis>все!</emphasis> – также применимо и к объектам производных классов. В ситуации с прямоугольниками и квадратами (а также в аналогичных случаях, включая множества и списки из правила 38), утверждение этого условия не выполняется, поэтому использование открытого наследования для моделирования здесь некорректно. Компилятор, конечно, этого не запрещает, но, как мы только что видели, не существует гарантий, что такой код будет вести себя должным образом. Любому программисту должно быть известно (некоторые знают это лучше других): если код компилируется, то это еще не значит, что он будет работать.</p>
<p>Все же не стоит беспокоиться, что приобретенная вами за многие годы разработки программного обеспечения интуиция окажется бесполезной при переходе к объектно-ориентированному программированию. Все ваши знания по-прежнему актуальны, но теперь, когда вы добавили к своему арсеналу наследование, вам придется дополнить свою интуицию новым пониманием, позволяющим создавать приложения с использованием наследования. Со временем идея наследования Penguin от Bird или Square от Rectangle будет казаться вам столь же забавной, как функция объемом в несколько страниц. Такое решение <emphasis>может</emphasis> оказаться правильным, но это маловероятно.</p>
<p>Отношение «является» – не единственное, возможное между классами. Два других, достаточно распространенных отношения – это «содержит» и «реализован посредством». Они рассматриваются в правилах 38 и 39. Очень часто при проектировании на C++ весь проект идет вкривь и вкось из-за того, что эти взаимосвязи моделируются отношением «является». Поэтому вы должны быть уверены, что понимаете различия между этими отношениями и знаете, каким образом их лучше всего моделировать в C++.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Открытое наследование означает «является». Все, что применимо к базовому классу, должно быть применимо также и производным от него, потому что каждый объект производного класса является также объектом базового класса.</p>
</section><section><title><p>Правило 33: Не скрывайте унаследованные имена</p>
</title><p>Шекспир много размышлял об именах. Он писал: «Что в имени тебе? Роза пахнет розой, хоть розой назови ее, хоть нет». И еще писал бард: «Кто доброе мое похитит имя, несчастным сделает меня вовек…» Правильно. И это заставляет нас обратить взор на унаследованные имена в C++.</p>
<p>Вообще-то эта тема относится не столько к наследованию, сколько к областям видимости. Все мы знаем, что в таком коде:</p>
<empty-line/><p><code>int x; // глобальная переменная</code></p>
<p><code>void someFunc()</code></p>
<p><code>{</code></p>
<p><code>double x; // локальная переменная</code></p>
<p><code>std::cin &gt;&gt; x; // прочитать новое значение локальной переменной x</code></p>
<p><code>}</code></p>
<empty-line/><p>имя x в предложении считывания относится к локальной, а не к глобальной переменной, потому что имена во вложенной области видимости скрывают («затеняют») имена из внешних областей. Мы можем представить эту ситуацию визуально:</p>
<image l:href="#i_003.png"/><p>Когда компилятор встречает имя x внутри функции someFunc, он смотрит, определено ли что-то с таким именем в локальной области видимости. Если да, то объемлющие области видимости не просматриваются. В данном случае имя x в функции someFunc принадлежит переменной типа double, а глобальная переменная с тем же именем x имеет тип int, но это несущественно. Правила сокрытия имен в C++ предназначены для одной-единственной цели: скрывать <emphasis>имена.</emphasis> Относятся ли одинаковые имена к объектам одного или разных типов, не имеет значения. В нашем примере переменная x типа double скрывает переменную x типа int.</p>
<p>Вернемся к наследованию. Мы знаем, что когда находимся внутри функции-члена производного класса и ссылаемся на что-то из базового класса (например, функцию-член, typedef или член данных), компилятор сможет найти то, на что мы ссылаемся, потому что производные классы наследуют свойства, объявленные в базовых классах. Механизм основан на том, что область видимости производного класса вложена в область видимости базового класса. Например:</p>
<image l:href="#i_004.png"/><p><code>class Base {</code></p>
<p><code>private:</code></p>
<p><code>int x; </code></p>
<p><code>public:</code></p>
<p><code>virtual void mf1() = 0;</code></p>
<p><code>virtual void mf2();</code></p>
<p><code>void mf3();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class Derived: public Base {</code></p>
<p><code>public:</code></p>
<p><code>virtual void mf1()</code></p>
<p><code>void mf4();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>В этом примере встречаются как открытые, так и закрытые имена, как имена членов данных, так и функций-членов. Одна из функций-членов – чисто виртуальная, другая – просто виртуальная, а третья – невиртуальная. Это я к тому, что мы говорим именно об <emphasis>именах,</emphasis> а не о чем-то другом. Я мог бы включить в пример еще имена типов, например перечислений, вложенных классов и typedef. В данном контексте важно лишь то, что все это <emphasis>имена.</emphasis> Что они именуют – несущественно. В примере используется одиночное наследование, но, поняв, что происходит при одиночном наследовании, легко будет разобраться и в том, как C++ ведет себя при множественном наследовании.</p>
<p>Предположим, что функция-член mf4 в производном классе реализована примерно так:</p>
<empty-line/><p><code>void Derived::mf4()</code></p>
<p><code>{</code></p>
<p><code>...</code></p>
<p><code>mf2();</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>Когда компилятор видит имя mf2, он должен понять, на что оно ссылается. Для этого в различных областях видимости производится поиск имени mf2. Сначала оно ищется в локальной области видимости (то есть внутри mf4), но там такого имени нет. Тогда просматривается объемлющая область видимости, то есть область видимости класса Derived. И здесь такое имя отсутствует, поэтому компилятор переходит к следующей область видимости, которой является базовый класс. И находит там нечто по имени mf2, после чего поиск завершается. Если бы mf2 не было и в классе Base, то поиск продолжился бы сначала в пространстве имен, содержащем Base, если таковое имеется, и, наконец, в глобальной области видимости.</p>
<p>Данное мной описание правильно, хотя и исчерпывает всю сложность процесса поиска имен в C++. Наша цель, однако, не в том, чтобы узнать о поиске имен столько, чтобы самостоятельно написать компилятор. Достаточно будет, если мы сумеем избежать неприятных сюрпризов, а для этого изложенной информации должно хватить.</p>
<p>Снова вернемся к предыдущему примеру, но на этот раз перегрузим функции mf1 и mf3, а также добавим версию mf3 в класс Derived. Как объясняется в правиле 36, перегрузка mf3 в производном классе Derived (когда наследуется невиртуальная функция) сама по себе подозрительна, но чтобы лучше разобраться с видимостью имен, закроем на это глаза.</p>
<image l:href="#i_005.png"/><p><code>class Base {</code></p>
<p><code>private:</code></p>
<p><code>int x;</code></p>
<p><code>public:</code></p>
<p><code>virtual void mf1() = 0;</code></p>
<p><code>virtual void mf1(int);</code></p>
<p><code>virtual void mf2();</code></p>
<p><code>void mf3();</code></p>
<p><code>void mf3(double);</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class Derived: public Base {</code></p>
<p><code>public:</code></p>
<p><code>virtual void mf1()</code></p>
<p><code>void mf3();</code></p>
<p><code>void mf4();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Этот код приводит к поведению, которое удивит любого программиста C++, впервые столкнувшегося с ним. Основанное на областях видимости правило сокрытия имен никуда не делось, поэтому <emphasis>все</emphasis> функции с именами mf1 и mf3 в базовом классе окажутся скрыты одноименными функциями в производном классе. С точки зрения поиска имен, Base::mf1 и Base::mf3 более не наследуются классом Derived!</p>
<empty-line/><p><code>Derived d;</code></p>
<p><code>int x;</code></p>
<p><code>...</code></p>
<p><code>d.mf1(); // правильно, вызывается Derived::mf1</code></p>
<p><code>d.mf1(x); // ошибка! Derived::mf1 скрывает Base::mf1</code></p>
<p><code>d.mf2(); // правильно, вызывается Base::mf2</code></p>
<p><code>d.mf3(); // правильно, вызывается Derived::mf3</code></p>
<p><code>d.mf3(x); // ошибка! Derived::mf3 скрывает Base::mf3</code></p>
<empty-line/><p>Как видите, это касается даже тех случаев, когда функции в базовом и производном классах принимают параметры разных типов, независимо от того, идет ли речь о виртуальных или невиртуальных функциях. И точно так же, как в нашем первом примере double x внутри функции someFunc скрывает int x из глобального контекста, так и здесь функция mf3 в классе Derived скрывает функцию mf3 из класса Base, которая имеет другой тип.</p>
<p>Обоснование такого поведения в том, что оно не дает нечаянно унаследовать перегруженные функции из базового класса, расположенного много выше в иерархии наследования, упрятанной в библиотеке или каркасе приложения. К сожалению, обычно вы <emphasis>хотите</emphasis> унаследовать перегруженные функции. Фактически если вы используете открытое наследование и не наследуете перегруженные функций, то нарушаете семантику отношения «является» между базовым и производным классами, которое в правиле 32 провозглашено фундаментальным принципом открытого наследования. То есть это тот случай, когда вы почти всегда хотите обойти принятое в C++ по умолчанию правило сокрытия имен.</p>
<p>Это можно сделать с помощью using-объявлений:</p>
<image l:href="#i_006.png"/><p><code>class Base {</code></p>
<p><code>private:</code></p>
<p><code>int x;</code></p>
<p><code>public:</code></p>
<p><code>virtual void mf1() = 0;</code></p>
<p><code>virtual void mf1(int);</code></p>
<p><code>virtual void mf2();</code></p>
<p><code>void mf3();</code></p>
<p><code>void mf3(double);</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class Derived: public Base {</code></p>
<p><code>public:</code></p>
<p><code>using Base::mf1; // обеспечить видимость всех (открытых) имен</code></p>
<p><code>using Base::mf3; // mf1 и mf3 из класса Base в классе Derived</code></p>
<p><code>virtual void mf1()</code></p>
<p><code>void mf3();</code></p>
<p><code>void mf4();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Теперь наследование будет работать, как и ожидается.</p>
<empty-line/><p><code>Derived d;</code></p>
<p><code>int x;</code></p>
<p><code>...</code></p>
<p><code>d.mf1(); // по-прежнему правильно, вызывается Derived::mf1</code></p>
<p><code>d.mf1(x); // теперь правильно, вызывается Base::mf1</code></p>
<p><code>d.mf2(); // по-прежнему правильно, вызывается Base::mf2</code></p>
<p><code>d.mf3(); // по-прежнему правильно, вызывается Derived::mf3</code></p>
<p><code>d.mf3(x); // теперь правильно, вызывается Base::mf3</code></p>
<empty-line/><p>Это означает, что если вы наследуете базовому классу с перегруженными функциями и хотите переопределить только некоторые из них, то должны включить using-объявление для каждого имени, иначе оно будет скрыто.</p>
<p>Можно представить себе ситуацию, когда вы не хотите наследовать все функции из базовых классов. При открытом наследовании такое никогда не должно происходить, так как это противоречит смыслу отношения «является» между базовым классом и производным от него. Вот почему using-объявление находится в секции public объявления производного класса; имена, которые открыты в базовом классе, должны оставаться открытыми и в открыто унаследованном от него. Но при закрытом наследовании (см. правило 39) такое желание иногда осмыслено. Например, предположим, что класс Derived закрыто наследует классу Base, и единственная версия mfl, которую Derived хочет унаследовать, – это та, что не принимает параметров. Using-объявление в этом случае не поможет, поскольку оно делает видимыми в производном классе <emphasis>все</emphasis> унаследованные функции с заданным именем. Здесь требуется другая техника – простая перенаправляющая функция:</p>
<empty-line/><p><code>class Base {</code></p>
<p><code>public:</code></p>
<p><code>virtual void mf1() = 0;</code></p>
<p><code>virtual void mf1(int);</code></p>
<p><code>... // как раньше</code></p>
<p><code>};</code></p>
<p><code>class Derived: private Base {</code></p>
<p><code>public:</code></p>
<p><code>virtual void mf1() // перенаправляющая функция</code></p>
<p><code>{ Base::mf1();} // неявно встроена (см. правило 30)</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>...</code></p>
<p><code>Derived d;</code></p>
<p><code>Int x;</code></p>
<p><code>d.mf1(); // правильно, вызывается Derived::mf1</code></p>
<p><code>d.mf1(x); // ошибка! Base::mf1 скрыта</code></p>
<empty-line/><p>Другое применение встроенных перенаправляющих функций – обойти дефект в тех устаревших компиляторах, которые не поддерживают using-объявления для импорта унаследованных имен в область видимости производного класса.</p>
<p>Это все, что можно сказать о наследовании и сокрытии имен. Впрочем, когда наследование сочетается с шаблонами, возникает совсем другой вариант проблемы «сокрытия унаследованных имен». Все подробности, касающиеся шаблонов, см. в правиле 43.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Имена в производных классах скрывают имена из базовых классов. При открытом наследовании это всегда нежелательно.</p>
<p>• Чтобы сделать скрытые имена видимыми, используйте using-объявления либо перенаправляющие функции.</p>
</section><section><title><p>Правило 34: Различайте наследование интерфейса и наследование реализации</p>
</title><p>Внешне простая идея открытого наследования при ближайшем рассмотрении оказывается состоящей из двух различных частей: наследования интерфейса функций и наследования их реализации. Различие между этими двумя видами наследования соответствует различию между объявлениями и определениями функций, обсуждавшемуся во введении к этой книге.</p>
<p>При разработке классов иногда требуется, чтобы производные классы наследовали только интерфейс (объявления) функций-членов. В других случаях необходимо, чтобы производные классы наследовали и интерфейс, и реализацию функций, но могли переопределять унаследованную реализацию. А иногда вам может понадобиться использование наследования интерфейса и реализации, но без возможности что-либо переопределять.</p>
<p>Чтобы лучше почувствовать различия между этими вариантами, рассмотрим иерархию классов для представления геометрических фигур в графическом приложении:</p>
<empty-line/><p><code>class Shape {</code></p>
<p><code>public:</code></p>
<p><code>virtual void draw() const = 0;</code></p>
<p><code>virtual void error(const std::string&amp; msg);</code></p>
<p><code>int objectID() const;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class Rectangle: public Shape {…};</code></p>
<p><code>class Ellipse: public Shape {…};</code></p>
<empty-line/><p>Shape – это абстрактный класс; таковым его делает чисто виртуальная функция draw. В результате пользователи не могут создавать объекты класса Shape, а лишь классов, производных от него. Несмотря на это, Shape оказывает сильное влияние на все открыто наследующие ему классы по следующей причине:</p>
<p><emphasis>• Интерфейс</emphasis> функций-членов <emphasis>наследуется всегда.</emphasis> Как объясняется в правиле 32, открытое наследование означает «является», поэтому все, что верно для базового класса, также верно и для производных от него. Поэтому если функция применима к классу, она остается применимой и для подклассов.</p>
<p>В классе Shape объявлены три функции. Первая, draw, выводит текущий объект на дисплей, подразумеваемый по умолчанию. Вторая, error, вызывается функциями-членами, если необходимо сообщить об ошибке. Третья, objectID, возвращает уникальный целочисленный идентификатор текущего объекта. Каждая из трех функций объявлена по-разному: draw – как чисто виртуальная; error – как просто виртуальная; а objectID – как невиртуальная функция. Каковы практические последствия этих различий?</p>
<p>Рассмотрим первую чисто виртуальную функцию draw:</p>
<empty-line/><p><code>class Shape {</code></p>
<p><code>public:</code></p>
<p><code>virtual void draw() const = 0;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Две наиболее заметные характеристики чисто виртуальных функций – они <emphasis>должны</emphasis> быть заново объявлены в любом конкретном наследующем их классе, и в абстрактном классе они обычно не определяются. Сопоставьте эти два свойства, и вы придете к пониманию следующего обстоятельства:</p>
<p>• Цель объявления чисто виртуальной функции состоит в том, чтобы производные классы наследовали <emphasis>только ее интерфейс.</emphasis></p>
<p>Это в полной мере относится к функции Shape::draw, поскольку наиболее разумное требование ко всем объектам класса Shape заключается в том, что они должны быть отображены на дисплее, но Shape не может обеспечить разумной реализации этой функции по умолчанию. Алгоритм рисования эллипса очень сильно отличается от алгоритма рисования прямоугольника. Объявление Shape::draw можно интерпретировать как следующее сообщение разработчикам конкретных подклассов: «Вы должны обеспечить наличие функции draw, но у меня нет ни малейшего представления, как вы это собираетесь сделать».</p>
<p>Между прочим, дать определение чисто виртуальной функции <emphasis>возможно.</emphasis> Иными словами, вы можете предоставить реализацию для Shape::draw, и С++ будет ее компилировать, но единственный способ вызвать – квалифицировать имя функции названием класса:</p>
<empty-line/><p><code>Shape *ps = new Shape; // ошибка! Shape – абстрактный</code></p>
<p><code>Shape *ps1 = new Rectangle; // правильно</code></p>
<p><code>ps1-&gt;draw(); // вызов Rectangle::draw</code></p>
<p><code>Shape *ps2 = new Ellipse; // правильно</code></p>
<p><code>Ps2-&gt;draw(); // вызов Ellipse::draw</code></p>
<p><code>ps1-&gt;Shape::draw(); // вызов Shape::draw</code></p>
<p><code>ps2-&gt;Shape::draw(); // вызов Shape::draw</code></p>
<empty-line/><p>Кроме перспективы блеснуть перед приятелями-программистами во время вечеринки, знание этой особенности вряд ли даст вам что-то ценное. Тем не менее, как вы увидите ниже, возможность определения чисто виртуальной функции может быть использована в качестве механизма обеспечения более безопасной реализации по умолчанию обычных виртуальных функций.</p>
<p>Ситуация с обычными виртуальными функциями несколько отличается от ситуации с чисто виртуальными функциями. Как всегда, производные классы наследуют интерфейс функции, но обычные виртуальные функции традиционно обеспечивают реализацию, которую подклассы могут переопределить. Если вы на минуту задумаетесь над этим, то поймете, что:</p>
<p>• Цель объявлений обычной виртуальной функции – наследовать в производных классах <emphasis>как интерфейс, так и ее реализацию по умолчанию.</emphasis></p>
<p>Рассмотрим функцию Shape::error:</p>
<empty-line/><p><code>class Shape {</code></p>
<p><code>public:</code></p>
<p><code>virtual void error(const std::string&amp; msg);</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Интерфейс говорит о том, что каждый класс должен поддерживать функцию, которую необходимо вызывать при возникновении ошибки, но каждый класс волен обрабатывать ошибки наиболее подходящим для себя образом. Если класс не предполагает производить специальные действия, он может просто положиться на обработку ошибок по умолчанию, которую предоставляет класс Shape. То есть объявление Shape::error говорит разработчикам производных классов: «Вы должны поддерживать функцию error, но если не хотите писать свою собственную, то можете рассчитывать просто использовать версию по умолчанию из класса Shape».</p>
<p>Оказывается, иногда может быть опасно использовать обычные виртуальные функции, которые обеспечивают как интерфейс функции, так и ее реализацию по умолчанию. Для того чтобы понять, почему имеется такая вероятность, рассмотрим иерархию самолетов в компании XYZ Airlines. XYZ располагает самолетами только двух типов: модель A и модель B, и оба летают одинаково. В связи с этим разработчики XYZ проектирует такую иерархию:</p>
<empty-line/><p><code>class Airport {…}; // представляет аэропорты</code></p>
<p><code>class Airplane {</code></p>
<p><code>public:</code></p>
<p><code>virtual void fly(const Airport&amp; destination);</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>void Airplane::fly(const Airport&amp; destination)</code></p>
<p><code>{</code></p>
<p><code><emphasis>код по умолчанию, описывающий полет самолета</emphasis></code></p>
<empty-line/><p><code><emphasis>в заданный пункт назначения – destination</emphasis></code></p>
<p><code>}</code></p>
<p><code>class ModelA: public Airplane {...};</code></p>
<p><code>class ModelB: public Airplane {...};</code></p>
<empty-line/><p>Чтобы выразить тот факт, что все самолеты должны поддерживать функцию fly, и для того чтобы засвидетельствовать, что для разных моделей, в принципе, могут потребоваться различные реализации fly, функция Airplane::fly объявлена виртуальной. При этом во избежание написания идентичного кода в классах ModelA и ModelB в качестве стандартного поведения используется тело функции Airplane::fly, которую наследуют как ModelA, так и ModelB.</p>
<p>Это классический пример объектно-ориентированного проектирования. Два класса имеют общее свойство (способ реализации fly), поэтому оно реализуется в базовом классе и наследуется обоими подклассами. Благодаря этому проект явным образом выделяет общие свойства, что позволяет избежать дублирования, благоприятствует проведению будущих модернизаций и упрощает долгосрочную эксплуатацию – иными словами, обеспечивает все, за что так ценится объектно-ориентированная технология. Программисты компании XYZ Airlines могут собой гордиться.</p>
<p>А теперь предположим, что дела XYZ идут в гору, и компания решает приобрести новый самолет модели C. Эта модель отличается от моделей A и B, в частности, тем, что летает по-другому.</p>
<p>Программисты компании XYZ добавляют в иерархию класс ModelC, но в спешке забывают переопределить функцию fly:</p>
<empty-line/><p><code>class ModelB: public Airplane {</code></p>
<p><code>... // функция fly не объявлена</code></p>
<p><code>};</code></p>
<empty-line/><p>В своем коде потом они пишут что-то вроде этого:</p>
<empty-line/><p><code>Airport PDX(...); // PDX – аэропорт возле моего дома</code></p>
<p><code>Airplane *pa = new ModelC;</code></p>
<p><code>...</code></p>
<p><code>pa-&gt;fly(PDX); // вызывается Airplane::fly!</code></p>
<empty-line/><p>Назревает катастрофа: делается попытка отправить в полет объект ModelC, как если бы он принадлежал одному из классов ModelA или ModelB. Такой образ действия вряд ли может внушить доверие пассажирам.</p>
<p>Проблема здесь заключается не в том, что Airplane::fly ведет себя определенным образом по умолчанию, а в том, что такое наследование допускает неявное применение этой функции для ModelC. К счастью, легко можно предложить подклассам поведение по умолчанию, но не предоставлять его, если они сами об этом не попросят. Трюк состоит в том, чтобы разделить <emphasis>интерфейс</emphasis> виртуальной функции и ее <emphasis>реализацию</emphasis> по умолчанию. Вот один из способов добиться этого:</p>
<empty-line/><p><code>class Airplane {</code></p>
<p><code>public:</code></p>
<p><code>virtual void fly(const Airport&amp; destination) = 0;</code></p>
<p><code>...</code></p>
<p><code>protected:</code></p>
<p><code>void defaultFly(const Airport&amp; destination);</code></p>
<p><code>};</code></p>
<p><code>void Airplane::defaultFly(const Airport&amp; destination)</code></p>
<p><code>{</code></p>
<p><code><emphasis>код по умолчанию, описывающий полет самолета в заданный пункт назначения</emphasis></code></p>
<p><code>}</code></p>
<empty-line/><p>Обратите внимание, что функция Airplane::fly преобразовна в чисто виртуальную. Она предоставляет интерфейс для полета. В классе Airplane присутствует и реализация по умолчанию, но теперь она представлена в форме независимой функции defaultFly. Классы, подобные ModelA и ModelB, которые хотят использовать поведение по умолчанию, просто выполняют встроенный вызов defaultFly внутри fly (см. также правило 30 о взаимодействии встраивания и виртуальных функций):</p>
<empty-line/><p><code>class ModelA: public Airplane {</code></p>
<p><code>public:</code></p>
<p><code>virtual void fly(const Airport&amp; destination)</code></p>
<p><code>{ defaultFly(destination};}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class ModelB: public Airplane {</code></p>
<p><code>public:</code></p>
<p><code>virtual void fly(const Airport&amp; destination)</code></p>
<p><code>{ defaultFly(destination};}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Теперь для класса ModelC возможность случайно унаследовать некорректную реализацию fly исключена, поскольку чисто виртуальная функция в Airplane вынуждает ModelC создавать свою собственную версию fly.</p>
<empty-line/><p><code>class ModelC: public Airplane {</code></p>
<p><code>public:</code></p>
<p><code>virtual void fly(const Airport&amp; destination)</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>void ModelC::fly(const Airport&amp; destination)</code></p>
<p><code>{</code></p>
<p><code><emphasis>код, описывающий полет самолета ModelC в заданный пункт назначения</emphasis></code></p>
<p><code>}</code></p>
<empty-line/><p>Эта схема не обеспечивает «защиту от дурака» (программисты все же могут создать себе проблемы копированием/вставкой), но она более надежна, чем исходная. Что же касается функции Airplane::defaultFly, то она объявлена защищенной, поскольку действительно является деталью реализации класса Airplane и производных от него. Пассажиры теперь должны беспокоиться только о том, чтобы улететь, а не о том, как происходит полет.</p>
<p>Важно также то, что Airplane::defaultFly объявлена как невиртуальная функция. Это связано с тем, что никакой подкласс не должен ее переопределять – обстоятельство, которому посвящено правило 36. Если бы defaultFly была виртуальной, перед вами снова встала бы та же самая проблема: что, если некоторые подклассы забудут переопределить defaultFly должным образом?</p>
<p>Иногда высказываются возражения против идеи разделения функций на обеспечивающие интерфейс и реализацию по умолчанию, такие, например, как fly и defaultFly. Прежде всего, отмечают противники этой идеи, это засоряет пространство имен класса близкими названиями функций. Все же они соглашаются с тем, что интерфейс и реализация по умолчанию должны быть разделены. Как разрешить кажущееся противоречие? Для этого используется тот факт, что производные классы должны переопределять чисто виртуальные функции и при необходимости предоставлять свои собственные реализации. Вот как можно было бы использовать возможность определения чисто виртуальных функций в иерархии Airplane:</p>
<empty-line/><p><code>class Airplane {</code></p>
<p><code>public:</code></p>
<p><code>virtual void fly(const Airport&amp; destination) = 0;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>void Airplane::fly(const Airport&amp; destination) // реализация чисто</code></p>
<p><code>{ // виртуальной функции</code></p>
<p><code><emphasis>код по умолчанию, описывающий полет</emphasis></code></p>
<p><code><emphasis>самолета в заданный пункт назначения</emphasis></code></p>
<p><code>}</code></p>
<p><code>class ModelA: pubic Airplane {</code></p>
<p><code>public:</code></p>
<p><code>virtual void fly(const Airport&amp; destination)</code></p>
<p><code>{ Airplane::fly(destination);}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class ModelB: pubic Airplane {</code></p>
<p><code>public:</code></p>
<p><code>virtual void fly(const Airport&amp; destination)</code></p>
<p><code>{ Airplane::fly(destination);}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class ModelC: pubic Airplane {</code></p>
<p><code>public:</code></p>
<p><code>virtual void fly(const Airport&amp; destination);</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>void ModelC::fly(const Airport&amp; destination)</code></p>
<p><code>{</code></p>
<p><code><emphasis>код, описывающий полет самолета ModelC в заданный пункт назначения</emphasis></code></p>
<p><code>}</code></p>
<empty-line/><p>Это практически такой же подход, как и прежде, за исключением того, что тело чисто виртуальной функции Airplane::fly заменяет собой независимую функцию Airplane::defaultFly. По существу, fly разбита на две основные составляющие. Объявление задает интерфейс (который <emphasis>должен</emphasis> быть использован в производных классах), а определение задает поведение по умолчанию (которое <emphasis>может</emphasis> использоваться производным классом, но только по явному требованию). Однако, производя слияние fly и defaultFly, мы теряем возможность задать для этих функций разные уровни доступа: код, который должен быть защищенным (функция defaultFly), становится открытым (потому что теперь он находится внутри fly).</p>
<p>И наконец, пришла очередь невиртуальной функции класса Shape – objectID:</p>
<empty-line/><p><code>class Shape {</code></p>
<p><code>public:</code></p>
<p><code>int objectID() const;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Когда функция-член объявлена невиртуальной, не предполагается, что она будет вести себя иначе в производных классах. В действительности невиртуальные функции-члены выражают <emphasis>инвариант относительно специализации,</emphasis> поскольку определяют поведение, которое должно сохраняться независимо от того, как специализируются производные классы. Справедливо следующее:</p>
<p>• Цель объявления невиртуальной функции – заставить производные классы наследовать как ее <emphasis>интерфейс, так и обязательную реализацию.</emphasis></p>
<p>Вы можете представлять себе объявление Shape::objectID как утверждение: «Каждый объект Shape имеет функцию, которая дает идентификатор объекта, и этот идентификатор всегда вычисляется одним и тем же способом. Этот способ задается определением функции Shape::objectID, и никакой производный класс не должен его изменять». Поскольку невиртуальная функция определяет инвариант относительно специализации, ее не следует переопределять в производных классах (см. правило 36).</p>
<p>Разница в объявлениях чисто виртуальных, просто виртуальных и невиртуальных функций позволяет точно указать, что, по вашему замыслу, должны наследовать производные классы: только интерфейс, интерфейс и реализацию по умолчанию либо интерфейс и обязательную реализацию соответственно. Поскольку эти типы объявлений обозначают принципиально разные вещи, следует тщательно подходить к выбору подходящего варианта при объявлянии функции-члена. При этом вы должны избегать двух ошибок, чаще всего совершаемых неопытными проектировщиками классов.</p>
<p>Первая ошибка – объявление всех функций невиртуальными. Это не оставляет возможности для маневров в производных классах; при этом больше всего проблем вызывают невиртуальные деструкторы (см. правило 7). Конечно, нет ничего плохого в проектировании классов, которые не предполагается использовать в качестве базовых. В этом случае вполне уместен набор из одних только невиртуальных функций-членов. Однако очень часто такие классы объявляются либо из-за незнания различий между виртуальными и невиртуальными функциями, либо в результате необоснованного беспокойства по поводу потери производительности при использовании виртуальных функций. Факт остается фактом: практически любой класс, который должен использоваться как базовый, будет содержать виртуальные функции (см. правило 7).</p>
<p>Если вы обеспокоены тем, во что обходится использование виртуальных функций, позвольте мне напомнить вам эмпирическое правило «80–20» (см. также правило 30), которое утверждает, что в типичной программе 80 % времени исполнения затрачивается на 20 % кода. Это правило крайне важно, потому что оно означает, что в среднем 80 % ваших функций могут быть виртуальными, не оказывая ощутимого влияния на общую производительность программы. Прежде чем начать беспокоиться о том, можете ли вы позволить себе использование виртуальных функций, убедитесь, что вы имеете дело с теми 20 % программы, для которых ваше решение окажет существенное влияние на производительность.</p>
<p>Другая распространенная ошибка – объявление <emphasis>всех</emphasis> функций виртуальными. Иногда это правильно, о чем свидетельствуют, например, интерфейсные классы (см. правило 31). Однако данное решение может также навести на мысль, что у разработчика нет ясного понимания задачи. Некоторые функции не должны переопределяться в производных классах, и в таком случае необходимо недвусмысленно указать на это, объявляя функции невиртуальными. Не имеет смысла делать вид, что ваш класс годится на все случаи жизни, стоит лишь переопределить его функции. Если вы видите необходимость в инвариантности относительно специализации, не бойтесь это признать!</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Наследование интерфейса отличается от наследования реализации. При открытом наследовании производные классы всегда наследуют интерфейсы базовых классов.</p>
<p>• Чисто виртуальные функции означают, что наследуется только интерфейс.</p>
<p>• Обычные виртуальные функции означают, что наследуются интерфейс и реализация по умолчанию.</p>
<p>• Невиртуальные функции означают, что наследуются интерфейс и обязательная реализация.</p>
</section><section><title><p>Правило 35: Рассмотрите альтернативы виртуальным функциям</p>
</title><section><p>Предположим, что вы работаете над видеоигрой и проектируете иерархию игровых персонажей. В вашей игре будут использоваться разные варианты сражений, персонажи могут подвергаться ранениям или иначе терять жизненные силы. Поэтому вы решаете включить в класс функцию-член healthValue, которая возвращает целочисленное значение, показывающее, сколько жизненных сил осталось у персонажа. Поскольку разные персонажи могут вычислять свою жизненную силу по-разному, то представляется естественным объявить функцию healthValue следующим образом:</p>
<empty-line/><p><code>class GameCharacter {</code></p>
<p><code>public:</code></p>
<p><code>virtual void healthValue() const; // возвращает жизненную силу персонажа</code></p>
<p><code>... // в производных классах можно</code></p>
<p><code>}; // переопределить</code></p>
<empty-line/><p>Тот факт, что healthValue не объявлена как чисто виртуальная, наводит на мысль, что существует алгоритм вычисления жизненной силы по умолчанию (см. правило 34).</p>
<p>Это очевидный подход к проектированию, и в каком-то смысле в очевидности и заключается его слабость. Поскольку решение кажется совершенно естественным, не исключено, что вы забудете уделить должное внимание рассмотрению альтернатив. Чтобы помочь вам выбраться из колеи, рассмотрим некоторые другие подходы к проблеме.</p>
</section><section><title><p>Реализация паттерна««Шаблонный метод» с помощью идиомы невиртуального интерфейса</p>
</title><p>Начнем с интересной концепции, которая утверждает, что виртуальные функции почти всегда должны быть закрытыми. Сторонники этой школы предполагают, что правильно было бы оставить функцию-член healthValue открытой, но сделать ее невиртуальной и заставить вызывать закрытую виртуальную функцию, которая и выполнит реальную работу. Назовем эту функцию doHealthValue:</p>
<empty-line/><p><code>class GameCharacter {</code></p>
<p><code>public:</code></p>
<p><code>int healthValue() const // производные классы не переопределяют</code></p>
<p><code>{ // эту функцию, см. правило 36</code></p>
<p><code>... // выполнить предварительные действия –</code></p>
<p><code>// см. ниже</code></p>
<p><code>int retVal = doHealthValue(); // выполнить реальную работу</code></p>
<p><code>... // выполнить завершающие действия –</code></p>
<p><code>// см. ниже</code></p>
<p><code>return retVal;</code></p>
<p><code>}</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>virtual int doHealthValue() const // производные классы могут</code></p>
<p><code>{ // переопределить эту функцию</code></p>
<p><code>... // алгоритм по умолчанию для вычисления</code></p>
<p><code>} // жизненной силы персонажа</code></p>
<p><code>};</code></p>
<empty-line/><p>В этом коде (и ниже в данном правиле) я привожу тела функций в определениях классов. Как следует из правила 30, тем самым они неявно объявляются встроенными. Я поступаю так лишь для того, чтобы смысл кода было проще понять. Описываемый подход к проектированию никак не зависит от того, будут ли функции встроенными или нет.</p>
<p>Основная идея этого подхода – дать возможность клиентам вызывать закрытые виртуальные функции опосредованно, через открытые невиртуальные функции-члены – известен под названием <emphasis>идиома невиртуального интерфейса (non-virtual interface idiom – NVI).</emphasis> Это частный случай более общего паттерна проектирования, называемого «Шаблонный метод» (Template Method) (к сожалению, он не имеет никакого отношения к шаблонам C++). Я называю невиртуальную функцию (healthValue) <emphasis>оберткой (wrapper)</emphasis> виртуальной функции.</p>
<p>Преимущество идиомы NVI таится в коде, скрытом за комментариями «выполнить предварительные действия» и «выполнить завершающие действия». Подразумевается, что некоторый код гарантированно будет выполнен перед вызовом виртуальной функции, выполняющей реальную работу, и после возврата из нее. Таким образом, обертка настроит контекст перед вызовом виртуальной функции создания, а после возврата произведет очистку. Например, «предварительные действия» могут заключаться в захвате мьютекса, записи в протокол, проверке инвариантов класса и выполнении предусловий и т. п. В состав «завершающих действий» могут входить освобождение мьютекса, проверка постусловий функции, повторная проверка инвариантов класса и т. п. Будет затруднительно проделать все это, если вы позволите клиентам вызывать виртуальную функцию непосредственно.</p>
<p>Возможно, вас поразила следующая странность: идиома NVI предполагает, что производные классы-наследники переопределяют закрытые виртуальные функции, которых они и вызывать-то не могут! Но здесь нет противоречия. Переопределяя виртуальную функцию, мы говорим, <emphasis>как</emphasis> должно быть выполнено некоторое действие. Вызов же виртуальной функции определяет момент, <emphasis>когда</emphasis> это действие выполняется. Одно от другого не зависит. Идиома NVI позволяет производным классам переопределить виртуальную функцию и, стало быть, управлять тем, <emphasis>как</emphasis> реализована некоторая функциональность. Базовый же класс оставляет за собой право определять, <emphasis>когда</emphasis> должна быть вызвана функция. Поначалу это может показаться странным, но то, что C++ разрешает в производных классах переопределять закрытые виртуальные функции, вполне разумно.</p>
<p>Идиома NVI не требует, чтобы виртуальные функции обязательно были закрытыми. В некоторых иерархиях классов ожидается, что виртуальная функция, переопределенная в производном классе, будем вызывать одноименную функцию из базового класса (как в примере из правила 27). Чтобы такие вызовы были возможны, виртуальная функция должна быть защищенной, а не закрытой. Иногда она даже может быть открытой (как, например, деструкторы в полиморфных базовых классах – см. правило 7), но к этому случаю идиома NVI уже неприменима.</p>
</section><section><title><p>Реализация паттерна «Стратегия» посредством указателей на функции</p>
</title><p>Идиома NVI – это интересная альтернатива открытым виртуальным функциям, но с точки зрения проектирования она дает не слишком много. В конце концов, мы по-прежнему используем виртуальные функции для вычисления жизненной силы каждого персонажа. С точки зрения проектирования гораздо более сильным было бы утверждение о том, что вычисление жизненной силы персонажа не зависит от типа персонажа, что такие вычисления вообще не являются свойством персонажа как такового. Например, мы можем потребовать, чтобы конструктору каждого персонажа передавался указатель на функцию, которая вызывалась бы для вычисления его жизненной силы:</p>
<empty-line/><p><code>class GameCharacter; // опережающее объявление</code></p>
<p><code>// функция алгоритма по умолчанию для вычисления жизненной силы персонажа</code></p>
<p><code>int defaultHealthCalc(const GameCharacter&amp; gc);</code></p>
<p><code>class GameCharacter {</code></p>
<p><code>public:</code></p>
<p><code>typedef int (*HealthCalcFunc)(const GameCharacter&amp;);</code></p>
<p><code>explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)</code></p>
<p><code>: healthFunc(hcf)</code></p>
<p><code>{}</code></p>
<p><code>int healthValue() const</code></p>
<p><code>{ return healthFunc(*this);}</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>HealthCalcFunc healthFunc;</code></p>
<p><code>};</code></p>
<empty-line/><p>Это простой пример применения другого распространенного паттерна проектирования – «Стратегия» (Strategy). По сравнению с подходами, основанными на виртуальных функциях в иерархии GameCharacter, он предоставляет некоторые любопытные возможности, повышающие гибкость:</p>
<p>• Разные экземпляры персонажей одного и того же типа могут иметь разные функции вычисления жизненной силы. Например:</p>
<empty-line/><p><code>class EvilBadGay: public GameCharacter {</code></p>
<p><code>public:</code></p>
<p><code>explicit EvilBadGay(HealthCalcFunc hcf = defaultHealthCalc)</code></p>
<p><code>: GameCharacter(hcf)</code></p>
<p><code>{...}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>int loseHealthQuickly(const GameCharacter&amp;); // функции вычисления</code></p>
<p><code>int loseHealthSlowly(const GameCharacter&amp;); // жизненной силы</code></p>
<p><code>// с разным поведением</code></p>
<p><code>EvilBadGay ebg1(loseHealthQuickly); // однотипные персонажи</code></p>
<p><code>EvilBadGay ebg2(loseHealthSlowly); // с разным поведением</code></p>
<p><code>// относительно здоровья</code></p>
<empty-line/><p>• Функция вычисления жизненной силы для одного и того же персонажа может изменяться во время исполнения. Например, класс GameCharacter мог бы предложить функцию-член setHealthCalculator, которая позволяет заменить текущую функцию вычисления жизненной силы.</p>
<p>С другой стороны, тот факт, что функция вычисления жизненной силы больше не является функцией-членом иерархии GameCharacter, означает, что она не имеет специального доступа к внутреннему состоянию объекта, чью жизненную силу вычисляет. Например, defaultHealthCalc не имеет доступа к закрытым частям EvilBadGay. Это не страшно, если жизненная сила персонажа может быть вычислена с помощью его открытого интерфейса, но для максимально точных расчетов может понадобиться доступ к закрытой информации. На самом деле такая проблема может возникать всегда, когда некоторая функциональность выносится из класса наружу (например, из функций-членов в свободные функции, не являющиеся друзьями класса, или в функции-члены другого класса, не дружественного данному). Она будет встречаться в настоящем правиле и далее, потому что все прочие проектные решения, которые нам еще предстоит рассмотреть, тоже включают использование функций, находящихся вне иерархии GameCharacter.</p>
<p>Общее правило таково: единственный способ рарешить функциям, не являющимся членами класса, доступ к его закрытой части – ослабить степень инкапсуляции. Например, класс может объявлять функции-нечлены в качестве друзей либо предоставлять открытые функции для доступа к тем частям реализации, которые лучше было бы оставить закрытыми. Имеет ли смысл жертвовать инкапсуляцией ради выгоды от использования указателей на функции вместо виртуальных функций (например, чтобы иметь разные функции жизненной силы для разных объектов и динамически менять их), решать вам в каждом конкретном случае.</p>
</section><section><title><p>Реализация паттерна «Стратегия» посредством класса tr::function</p>
</title><p>Если вы привыкли к шаблонам и их применению для построения неявных интерфейсов (см. правило 41), то применение указателей на функции покажется вам не слишком гибким решением. Почему вообще для вычисления жизненной силы нужно обязательно использовать функцию, а не что-то <emphasis>ведущее себя</emphasis> как функция (например, функциональный объект)? Если от функции никуда не деться, то почему не сделать ее членом класса? И почему функция должна возвращать int, а не объект, который можно <emphasis>преобразовать</emphasis> в int?</p>
<p>Эти ограничения исчезают, если вместо указателя на функцию (подобную healthFunc) воспользоваться объектом типа tr::function. Как объясняется в правиле 54, такой объект может содержать любую <emphasis>вызываемую сущность</emphasis> (указатель на функцию, функциональный объект либо указатель на функцию-член), чья сигнатура совместима с ожидаемой. Вот пример такого подхода, на этот раз с использованием tr1::function:</p>
<empty-line/><p><code>class GameCharacter; // как раньше</code></p>
<p><code>int defaultHealthCalc(const GameCharacter&amp; gc); // как раньше</code></p>
<p><code>class GameCharacter {</code></p>
<p><code>public:</code></p>
<p><code>// HealthCalcFunction – это любая вызываемая сущность, которой можно</code></p>
<p><code>// передать в качестве параметра нечто, совместимое с GameCharacter,</code></p>
<p><code>// и которая возвращает нечто, совместимое с int; подробности см. ниже</code></p>
<p><code>typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;</code></p>
<p><code>explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)</code></p>
<p><code>: healthFunc(hcf)</code></p>
<p><code>{}</code></p>
<p><code>int healthValue() const</code></p>
<p><code>{ return healthFunc(*this);}</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>HealthCalcFunc healthFunc;</code></p>
<p><code>};</code></p>
<empty-line/><p>Как видите, HealthCalcFunc – это typedef, описывающий конкретизацию шаблона tr1::function. А значит, он работает как обобщенный указатель на функцию. Посмотрим внимательнее, как определен тип HealthCalcFunc:</p>
<empty-line/><p><code>std::tr1::function&lt;int (const GameCharacter&amp;)&gt;</code></p>
<empty-line/><p>Здесь я выделил «целевую сигнатуру» данной конкретизации tr1::function. Словами ее можно описать так: «функция, принимающая ссылку на объект типа const GameCharacter и возвращающая int». Объект типа HealthCalcFunc может содержать любую вызываемую сущность, чья сигнатура совместима с заданной. Быть совместимой в данном случае означает, что параметр можно неявно преобразовать в const GameCharacter&amp;, а тип возвращаемого значения неявно конвертируется в int.</p>
<p>Если сравнить с предыдущим вариантом дизайна (где GameCharacter включал в себя указатель на функцию), то вы не обнаружите почти никаких отличий. Единственная разница в том, что GameCharacter теперь содержит объект типа tr1::function – <emphasis>обобщенный</emphasis> указатель на функцию. Это изменение так незначительно, что я назвал бы его несущественным, если бы не то обстоятельство, что теперь пользователь получает ошеломляющую гибкость в спецификации функций, вычисляющих жизненную силу:</p>
<empty-line/><p><code>short calcHealth(const gameCharacter&amp;); // функция вычисления</code></p>
<p><code>// жизненной силы;</code></p>
<p><code>// она возвращает не int</code></p>
<p><code>stuct HealthCalculator { // класс функциональных</code></p>
<p><code>int operator()(const GameCharacter&amp;) const // объектов, вычисляющих</code></p>
<p><code>{...} // жизненную силу</code></p>
<p><code>};</code></p>
<p><code>class GameLevel {</code></p>
<p><code>public:</code></p>
<p><code>float health(const GameCharacter&amp;) const; // функция-член для</code></p>
<p><code>... // вычисления жизненной</code></p>
<p><code>}; // силы; возвращает не int</code></p>
<p><code>class EvilBadGay: public GameCharacter { // как раньше</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class EyeCandyCharacter: public GameCharacter { // другой тип персонажей;</code></p>
<p><code>... // предполагается такой же</code></p>
<p><code>}; // конструктор как</code></p>
<p><code>// у EvilBadGay</code></p>
<p><code>EvilBadGay ebg1(calcHealh); // персонаж использует</code></p>
<p><code>// функцию вычисления</code></p>
<p><code>// жизненной силы</code></p>
<p><code>EyeCandyCharacter ecc1(HealthCalculator()); // персонаж использует</code></p>
<p><code>// функциональный объект</code></p>
<p><code>// вычисления жизненной</code></p>
<p><code>// силы</code></p>
<p><code>GameLevel currentLevel;</code></p>
<p><code>...</code></p>
<p><code>EvilBadGay ebg2( // персонаж использует</code></p>
<p><code>std::tr1::bind(&amp;GameLevel::health, // функцию-член для</code></p>
<p><code>currentLevel, // вычисления жизненной</code></p>
<p><code>_1) // силы; подробности</code></p>
<p><code>); // см. ниже</code></p>
<empty-line/><p>Лично я поражаюсь тому, какие удивительные вещи позволяет делать шаблон tr1::function. Если вы не разделяете моих чувств, то не исключено, что просто не понимаете, для чего используется tr1::bind в определении ebg2. Позвольте мне объяснить.</p>
<p>Мы хотим сказать, что для вычисления жизненной силы персонажа ebg2 следует использовать функцию-член класса GameLevel. Но из объявления GameLevel::health следует, что она должна принимать один параметр (ссылку на GameCharacter), а на самом деле она принимает два, потому что имеется еще неявный параметр типа GameLevel – тот, на который внутри нее указывает this. Все функции вычисления жизненной силы принимают лишь один параметр: ссылку на персонажа GameCharacter, чья жизненная сила вычисляется. Если мы используем функцию GameLevel::health, то должны каким-то образом «адаптировать» ее, чтобы вместо двух параметров (GameCharacter и GameLevel) она принимала только один (GameCharacter). В этом примере мы хотим для вычисления здоровья ebg2 в качестве параметра типа GameLevel всегда использовать объект currentLevel, поэтому «привязываем» его как первый параметр при вызове GameLevel::health. Именно в этом и заключается смысл вызова tr1::bind: указать, что функция вычисления жизненной силы персонажа ebg2 должна в качестве объекта типа GameLevel использовать currentLevel.</p>
<p>Я пропускаю целый ряд подробностей, к примеру: почему «_1» означает «использовать currentLevel в качестве объекта GameLevel при вызове GameLevel::health для ebg2». Эти детали не столь сложны, к тому же они не имеют прямого отношения к основной идее, которую я хочу продемонстрировать, а именно: используя tr1::function вместо указателя на функцию, мы позволяем пользователям применять <emphasis>любую совместимую вызываемую сущность</emphasis> для вычислении жизненной силы персонажа. Впечатляет, не правда ли?</p>
</section><section><title><p>«Классический» паттерн «Стратегия»</p>
</title><p>Если вас больше интересуют паттерны проектирования, чем собственно язык C++, то более традиционный подход к реализации паттерна «Стратегия» состоит в том, чтобы сделать функцию вычисления жизненной силы виртуальной функцией-членом в классах, принадлежащих отдельной иерархии. Эта иерархия может выглядеть примерно так:</p>
<image l:href="#i_007.png"/><p>Если вы не знакомы с нотацией UML, поясню: здесь говорится, что GameCharacter – корень иерархии, в которой EvilBadGay и EyeCandyCharacter являются производными классами; HealthCalcFunc – корень иерархии, в которой производными классами являются SlowHealthLooser и FastHealthLooser; и каждый объект типа GameCharacter содержит указатель на объект из иерархии HealthCalcFunc. А вот как структурируется соответствующий код:</p>
<empty-line/><p><code>class GameCharacter; // опережающее объявление</code></p>
<p><code>class HealthCalcFunc {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>virtual int calc(const GameCharacter&amp; gc) const</code></p>
<p><code>{...}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>HealthCalcFunc defaultHealthCalc;</code></p>
<p><code>class GameCharacter {</code></p>
<p><code>public:</code></p>
<p><code>explicit GameCharacter(HealhCalcFunc *phfc = &amp;defaultHealthCalc)</code></p>
<p><code>:pHealtCalc(pfhc)</code></p>
<p><code>{}</code></p>
<p><code>int healthValue() const</code></p>
<p><code>{ return pHealthCalc-&gt;calc(*this);}</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>HealhCalcFunc * pHealtCalc;</code></p>
<p><code>};</code></p>
<empty-line/><p>Этот подход привлекателен тем, что программисты, знакомые со «стандартной» реализацией паттерна «Стратегия», сразу видят, что к чему. К тому же он предоставляет возможность модифицировать существующий алгоритм вычисления жизненной силы путем добавления производных классов в иерархию HealthCalcFunc.</p>
</section><section><title><p>Резюме</p>
</title><p>Из этого правила вы должны извлечь одну практическую рекомендацию: размышляя над тем, как решить стоящую перед вами задачу, имеет смысл рассматривать не только виртуальные функции. Вот краткий перечень предложенных альтернатив:</p>
<p>• Применение идиомы <strong>невиртуального интерфейса</strong> (NVI), варианта паттерна проектирования «Шаблонный Метод». Смысл ее в том, чтобы обернуть открытыми невиртуальными функциями-членами вызовы менее доступных виртуальных функций.</p>
<p>• Замена виртуальных функций <strong>членами данных – указателями на функции.</strong> Это упрощенное проявление паттерна проектирования «Стратегия».</p>
<p>• Замена виртуальных функций <strong>членами данных – tr1::function.</strong> Это позволяет применять любую вызываемую сущность, сигнатура которой совместима с той, что вам нужна. Это тоже форма паттерна проектирования «Стратегия».</p>
<p>• Замена виртуальных функций из одной иерархии <strong>виртуальными функциями из другой иерархии.</strong> Это традиционная реализация паттерна проектирования «Стратегия».</p>
<p>Это не исчерпывающий список альтернатив виртуальным функциям, но его должно хватить, чтобы убедить вас в том, что такие альтернативы <emphasis>существуют.</emphasis> Более того, из сравнения их достоинств и недостатков должны быть ясно, что рассматривать их стоит.</p>
<p>Чтобы не застрять в колее на дороге объектно-ориентированного проектирования, стоит время от времени резко поворачивать руль. Путей много. Потратьте время на знакомство с ними.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• К числу альтернатив виртуальным функциям относятся идиома NVI и различные формы паттерна проектирования «Стратегия». Идиома NVI сама по себе – это пример реализации паттерна «Шаблонный Метод».</p>
<p>• Недостаток переноса функциональности из функций-членов вовне класса заключается в том, что функциям-нечленам недостает прав доступа к закрытым членам класса.</p>
<p>• Объекты tr1::function работают как обобщенные указатели на функции. Такие объекты поддерживают все вызываемые сущности, совместимые с сигнатурой целевой функции.</p>
</section></section><section><title><p>Правило 36: Никогда не переопределяйте наследуемые невиртуальные функции</p>
</title><p>Предположим, я сообщаю вам, что класс D открыто наследует классу B и что в классе B определена открытая функция-член mf. Ее параметры и тип возвращаемого значения не важны, поэтому давайте просто предположим, что это void. Другими словами, я говорю следующее:</p>
<empty-line/><p><code>class B {</code></p>
<p><code>public:</code></p>
<p><code>void mf();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class D: public B {...};</code></p>
<empty-line/><p>Даже ничего не зная о B, D или mf, имея объект x типа D,</p>
<empty-line/><p><code>D x; // x – объект типа D</code></p>
<empty-line/><p>вы, наверное, удивитесь, когда код</p>
<empty-line/><p><code>B *pB = &amp;x; // получить указатель на x</code></p>
<p><code>PB-&gt;mf(); // вызвать mf с помощью ука</code></p>
<empty-line/><p>поведет себя иначе, чем</p>
<empty-line/><p><code>D *pD = &amp;x; // получить указатель на x</code></p>
<p><code>PD-&gt;mf(); // вызвать mf через указатель</code></p>
<empty-line/><p>Ведь в обоих случаях вы вызываете функцию-член объекта x. Поскольку вы имеете дело с одной и той же функцией и одним и тем же объектом, поведение в обоих случаях должно быть одинаково, не так ли?</p>
<p>Да, так должно быть, но не всегда бывает. В частности, вы получите иной результат, если mf невиртуальна, а D определяет собственную версию mf:</p>
<empty-line/><p><code>class D: public B {</code></p>
<p><code>public:</code></p>
<p><code>void mf(); // скрывает B:mf; см. правило 33</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>PB-&gt;mf(); // вызвать B::mf</code></p>
<p><code>PD-&gt;mf(); // вызвать D::mf</code></p>
<empty-line/><p>Причина такого «двуличного» поведения заключается в том, что невиртуальные функции, подобные B::mf и D::mf, связываются статически (см. правило 37). Это означает, что когда pB объявляется как указатель на объект тип B, невиртуальные функции, вызываемые посредством pB, – это <emphasis>всегда</emphasis> функции, определения которых даны в классе B, даже если pB, как в данном примере, указывает на объект класса, производного от B.</p>
<p>С другой стороны, <emphasis>виртуальные</emphasis> функции связываются динамически (снова см. правило 37), поэтому для них не существует такой проблемы. Если бы функция mf была виртуальной, то ее вызов как посредством pB, так и посредством pD означал бы вызов D::mf, потому в <emphasis>действительности</emphasis> pB и pD указывают на объект типа D.</p>
<p>В итоге, если вы пишете класс D и переопределяете невиртуальную функцию mf, наследуемую от класса B, есть вероятность, что объекты D будут вести себя совершенно непредсказуемо. В частности, любой конкретный объект D может вести себя при вызове mf либо как B, либо как D, причем определяющим фактором будет не тип самого объекта, а лишь тип указателя на него. При этом ссылки в этом отношении ведут себя ничем не лучше указателей.</p>
<p>Это все, что относится к «прагматической» аргументации. Теперь, я уверен, требуется некоторое теоретическое обоснование запрета на переопределение наследуемых невиртуальных функций. С удовольствием его представлю.</p>
<p>В правиле 32 объясняется, что открытое наследование всегда означает «является разновидностью», а в правиле 34 говорится, почему объявление невиртуальной функции в классе определяет инвариант относительно специализации этого класса. Если вы примените эти наблюдения к классам B и D и невиртуальной функции B: mf, то получите следующее:</p>
<p>• Все, что применимо к объектам B, применимо и к объектам D, поскольку каждый объект D также является объектом B;</p>
<p>• Подклассы B должны наследовать как интерфейс, так и реализацию mf, потому что mf невиртуальна в B.</p>
<p>Теперь, если D переопределяет mf, возникает противоречие. Если класс D <emphasis>действительно</emphasis> должен содержать отличную от B реализацию mf и если каждый объект B, являющийся разновидностью B, <emphasis>действительно</emphasis> должен использовать реализацию mf из B, тогда неверно, что каждый объект класса D является разновидностью B. В этом случае D не должен открыто наследовать B. С другой стороны, если класс D <emphasis>действительно</emphasis> должен открыто наследовать B и если D <emphasis>действительно</emphasis> должен содержать реализацию mf, отличную от B, тогда неверно, что mf является инвариантом относительно специализации B. В этом случае mf должна быть виртуальной. И наконец, если каждый объект класса D <emphasis>действительно</emphasis> является разновидностью B и если mf – <emphasis>действительно</emphasis> инвариант относительно специализации B, тогда D, по правде говоря, не нуждается в переопределении mf и не должен пытаться это делать.</p>
<p>Независимо от того, какой из аргументов применим в вашем случае, чем-то придется пожертвовать, но при любых обстоятельствах запрет на переопределение наследуемых невиртуальных функций остается в силе.</p>
<p>Если при чтении этого правила у вас возникло ощущение <emphasis>«дежа вю»,</emphasis> то, наверное, вы просто вспомнили правило 7, где я объяснял, почему деструкторы в полиморфных базовых классах должны быть виртуальными. Если вы не следуете этому совету (то есть объявляете невиртуальные деструкторы в полиморфных базовых классах), то нарушаете и требование, изложенное в настоящем правиле, потому что все производные классы автоматически переопределяют унаследованную невиртуальную функцию – деструктор базового класса. Это верно даже для производных классов, в которых нет деструкторов, потому что, как объясняется в правиле 5, компилятор генерирует деструктор автоматически, если вы не определяете его сами. По существу, правило 7 – это лишь частный случай настоящего правила, хотя и заслуживает отдельного внимания и рекомендаций по применению.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Никогда не переопределяйте наследуемые невиртуальные функции.</p>
</section><section><title><p>Правило 37: Никогда не переопределяйте наследуемое значение аргумента функции по умолчанию</p>
</title><p>Давайте с самого начала упростим обсуждение. Есть только два типа функций, которые можно наследовать: виртуальные и невиртуальные. Но переопределять наследуемые невиртуальные функции в любом случае ошибочно (см. правило 36), поэтому мы вполне можем ограничить наше обсуждение случаем наследования <emphasis>виртуальной</emphasis> функции со значением аргумента по умолчанию.</p>
<p>В этих обстоятельствах мотивировка настоящего правила становится достаточно очевидной: виртуальные функции связываются динамически, а значения аргументов по умолчанию – статически.</p>
<p>Что это значит? Вы говорите, что уже позабыли, в чем заключается разница между статическим и динамическим связыванием? (Кстати, статическое связывание называют еще <emphasis>ранним связыванием,</emphasis> а динамическое – <emphasis>поздним.)</emphasis> Что ж, давайте освежим вашу память.</p>
<p><emphasis>Статический тип</emphasis> объекта – это тип, объявленный вами в тексте программы. Рассмотрим следующую иерархию классов:</p>
<empty-line/><p><code>// классы для представления геометрических фигур</code></p>
<p><code>class Shape {</code></p>
<p><code>public:</code></p>
<p><code>enum ShapeColor { Red, Green, Blue };</code></p>
<p><code>// все фигуры должны предоставлять функцию для рисования</code></p>
<p><code>virtual void draw(ShapeColor color = Red) const = 0;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class Rectangle: public Shape {</code></p>
<p><code>public:</code></p>
<p><code>// заметьте, другое значение параметра по умолчанию – плохо!</code></p>
<p><code>virtual void draw(ShapeColor color = Green) const;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class Circle: public Shape {</code></p>
<p><code>public:</code></p>
<p><code>virtual void draw(ShapeColor color) const;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Графически это можно представить так:</p>
<image l:href="#i_008.png"/><p>Теперь рассмотрим следующие указатели:</p>
<empty-line/><p><code>Shape *ps; // статический тип – Shape*</code></p>
<p><code>Shape *pc = new Circle; // статический тип – Shape*</code></p>
<p><code>Shape *pr = new Rectangle; // статический тип – Shape*</code></p>
<empty-line/><p>В этом примере ps, pc и pr объявлены как указатели на Shape, так что для всех них он и будет выступать в роли статического типа. Отметим, что не совершенно безразлично, на что они указывают <emphasis>в действительности,</emphasis> – независимо от этого они имеют статический тип Shape*.</p>
<p><emphasis>Динамический тип</emphasis> объекта определяется типом того объекта, на который он ссылается в данный момент. Иными словами, динамический тип определяет поведение объекта. В приведенном выше примере динамический тип pc – это Circle*, а динамический тип pr – Recangle*. Что касается ps, то он не имеет динамического типа, потому что не указывает ни на какой объект (пока).</p>
<p>Динамические типы, как следует из их названия, могут изменяться в процессе работы программы, обычно вследствие присваивания:</p>
<empty-line/><p><code>ps = pc; // динамический тип ps теперь Circle*</code></p>
<p><code>ps = pr; // динамический тип ps теперь Rectangle*</code></p>
<empty-line/><p>Виртуальные функции <emphasis>связываются динамически,</emphasis> то есть динамический тип вызывающего объекта определяет, какая конкретная функция вызывается:</p>
<empty-line/><p><code>pc-&gt;draw(Shape::Red); // вызывается Circle::draw(Shape::Red)</code></p>
<p><code>pr-&gt;draw(Shape::Red); // вызывается Rectangle::draw(Shape::Red)</code></p>
<empty-line/><p>Я знаю, что все это давно известно, и вы, несомненно, разбираетесь в виртуальных функциях. Самое интересное начинается, когда мы подходим к виртуальным функциям с аргументами, принимающими значения по умолчанию, поскольку, как я уже сказал, виртуальные функции связываются динамически, а аргументы по умолчанию – статически. Следовательно, вы можете прийти к тому, что будете вызывать виртуальную функцию, определенную в <emphasis>производном классе,</emphasis> но при этом использовать аргументы по умолчанию, заданные в <emphasis>базовом классе:</emphasis></p>
<empty-line/><p><code>pr-&gt;draw(); // вызывается Rectangle::draw(Shape::Red)!</code></p>
<empty-line/><p>В этом случае динамический тип pr – это Rectangle*, поэтому, как вы и ожидали, вызывается виртуальная функция класса Rectangle. Для функции Rectangle::draw значение аргумента по умолчанию – Green. Но поскольку статический тип pr – Shape*, то значения аргумента по умолчанию берутся из класса Shape, а не Rectangle! В результате получаем вызов, состоящий из странной, совершенно неожиданной комбинации объявлений draw из классов Shape и Rectangle.</p>
<p>Тот факт, что ps, pc и pr являются указателями, не играет никакой роли. Будь они ссылками, результат остался бы таким же. Важно лишь, что draw – виртуальная функция, и значение по умолчанию одного из ее аргументов переопределено в производном классе.</p>
<p>Почему C++ настаивает на таком диковинном поведении? Ответ на этот вопрос связан с эффективностью исполнения программы. Если бы значения аргументов по умолчанию связывались динамически, то компилятору пришлось бы найти способ во время исполнения определять, какое значение по умолчанию должно быть у параметра виртуальной функции, что медленнее и технически сложнее нынешнего механизма. Решение было принято в пользу скорости и простоты реализации, в результате чего вы можете пользоваться преимуществами эффективного выполнения кода программы. Но если не последуете совету, изложенному в настоящем правиле, то программа будет вести себя нелогично.</p>
<p>Все это прекрасно, но посмотрите, что получится, если, пытаясь следовать этому правилу, вы включите аргументы со значениями по умолчанию в функцию-член, объявленную и в базовом, и в производном классах:</p>
<empty-line/><p><code>class Shape {</code></p>
<p><code>public:</code></p>
<p><code>enum ShapeColor { Red, Green, Blue };</code></p>
<p><code>virtual void draw(ShapeColor color = Red) const = 0;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class Rectangle: public Shape {</code></p>
<p><code>public:</code></p>
<p><code>virtual void draw(ShapeColor color = Red) const;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Гм, дублирование кода! Хуже того: дублирование кода с зависимостями: если значение аргумента по умолчанию изменится в Shape, придется изменить его и во всех производных классах. В противном случае дело закончится переопределением наследуемого значения по умолчанию. Что делать?</p>
<p>Когда у вас возникает проблема с тем, чтобы заставить виртуальную функцию вести себя так, как вы хотите, то благоразумнее рассмотреть альтернативные решения, и в правиле 35 таких альтернатив приведено немало. Одна из них – <emphasis>идиома невиртуального интерфейса</emphasis> (NVI): определить в базовом классе открытую невиртуальную функцию, которая вызывает закрытую виртуальную функцию, переопределяемую в подклассах. В данном случае можно предложить невиртуальную функцию с аргументом по умолчанию и виртуальную функцию, которая выполняет всю реальную работу:</p>
<empty-line/><p><code>class Shape {</code></p>
<p><code>public:</code></p>
<p><code>enum ShapeColor( Red, Green, Blue };</code></p>
<p><code>void draw(ShapeColor color = Red) const // теперь – невиртуальная</code></p>
<p><code>{</code></p>
<p><code>doDraw(color); // вызов виртуальной функции</code></p>
<p><code>}</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>virtual void doDraw(ShapeColor color) const = 0; // реальная работа</code></p>
<p><code>}; // выполняется</code></p>
<p><code>// в этой функции</code></p>
<p><code>class Rectangle: public Shape {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>virtual void doDraw(ShapeColor color) const // обратите внимание</code></p>
<p><code>... // на отсутствие у аргумента</code></p>
<p><code>}; // значения по умолчанию</code></p>
<empty-line/><p>Поскольку невиртуальные функции никогда не должны переопределяться в производных классах (см. правило 36), то ясно, что при таком подходе значение по умолчанию для параметра color функции draw всегда будет Red.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Никогда не переопределяйте наследуемые значения аргументов по умолчанию, потому что аргументы по умолчанию связываются статически, тогда как виртуальные функции – а только их и можно переопределять, – динамически.</p>
</section><section><title><p>Правило 38: Моделируйте отношение «содержит» или «реализуется посредством» с помощью композиции</p>
</title><p><emphasis>Композиция</emphasis> – это отношение между типами, которое возникает тогда, когда объект одного типа содержит в себе объекты других типов. Например:</p>
<empty-line/><p><code>class Address {...}; // адрес проживания</code></p>
<p><code>class PhoneNumber {...};</code></p>
<p><code>class Person {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>std::string name; // вложенный объект</code></p>
<p><code>Address address; // то же</code></p>
<p><code>PhoneNumber voiceNumber; // то же</code></p>
<p><code>PhoneNumber faxNumber; // то же</code></p>
<p><code>};</code></p>
<empty-line/><p>В данном случае объекты класса Person включают в себя объекты классов string, Address и PhoneNumber. Термин <emphasis>композиция</emphasis> имеет ряд синонимов, например: <emphasis>вложение, агрегирование</emphasis> или <emphasis>встраивание.</emphasis></p>
<p>В правиле 32 объясняется, что открытое наследование означает «класс является разновидностью другого класса». У композиции тоже есть семантика, даже две: «содержит» или «реализуется посредством». Дело в том, что в своих программах вы имеете дело с двумя различными областями. Некоторые программные объекты описывают сущности из моделируемого мира: людей, автомобили, видеокадры и т. п. Такие объекты являются частью <emphasis>предметной области.</emphasis> Другие объекты возникают как часть реализации, например: буферы, мьютексы, деревья поиска и т. д. Они относятся к <emphasis>области реализации,</emphasis> свойственной для вашего приложения. Когда отношение композиции возникает между объектами из предметной области, оно имеет семантику «реализовано посредством».</p>
<p>Вышеприведенный класс Person демонстрирует отношение типа «содержит». Объект Person имеет имя, адрес, номера телефона и факса. Нельзя сказать, что человек <emphasis>«есть разновидность»</emphasis> имени или что человек <emphasis>«есть разновидность»</emphasis> адреса. Можно сказать, что человек <emphasis>«имеет»</emphasis> («содержит») имя и адрес. Большинство людей не испытывают затруднений при проведении подобных различий, поэтому путаница между ролями «является» и «содержит» возникает сравнительно редко.</p>
<p>Чуть сложнее провести различие между отношениями «является» и «реализуется посредством». Например, предположим, что вам нужен шаблон для классов, представляющих множества произвольных объектов, то есть наборов без дубликатов. Поскольку повторное использование – прекрасная вещь, то сразу возникает желание обратиться к шаблону set из стандартной библиотеки. В конце концов, зачем писать новый шаблон, когда есть возможность использовать уже готовый?</p>
<p>К сожалению, реализации set обычно влекут за собой накладные расходы – по три указателя на элемент. Связано это с тем, что множества обычно реализованы в виде сбалансированных деревьев поиска, гарантирующих логарифмическое время поиска, вставки и удаления. Когда быстродействие важнее, чем объем занимаемой памяти, это вполне разумное решение, но конкретно для вашего приложения выясняется, что экономия памяти более существенна. Поэтому стандартный шаблон set для вас неприемлем. Похоже, нужно писать свой собственный.</p>
<p>Тем не менее повторное использование – прекрасная вещь. Будучи экспертом в области структур данных, вы знаете, что среди многих вариантов реализации множеств есть и такой, который базируется на применении связанных списков. Вы также знаете, что в стандартной библиотеке C++ есть шаблон list, поэтому решаете им воспользоваться (повторно).</p>
<p>В частности, вы решаете, что создаваемый вами шаблон Set должен наследовать от list. То есть Set&lt;T&gt; будет наследовать list&lt;T&gt;. В итоге в вашей реализации объект Set будет выступать как объект list. Соответственно, вы объявляете Set следующим образом:</p>
<empty-line/><p><code>template&lt;typename T&gt; // <emphasis>неправильный </emphasis>способ использования</code></p>
<p><code>class Set: public std::list&lt;T&gt; {...}; // list для определения Set</code></p>
<empty-line/><p>До сих пор все вроде бы шло хорошо, но, если присмотреться, в код вкралась ошибка. Как объясняется в правиле 32, если D является разновидностью B, то все, что верно для B, должно быть верно также и для D. Однако объект list может содержать дубликаты, поэтому если значение 3051 вставляется в list&lt;int&gt; дважды, то список будет содержать две копии 3051. Напротив, Set не может содержать дубликатов, поэтому, если значение 3051 вставляется в Set&lt;int&gt; дважды, множество будет содержать лишь одну копию данного значения. Следовательно, утверждение, что Set является разновидностью list, ложно: ведь некоторые положения, верные для объектов list, неверны для объектов Set.</p>
<p>Из-за этого отношение между этими двумя классами не подходит под определение «является», открытое наследование – неправильный способ моделирования этой взаимосязи. Правильный подход основан на понимании того факта, что объект Set может быть <emphasis>реализован посредством</emphasis> объекта list:</p>
<empty-line/><p><code>template&lt;typename T&gt; // правильный способ использования list</code></p>
<p><code>class Set { // для определения Set</code></p>
<p><code>public:</code></p>
<p><code>bool member(const T&amp; item) const;</code></p>
<p><code>void insert(const T&amp; item);</code></p>
<p><code>void remove(const T&amp; item);</code></p>
<p><code>std::size_t size() const;</code></p>
<p><code>private:</code></p>
<p><code>std::list&lt;T&gt; rep; // представление множества</code></p>
<p><code>};</code></p>
<empty-line/><p>Функции-члены класса Set могут опереться на функциональность, предоставляемую list и другими частями стандартной библиотеки, поэтому их реализацию нетрудно написать, коль скоро вам знакомы основы программирования с применением библиотеки STL:</p>
<empty-line/><p><code>template&lt;typename T&gt;</code></p>
<p><code>bool Set&lt;T&gt;::member(const T&amp; item) const</code></p>
<p><code>{</code></p>
<p><code>return std::find(rep.begin(), rel.end(), item) != rep.end();</code></p>
<p><code>}</code></p>
<p><code>template&lt;typename T&gt;</code></p>
<p><code>void Set&lt;T&gt;::insert(const T&amp; item)</code></p>
<p><code>{</code></p>
<p><code>if(!member(item)) rep.push_back(item);</code></p>
<p><code>}</code></p>
<p><code>template&lt;typename T&gt;</code></p>
<p><code>void Set&lt;t&gt;::remove(const T&amp; item)</code></p>
<p><code>{</code></p>
<p><code>typename std::list&lt;T&gt;::iterator it = // см. в правиле 42</code></p>
<p><code>std::find(rep.begin(), rep.end(), item); // информацию о “typename”</code></p>
<p><code>if(it != rep.end()) rep.erase(it);</code></p>
<p><code>}</code></p>
<p><code>template&lt;typename T&gt;</code></p>
<p><code>std::size_t Set&lt;T&gt;::size() const</code></p>
<p><code>{</code></p>
<p><code>return rep.size();</code></p>
<p><code>}</code></p>
<empty-line/><p>Эти функции достаточно просты, чтобы стать кандидатами для встраивания, хотя перед принятием окончательного решения стоит еще раз прочитать правило 30.</p>
<p>Стоит отметить, что интерфейс Set лучше отвечал бы требованиям правила 18 (проектировать интерфейсы так, чтобы их легко было использовать правильно и трудно – неправильно), если бы он следовал соглашениям, принятым для STL-контейнеров, но для этого пришлось бы добавить в класс Set столько кода, что в нем потонула бы основная идея: проиллюстрировать взаимосвязь между Set и list. Поскольку тема настоящего правила – именно эта взаимосвязь, то мы пожертвуем совместимостью с STL ради наглядности. Недостатки интерфейса Set не должны, однако, затенять тот неоспоримый факт, что отношение между классами Set и list – не «является» (как это вначале могло показаться), а «реализовано посредством».</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Семантика композиции кардинально отличается от семантики открытого наследования.</p>
<p>• В предметной области композиция означает «содержит». В области реализации она означает «реализовано посредством».</p>
</section><section><title><p>Правило 39: Продумывайте подход к использованию закрытого наследования</p>
</title><p>В правиле 32 показано, что C++ рассматривает открытое наследование как отношение типа «является». В частности, говорится, что компиляторы, столкнувшись с иерархией, где класс Student открыто наследует классу Person, неявно преобразуют объект класса Student в объект класса Person, если это необходимо для вызова функций. Очевидно, стоит еще раз привести фрагмент кода, заменив в нем открытое наследование закрытым:</p>
<empty-line/><p><code>class Person {...}</code></p>
<p><code>class Student: private Person {...} // теперь наследование закрытое</code></p>
<p><code>void eat(const Person&amp; p); // все люди могут есть</code></p>
<p><code>void study(const Student&amp; s); // только студенты учатся</code></p>
<p><code>Person p; // p – человек (Person)</code></p>
<p><code>Student s; // s – студент (Student)</code></p>
<p><code>eat(p); // нормально, p – типа Person</code></p>
<p><code>eat(s); // ошибка! Student не является объектом</code></p>
<p><code>// Person</code></p>
<empty-line/><p>Ясно, что закрытое наследование не означает «является». А что же тогда оно означает?</p>
<p>«Стоп! – восклицаете вы. – Прежде чем говорить о значении, давайте поговорим о поведении. Как ведет себя закрытое наследование?» Первое из правил, регламентирующих закрытое наследование, вы только что наблюдали в действии: в противоположность открытому наследованию компиляторы в общем случае не преобразуют объекты производного класса (такие как Student) в объекты базового класса (такие как Person). Вот почему вызов eat для объекта s ошибочен. Второе правило состоит в том, что члены, наследуемые от закрытого базового класса, становятся закрытыми, даже если в базовом классе они были объявлены как защищенные или открытые.</p>
<p>Это то, что касается поведения. А теперь вернемся к значению. Закрытое наследование означает «реализовано посредством…». Делая класс D закрытым наследником класса B, вы поступаете так потому, что заинтересованы в использовании некоторого когда, уже написанного для B, а не потому, что между объектами B и D существует некая концептуальная взаимосвязь. Таким образом, закрытое наследование – это исключительно прием реализации. (Вот почему все унаследованное от закрытого базового класса становится закрытым и в вашем классе: это не более чем деталь реализации). Используя терминологию из правила 34, можно сказать, что закрытое наследование означает наследование <emphasis>одной только</emphasis> реализации, без интерфейса. Если D закрыто наследует B, это означает, что объекты D реализованы посредством объектов B, и ничего больше. Закрытое наследование ничего не означает в ходе <emphasis>проектирования</emphasis> программного обеспечения и обретает смысл только на этапе <emphasis>реализации.</emphasis></p>
<p>Утверждение, что закрытое наследование означает «реализован посредством», вероятно, слегка вас озадачит, поскольку в правиле 38 указывалось, что композиция может означать то же самое. Как же сделать выбор между ними? Ответ прост: используйте композицию, когда можете, а закрытое наследование – когда обязаны так поступить. А в каких случаях вы <emphasis>обязаны</emphasis> использовать закрытое наследование? В первую очередь тогда, когда на сцене появляются защищенные члены и/или виртуальные функции, хотя существуют также пограничные ситуации, когда соображения экономии памяти могут продиктовать выбор в пользу закрытого наследования.</p>
<p>Предположим, что вы работаете над приложением, в котором есть объекты класса Widget, и решили как следует разобраться с тем, как они используются. Например, интересно не только знать, насколько часто вызываются функции-члены Widget, но еще и как частота обращений к ним изменяется во времени. Программы, в которых есть несколько разных фаз исполнения, могут вести себя по-разному в каждой фазе. Например, функции, используемые компилятором на этапе синтаксического анализа, значительно отличаются от функций, вызываемых во время оптимизации и генерации кода.</p>
<p>Мы решаем модифицировать класс Widget так, чтобы отслеживать, сколько раз вызывалась каждая функция-член. Во время исполнения мы будем периодически считывать эту информацию, возможно, вместе со значениями каждого объекта Widget и другими данными, которые сочтем необходимым. Для этого понадобится установить таймер, который будет извещать нас о том, когда наступает время собирать статистику использования.</p>
<p>Предпочитая повторное использование существующего кода написанию нового, мы тщательно просмотрим наш набор инструментов и найдем следующий класс:</p>
<empty-line/><p><code>class Timer {</code></p>
<p><code>public:</code></p>
<p><code>explicit Timer(int tickFrequency);</code></p>
<p><code>virtual void onTick() const; // автоматически вызывается</code></p>
<p><code>// при каждом тике</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Это как раз то, что мы искали. Объект Timer можно настроить для срабатывания с любой частотой, и при каждом «тике» будет вызываться виртуальная функция. Мы можем переопределить эту виртуальную функцию так, чтобы она проверяла текущее состояние Widget. Отлично!</p>
<p>Для того чтобы класс Widget переопределял виртуальную функцию Timer, он должен наследовать Timer. Но открытое наследование в данном случае не подходит. Ведь Widget не является разновидностью Timer. Пользователи Widget не должны иметь возможности вызывать onTick для объекта Widget, потому что эта функция не является частью концептуального интерфейса этого класса. Если разрешить вызов подобной функции, то пользователи получат возможность работать с интерфейсом Widget некорректно, что очевидно нарушает рекомендацию из правила 18 о том, что интерфейсы должно быть легко применять правильно и трудно – неправильно. Открытое наследование в данном случае не подходит.</p>
<p>Потому мы будем наследовать закрыто:</p>
<empty-line/><p><code>class Widget: private Timer {</code></p>
<p><code>private:</code></p>
<p><code>virtual void onTick() const; // просмотр данных об использовании</code></p>
<p><code>... // Widget и т. п.</code></p>
<p><code>};</code></p>
<empty-line/><p>Благодаря закрытому наследованию открытая функция onTick класса Timer становится закрытой в Widget, и после переопределения мы ее такой и оставим. Опять же, если поместить onTick в секцию public, то это введет в заблуждение пользователей, заставляя их думать, будто ее можно вызвать, а это идет вразрез с правилом 18.</p>
<p>Это неплохое решение, но стоит отметить, что закрытое наследование не является здесь строго необходимым. Никто не мешает вместо него использовать композицию. Мы просто объявим закрытый вложенный класс внутри Widget, который будет открыто наследовать классу Timer и переопределять onTick, а затем поместим объект этого типа внутрь Widget. Вот эскиз такого подхода:</p>
<image l:href="#i_009.png"/><p><code>class Widget {</code></p>
<p><code>private:</code></p>
<p><code>class WidgetTimer: public Timer {</code></p>
<p><code>public:</code></p>
<p><code>virtual void onTick() const;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>WidgetTimer timer;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Этот дизайн сложнее того, что использует только закрытое наследование, потому что здесь используются и открытое наследование, и композиция, а ко всему еще и новый класс (WidgetTimer). Честно говоря, я показал этот вариант в первую очередь для того, чтобы напомнить о существовании различных подходов к решению одной задачи. Стоит привыкать к тому, чтобы не ограничиваться единственным решением (см. также правило 35). Тем не менее я могу представить две причины, по которым иногда имеет смысл предпочесть открытое наследование в сочетании с композицией закрытому наследованию.</p>
<p>Во-первых, вы можете спроектировать класс Widget так, чтобы ему можно было наследовать, но при этом запретить производным классам переопределять функцию onTick. Если Widget наследуется от Timer, то это невозможно, даже в случае закрытого наследования. (Напомню, что согласно правилу 35 производные классы могут переопределять виртуальные функции, даже если не могут вызывать их). Но если WidgetTimer – это закрытый класс внутри Widget, который наследует Timer, то производные от Widget классы не имеют доступа к WidgetTimer, а значит, не могут ни наследовать ему, ни переопределять его виртуальные функции. Если вам приходилось программировать на языках Java или C# и вы не обратили внимания на то, как можно запретить производным классам переопределять функции базового (с помощью ключевого слова final в Java или sealed в C#), то теперь вы знаете, как добиться примерно того же эффекта в C++.</p>
<p>Во-вторых, вы можете захотеть минимизировать зависимости Widget на этапе компиляции. Если Widget наследует классу Timer, то определение Timer должно быть доступно во время компиляции Widget, поэтому файл, определяющий Widget, вероятно, должен содержать директиву #include "Timer.h". С другой стороны, если WidgetTimer вынести из Widget, а в Widget оставить только указатель на WidgetTimer, тогда Widget сможет обойтись простым объявлением класса WidgetTimer; так что необходимость включать заголовочный файл для Timer будет устранена. Для больших систем такая развязка может оказаться важной. Подробнее о минимизации зависимостей на этапе компиляциии см. правило 31.</p>
<p>Я уже отмечал, что закрытое наследование удобно прежде всего тогда, когда предполагаемым производным классам нужен доступ к защищенным частям базового класса или у них может возникнуть потребность в переопределении одной или более виртуальных функций, но концептуальное отношение между этими классами выражается не словами «является разновидностью», а «реализован посредством». Я также говорил, что существуют ситуации, в частности, связанные с оптимизацией использования памяти, когда закрытое наследование оказывается предпочтительнее композиции.</p>
<p>Граничный случай – действительно граничный: речь идет о классах, в которых вообще нет никаких данных. Такие классы не имеют ни нестатических членов-данных, ни виртуальных функций (поскольку наличие этих функций означает добавление указателя vptr в каждый объект – см. правило 7), ни виртуальных базовых классов (поскольку в этом случае тоже имеют место дополнительные расходы памяти – см. правило 40). Концептуально, объекты таких <emphasis>пустых классов</emphasis> вообще не занимают места, потому что в них не хранится никаких данных. Однако есть технические причины, по которым C++ требует, чтобы любой автономный объект должен иметь ненулевой размер, поэтому для следующих объявлений:</p>
<empty-line/><p><code>class Empty {}; // не имеет данных, поэтому объекты</code></p>
<p><code>// не должны занимать памяти</code></p>
<p><code>class HoldsAnInt { // память, по идее, нужна только для int</code></p>
<p><code>private:</code></p>
<p><code>int x;</code></p>
<p><code>Empty e; // не должен занимать память</code></p>
<p><code>};</code></p>
<empty-line/><p>оказывается, что sizeof(HoldsAnlnt) &gt; sizeof(int); член данных Empty занимает какую-то память. Для большинства компиляторов sizeof(Empty) будет равно 1, потому что требование C++ о том, что не должно быть объектов нулевой длины, обычно удовлетворяется молчаливой вставкой одного байта (char) в такой «пустой» объект. Однако из-за необходимости выравнивания (см. правило 50) компилятор может оказаться вынужден дополнить классы, подобные HoldsAnInt, поэтому вполне вероятно, что размер объектов HoldsAnInt увеличится больше чем на char, скорее всего, речь может идти о росте на размер int. На всех компиляторах, где я тестировал, происходило именно так.</p>
<p>Возможно, вы обратили внимание, что, говоря о ненулевом размере, я упомянул «автономные» объекты. Это ограничение не относится к тем частям производного класса, которые унаследованы от базового, поскольку они уже не считаются «автономными». Если вы наследуете Empty вместо того, чтоб включать его,</p>
<empty-line/><p><code>class HoldsAnInt: private Empty {</code></p>
<p><code>private:</code></p>
<p><code>int x;</code></p>
<p><code>};</code></p>
<empty-line/><p>то почти наверняка обнаружите, что sizeof(HoldsAnlnt) = sizeof(int). Это явление известно как <emphasis>оптимизация пустого базового класса (empty base optimization – EBO),</emphasis> и оно реализовано во всех компиляторах, которые я тестировал. Если вы разрабатываете библиотеку, пользователям которой небезразлично потребление памяти, то знать о EBO будет полезно. Но имейте в виду, что в общем случае оптимизация EBO применяется только для одиночного наследования. Действующие в C++ правила размещения объектов в памяти обычно делают невозможной такую оптимизацию, если производный класс имеет более одного базового.</p>
<p>На практике «пустые» классы на самом деле не совсем пусты. Хотя они и не содержат нестатических данных-членов, но часто включают typedefbi, перечисления, статические члены-данные, или невиртуальные функции. В библиотеке STL есть много технически пустых классов, которые содержат полезные члены (обычно typedef). К их числу относятся, в частности, базовые классы unary_function и binary_function, которым обычно наследуют классы определяемых пользователями функциональных объектов. Благодаря широкому распространению реализаций EBO такое наследование редко увеличивает размеры производных классов.</p>
<p>Но вернемся к основам. Большинство классов не пусты, поэтому EBO редко может служить оправданием закрытому наследованию. Более того, в большинстве случаев наследование выражает отношение «является», а это признак открытого, а не закрытого наследования. Как композиция, так и закрытое наследование выражают отношение «реализован посредством», но композиция проще для понимания, поэтому использует ее всюду, где возможно.</p>
<p>Закрытое наследование чаще всего оказывается разумной стратегией проектирования, когда вы имеете дело с двумя классами, не связанными отношением «является», причем один из них либо нуждается в доступе к защищенным членам другого, либо должен переопределять одну или несколько виртуальных функций последнего. И даже в этом случае мы видели, что сочетание открытого наследования и композиции часто помогают реализовать желаемое поведение, хотя и ценой некоторого усложнения. Говоря о <emphasis>продумывании</emphasis> подхода к применению закрытого наследования, я имею в виду, что прибегать к нему стоит лишь тогда, когда рассмотрены все другие альтернативы и выяснилось, что это лучший способ выразить отношение между двумя классами в вашей программе.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Закрытое наследование означает «реализован посредством». Обычно этот вариант хуже композиции, но все же приобретает смысл, когда производный класс нуждается в доступе к защищенным членам базового класса или должен переопределять унаследованные виртуальные функции.</p>
<p>• В отличие от композиции, закрытое наследование позволяет проводить оптимизацию пустого базового класса. Это может оказаться важным для разработчиков библиотек, которые стремятся минимизировать размеры объектов.</p>
</section><section><title><p>Правило 40: Продумывайте подход к использованию множественного наследования</p>
</title><p>Когда речь заходит о множественном наследовании (multiple inheritance – MI), сообщество разработчиков на C++ разделяется на два больших лагеря. Одни полагают, что раз одиночное исследование (SI) – это хорошо, то множественное наследование должно быть еще лучше. Другие говорят, что одиночное наследование – это на самом деле хорошо, а множественное не стоит хлопот. В этом правиле мы постараемся разобраться в обеих точках зрения.</p>
<p>Первое, что нужно уяснить для себя о множественном наследовании, – это появляющаяся возможность унаследовать одно и то же имя (функции, typedef и т. п.) от нескольких базовых классов. Это может стать причиной неоднозначности. Например:</p>
<empty-line/><p><code>class BorrowableItem { // нечто, что можно позаимствовать</code></p>
<p><code>// из библиотеки</code></p>
<p><code>public:</code></p>
<p><code>void checkOut();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class ElectronicGadget {</code></p>
<p><code>private:</code></p>
<p><code>bool checkOut() const; // выполняет самотестирование, возвращает</code></p>
<p><code>... // признак успешности теста</code></p>
<p><code>};</code></p>
<p><code>class MP3Player: // здесь множественное наследование (в некоторых</code></p>
<p><code>public BorrowableItem, // библиотеках реализована функциональность,</code></p>
<p><code>public ElectronicGadget // необходимая для MP3-плееров)</code></p>
<p><code>{...} // определение класса не важно</code></p>
<p><code>MP3Player mp;</code></p>
<p><code>mp.checkout(); // неоднозначность! какой checkOut?</code></p>
<empty-line/><p>Отметим, что в этом примере вызов функции checkOut неоднозначен, несмотря на то что доступна лишь одна из двух функций. (checkOut открыта в классе Borrowableltem и закрыта в классе ElectronicGadget.) И это согласуется с правилами разрешения имен перегруженных функций в C++: прежде чем проверять права доступа, C++ находит функцию, которая наиболее соответствует вызову. И только потом проверяется, доступна ли наиболее подходящая функция. В данном случае оба варианта функции checkOut одинаково хорошо соответствуют вызову, то есть ни одна из них не подходит лучше, чем другая. А стало быть, до проверки доступности ElectronicGadget::checkOut дело не доходит.</p>
<p>Чтобы разрешить неоднозначность, вы можете указать имя базового класса, чью функцию нужно вызвать:</p>
<empty-line/><p><code>mp.BorrowableItem::checkOut(); // вот какая checkOut мне нужна!</code></p>
<empty-line/><p>Вы, конечно, также можете попытаться явно вызвать ElectronicGadget::check-Out, но тогда вместо ошибки неоднозначности получите другую: «вы пытаетесь вызвать закрытую функцию-член».</p>
<p>Множественное наследование просто означает наследование более, чем от одного базового класса, но вполне может возникать также и в иерархиях, содержащих более двух уровней. Это может привести к «ромбовидному наследованию»:</p>
<image l:href="#i_010.png"/><p><code>class File {...};</code></p>
<p><code>class InputFile: public File {...};</code></p>
<p><code>class OutputFile: public File {...};</code></p>
<p><code>class IOFile: public InputFile,</code></p>
<p><code>public OutputFile</code></p>
<p><code>{...};</code></p>
<empty-line/><p>Всякий раз, когда вы строите иерархию наследования, в которой от базового класса к производному ведет более одного пути (как в приведенном примере: от File к IOFile можно пройти как через InputFile, так и через OutputFile), вам приходится сталкиваться с вопросом о том, должны ли данные-члены базового класса дублироваться в объекте подкласса столько раз, сколько имеется путей. Например, предположим, что в классе File есть член filename. Сколько копий этого поля должно быть в классе IOFile? С одной стороны, он наследует по одной копии от каждого из своих базовых классов, следовательно, всего будет два члена данных с именем fileName. С другой стороны, простая логика подсказывает, что объект IOFile имеет только одно имя файла, поэтому поле fileName, наследуемое от двух базовых классов, не должно дублироваться.</p>
<p>C++ не принимает ничью сторону в этом споре. Он успешно поддерживает оба варианта, хотя по умолчанию предполагается дублирование. Если это не то, что вам нужно, сделайте класс, содержащий данные (то есть File), <emphasis>виртуальным базовым классом.</emphasis> Для этого все непосредственные потомки должны использовать <emphasis>виртуальное наследование:</emphasis></p>
<image l:href="#i_011.png"/><p><code>class File {...};</code></p>
<p><code>class InputFile: virtual public File {...};</code></p>
<p><code>class OutputFile: virtual public File {...};</code></p>
<p><code>class IOFile: public InputFile,</code></p>
<p><code>public OutputFile</code></p>
<p><code>{...};</code></p>
<empty-line/><p>В стандартной библиотеке C++ есть похожая иерархия, только классы в ней являются шаблонными и называются basic_ios, basic_istream, basic_ostream и basic_iostream, в не File, InputFile, OutputFile и IOFile.</p>
<p>С точки зрения корректности, открытое наследование всегда должно быть виртуальным. Если бы это была единственная точка зрения, то правило было бы простым: всякий раз при открытом наследовании используйте <emphasis>виртуальное</emphasis> открытое наследование. К сожалению, корректность – не единственное, что нужно принимать во внимание. Чтобы избежать дублирования унаследованных членов, компилятору приходится прибегать к нетривиальным трюкам, из-за чего размер объектов классов, использующих множественное виртуальное наследование, обычно оказывается больше по сравнению со случаем, когда виртуальное наследование не используется. Доступ к данным-членам виртуальных базовых классов также медленнее, чем к данным невиртуальных базовых классов. Детали реализации зависят от компилятора, но суть остается неизменной: виртуальное наследование требует затрат.</p>
<p>Оно обходится не бесплатно еще и по другой причине. Правила, определяющие инициализацию виртуальных базовых классов, сложнее и интуитивно не так понятны, как правила для невиртуальных базовых классов. Ответственность за инициализацию виртуального базового класса ложится на <emphasis>самый дальний производный класс</emphasis> в иерархии. Отсюда следует, что: (1) классы, наследующие виртуальному базовому и требующие инициализации, должны знать обо всех своих виртуальных базовых классах, независимо от того, как далеко они от них находятся в иерархии, и (2) когда в иерархию добавляется новый производный класс, он должен принять на себя ответственность за инициализацию виртуальных предков (как прямых, так и непрямых).</p>
<p>Мой совет относительно виртуальных базовых классов (то есть виртуального наследования) прост. Во-первых, не применяйте виртуальных базовых классов до тех пор, пока в этом не возникнет настоятельная потребность. По умолчанию используйте невиртуальное наследование. Во-вторых, если все же избежать виртуальных базовых классов не удается, старайтесь не размещать в них данных. Тогда можно будет забыть о странностях правил инициализации (да, кстати, и присваивания) таких классов. Неспроста интерфейсы Java и. NET, которые во многом подобны виртуальным базовым классам C++, не могут содержать никаких данных.</p>
<p>Теперь рассмотрим следующий интерфейсный класс C++ (см. правило 31) для моделирования физических лиц:</p>
<empty-line/><p><code>class IPerson {</code></p>
<p><code>public:</code></p>
<p><code>virtual ~IPerson();</code></p>
<p><code>virtual std::string name() const = 0;</code></p>
<p><code>virtual std::string birthDate() const = 0;</code></p>
<p><code>};</code></p>
<empty-line/><p>Пользователи IPerson должны программировать в терминах указателей и ссылок на IPerson, поскольку создавать объекты абстрактных классов запрещено. Для создания объектов, которыми можно манипулировать как объектами IPerson, используются функции-фабрики (опять же см. правило 31), которые порождают объекты конкретных классов, производных от IPerson:</p>
<empty-line/><p><code>// функция-фабрика для создания объекта Person по уникальному</code></p>
<p><code>// идентификатору из базы данных; см. в правиле 18,</code></p>
<p><code>// почему возвращаемый тип – не обычный указатель</code></p>
<p><code>std::tr1::shared_ptr&lt;IPerson&gt; makePerson(DatabaseID personIdentifier);</code></p>
<p><code>// функция для запроса идентификатора у пользователя</code></p>
<p><code>DatabaseID askUserForDtabaseID();</code></p>
<p><code>DatabaseID id(askUserForDtabaseID());</code></p>
<p><code>std::tr1::shared_ptr&lt;IPerson&gt; pp(makePerson(id)); // создать объект,</code></p>
<p><code>// поддерживающий</code></p>
<p><code>// интерфейс IPerson</code></p>
<p><code>... // манипулировать *pp</code></p>
<p><code>// через функции-члены</code></p>
<p><code>// IPerson</code></p>
<empty-line/><p>Но как makePerson создает объекты, на которые возвращает указатель? Ясно, что должен быть какой-то конкретный класс, унаследованный от IPerson, который makePerson может инстанцировать.</p>
<p>Предположим, этот класс называется CPerson. Будучи конкретным классом, CPerson должен предоставлять реализацию чисто виртуальных функций, унаследованных от IPerson. Можно написать его «с нуля», но лучше воспользоваться уже готовыми компонентами, которые делают большую часть работы. Например, предположим, что старый, ориентированный только на базы данных класс Person-Info предоставляет почти все необходимое CPerson:</p>
<empty-line/><p><code>class PersonInfo {</code></p>
<p><code>public:</code></p>
<p><code>explicit PersonInfo(DatabaseID pid)</code></p>
<p><code>virtual ~PersonInfo();</code></p>
<p><code>virtual const char *theName() const;</code></p>
<p><code>virtual const char *theBirthDate() const;</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>virtual const char *valeDelimOpen() const; // ñì. íèæå</code></p>
<p><code>virtual const char *valeDelimClose() const;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Понять, что этот класс старый, можно хотя бы потому, что функции-члены возвращают const char* вместо объектов string. Но если ботинки подходят, почему бы не носить их? Имена функций-членов класса наводят на мысль, что результат может оказаться вполне удовлетворительным.</p>
<p>Вскоре вы приходите к выводу, что класс PersonInfo был спроектирован для печати полей базы данных в различных форматах, с выделением начала и конца каждого поля специальными строками-разделителями. По умолчанию открывающим и закрывающим разделителями служат квадратные скобки, поэтому значение поля «Ring-tailed Lemur» будет отформатировано так:</p>
<empty-line/><p><code>[Ring-tailed Lemur]</code></p>
<empty-line/><p>Учитывая тот факт, что квадратные скобки не всегда приемлемы для пользователей PersonInfo, в классе предусмотрены виртуальные функции valeDelimOpen и valeDelimClose, позволяющие производным классам задать другие открывающие и закрывающие строки-разделители. Функции-члены PersonInfo вызывают эти виртуальные функции для добавления разделителей к возвращаемым значениям. Так, функция PersonInfo::theName могла бы выглядеть следующим образом:</p>
<empty-line/><p><code>const char *PersonInfo::valueDelimOpen() const</code></p>
<p><code>{</code></p>
<p><code>return “[“; // открывающий разделитель по умолчанию</code></p>
<p><code>}</code></p>
<p><code>const char *PersonInfo::valueDelimClose() const</code></p>
<p><code>{</code></p>
<p><code>return “]“; // закрывающий разделитель по умолчанию</code></p>
<p><code>}</code></p>
<p><code>const char * PersonInfo::theName() const</code></p>
<p><code>{</code></p>
<p><code>// резервирование буфера для возвращаемого значения; поскольку он</code></p>
<p><code>// статический, автоматически инициализируется нулями</code></p>
<p><code>static char value[Max_Formatted_Field_Value_Length];</code></p>
<p><code>// скопировать открывающий разделитель</code></p>
<p><code>std::strcpy(value, valueDelimOpen());</code></p>
<p><code><emphasis>добавить к строке value значение из поля name объекта (будьте осторожны –</emphasis></code></p>
<p><code><emphasis>избегайте переполнения буфера!)</emphasis></code></p>
<p><code>// скопировать закрывающий разделитель</code></p>
<p><code>std::strcpy(value, valueDelimClose());</code></p>
<p><code>return value;</code></p>
<p><code>}</code></p>
<empty-line/><p>Кто-то может посетовать на устаревший подход к реализации PersonInfo::theName (особенно это касается использования статического буфера фиксированного размера, опасного возможностью переполнения и потенциальными проблемами в многопоточной среде – см. правило 21), но оставим этот вопрос в стороне и сосредоточимся вот на чем: функция theName вызывает valueDelimOpen для получения открывающего разделителя, вставляемого в возвращаемую строку, затем дописывает имя и в конце вызывает valueDelimClose.</p>
<p>Поскольку valueDelimOpen и valueDelimClose – виртуальные функции, возвращаемый результат theName зависит не только от PersonInfo, но и от классов, производных от него.</p>
<p>Для разработчика CPerson это хорошая новость, потому что, внимательно просматривая документацию по функциям печати из класса IPerson, вы обнаруживаете, что функции name и birthDate должны возвращать неформатированные значения, то есть без добавления разделителей. Другими словами, если человека зовут Homer, то вызов функции name должен возвращать «Homer», а не «[Homer]».</p>
<p>Взаимосвязь между CPerson и PersonInfo можно описать так: PersonInfo упрощает реализацию некоторых функций CPerson. И это все! Стало быть, речь идет об отношении «реализован посредством», и, как мы знаем, такое отношение можно представить двумя способами: с помощью композиции (см. правило 38) или закрытого наследования (см. правило 39). В правиле 39 отмечено, что композиция в общем случае более предпочтительна, но если нужно переопределять виртуальные функции, то требуется наследование. В данном случае CPerson должен переопределить valueDelimOpen и valueDelimClose – задача, которая с помощью композиции не решается. Самое очевидное решение – применить закрытое наследование CPerson от PersonInfo, хотя, как объясняется в правиле 39, это потребует несколько больше работы. Можно также при реализации CPerson воспользоваться сочетанием композиции и наследования с целью переопределения виртуальных функций PersonInfo. Но мы остановимся просто на закрытом наследовании.</p>
<p>Однако CPerson также должен реализовать интерфейс IPerson, а для этого требуется открытое наследование. Вот мы и пришли к множественному наследованию: сочетанию открытого наследования интерфейса с закрытым наследованием реализации:</p>
<empty-line/><p><code>class IPerson { // класс описывает интерфейс,</code></p>
<p><code>public: // который должен быть реализован</code></p>
<p><code>virtual ~IPerson();</code></p>
<p><code>virtual std::string name() const = 0;</code></p>
<p><code>virtual std::string birthDate() const = 0;</code></p>
<p><code>};</code></p>
<p><code>class DatabaseID {...}; // используется далее;</code></p>
<p><code>// детали не существенны</code></p>
<p><code>class PersonInfo { // в этом классе имеет функции,</code></p>
<p><code>public: // помогающие при реализации</code></p>
<p><code>explicit PersonInfo(DatabaseID pid) // интерфейса IPerson</code></p>
<p><code>virtual ~PersonInfo();</code></p>
<p><code>virtual const char *theName() const;</code></p>
<p><code>virtual const char *theBirthDate() const;</code></p>
<p><code>virtual const char *valeDelimOpen() const;</code></p>
<p><code>virtual const char *valeDelimClose() const;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class CPerson: public IPerson, private PersonInfo { // используется</code></p>
<p><code>public: // множественное</code></p>
<p><code>explicit CPerson(DatabaseID pid): PersonInfo(pid) {} // наследование</code></p>
<p><code>virtual std::string name() const // реализации</code></p>
<p><code>{ return PersonInfo::theName();} // функций-членов</code></p>
<p><code>// из интерфейса</code></p>
<p><code>// IPerson</code></p>
<p><code>virtual std::string birthDate() const</code></p>
<p><code>{ return PersonInfo::theBirthDate();}</code></p>
<p><code>private: // переопределения</code></p>
<p><code>const char * valeDelimOpen() const { return “”;} // унаследованных</code></p>
<p><code>const char * valeDelimClose() const { return “”;} // виртуальных</code></p>
<p><code>}; // функций,</code></p>
<p><code>// возвращающих</code></p>
<p><code>// строки-разделители</code></p>
<empty-line/><p>В нотации UML это решение выглядит так:</p>
<image l:href="#i_012.png"/><p>Рассмотренный пример показывает, что множественное наследование может быть и удобным, и понятным.</p>
<p>Замечу, что множественное наследование – просто еще один инструмент в объектно-ориентированном инструментарии. По сравнению с одиночным наследованием оно несколько труднее для понимания и применения, поэтому если вы можете спроектировать программу с одним лишь одиночным наследованием, который более или менее эквивалентен варианту с множественным наследованием, то, скорее всего, предпочтение следует отдать первому подходу. Если вам кажется, что единственно возможный вариант дизайна требует применения множественного наследования, то рекомендую как следует подумать – почти наверняка найдется способ обойтись одиночным. В то же время иногда множественное наследование – это самый ясный, простой для сопровождения и разумный способ достижения цели. В таких случаях не бойтесь применять его. Просто делайте это, тщательно обдумав все последствия.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Множественное наследование сложнее одиночного. Оно может привести к неоднозначности и необходимости применять виртуальное наследование.</p>
<p>• Цена виртуального наследования – дополнительные затраты памяти, снижение быстродействия и усложнение операций инициализации и присваивания. На практике его разумно применять, когда виртуальные базовые классы не содержат данных.</p>
<p>• Множественное наследование вполне законно. Один из сценариев включает комбинацию открытого наследования интерфейсного класса и закрытого наследования класса, помогающего в реализации.</p>
</section></section><section><title><p>Глава 7</p>
<p>Шаблоны и обобщенное программирование</p>
</title><section><p>Изначально шаблоны в C++ появились для того, чтобы можно было реализовать безопасные относительно типов контейнеры: vector, list, map и им подобные. Однако по мере обретения опыта работы с шаблонами стали обнаруживаться все новые и новые способы их применения. Контейнеры были хороши сами по себе, но обобщенное программирование – возможность писать код, не зависящий от типа объектов, которыми он манипулирует, – оказалось еще лучше. Примерами такого программирования являются алгоритмы STL, такие как for_each, find и merge. В конечном итоге выяснилось, что механизм шаблонов C++ сам по себе является машиной Тьюринга: он может быть использован для вычисления любых вычисляемых значений. Это привело к метапрограммированию шаблонов: созданию программ, которые исполняются внутри компилятора C++ и завершают свою работу вместе с окончанием компиляции. В наши дни контейнеры – это лишь малая толика того, на что способны шаблоны C++. Но, несмотря на огромное разнообразие применений, в основе программирования шаблонов лежит небольшое число базовых идей. Именно им и посвящена настоящая глава.</p>
<p>Я не ставлю себе целью сделать из вас эксперта по программированию шаблонов, но, прочитав эту главу, вы станете лучше разбираться в этом вопросе. К тому же в ней достаточно информации для того, чтобы раздвинуть границы ваших представлений о программировании шаблонов – настолько широко, насколько вы пожелаете.</p>
</section><section><title><p>Правило 41: Разберитесь в том, что такое неявные интерфейсы и полиморфизм на этапе компиляции</p>
</title><p>В мире объектно-ориентированного программирования преобладают <emphasis>явные</emphasis> интерфейсы и полиморфизм на этапе исполнения. Например, рассмотрим следующий (бессмысленный) класс:</p>
<empty-line/><p><code>class Widget {</code></p>
<p><code>public:</code></p>
<p><code>Widget();</code></p>
<p><code>virtual ~Widget();</code></p>
<p><code>virtual std::size_t size() const;</code></p>
<p><code>virtual void normalize();</code></p>
<p><code>void swap(Widget&amp; other); // см. правило 25</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>и столь же бессмысленную функцию:</p>
<empty-line/><p><code>void doProcessing(Widget&amp; w)</code></p>
<p><code>{</code></p>
<p><code>if(w.size() &gt; 10 &amp;&amp; w != someNastyWidget) {</code></p>
<p><code>Widget temp(w);</code></p>
<p><code>temp.normalize();</code></p>
<p><code>temp.swap(w);</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/><p>Вот что мы можем сказать о переменной w в функции doProcessing:</p>
<p>• Поскольку объявлено, что переменная w имеет тип Widget, то w должна поддерживать интерфейс Widget. Мы можем найти точное описание этого интерфейса в исходном коде (например, в заголовочном файле для Widget), поэтому я называю его <emphasis>явным интерфейсом</emphasis> – явно присутствующим в исходном коде программы.</p>
<p>• Поскольку некоторые из функций-членов Widget являются виртуальными, то вызовы этих функций посредством w являются примером полиморфизма времени исполнения: конкретная функция, которую нужно вызвать, определяется во время исполнения на основании динамического типа w (см. правило 37).</p>
<p>Мир шаблонного и обобщенного программирования принципиально отличается. В этом мире явные интерфейсы и полиморфизм времени исполнения продолжают существовать, но они менее важны. Вместо них на передний план выходят <emphasis>неявные интерфейсы</emphasis> и <emphasis>полиморфизм времени компиляции.</emphasis> Чтобы понять, что это означает, посмотрите, что произойдет, если мы превратим функцию doProcessing в шаблон функции:</p>
<empty-line/><p><code>template&lt;typename T&gt;</code></p>
<p><code>void doProcessing(T&amp; w)</code></p>
<p><code>{</code></p>
<p><code>if(w.size() &gt; 10 &amp;&amp; w != someNastyWidget) {</code></p>
<p><code>T temp(w);</code></p>
<p><code>temp.normalize();</code></p>
<p><code>temp.swap(w);</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/><p>Что теперь можно сказать о переменной w в шаблоне doProcessing?</p>
<p>• Теперь интерфейс, который должна поддерживать переменная w, определяется операциями, выполняемыми над w в шаблоне. В данном случае видно, что тип переменной w (а именно T) должен поддерживать функции-члены size, normalize и swap; конструктор копирования (для создания temp), а также операцию сравнения на равенство (для сравнения с someNastyWidget). Скоро мы увидим, что это не совсем точно, но на данный момент достаточно. Важно, что набор выражений, которые должны быть корректны для того, чтобы шаблон компилировался, представляет собой неявный интерфейс, который тип T должен поддерживать.</p>
<p>• Для успешного вызова функций, в которых участвует w, таких как operator&gt; и operator!=, может потребоваться конкретизировать шаблон. Такая конкретизация происходит во время компиляции. Поскольку конкретизация шаблонов функций с разными шаблонными параметрами приводит к вызову разных функций, мы называем это <emphasis>полиморфизмом времени компиляции.</emphasis></p>
<p>Даже если вы никогда не пользовались шаблонами, разница между полиморфизмом времени исполнения и полиморфизмом времени компиляции должна быть вам знакома, поскольку она напоминает разницу между процедурой определения того, какую из перегруженных функций вызывать (это происходит во время компиляции) и динамическим связыванием при вызове виртуальных функций (которое происходит во время исполнения). Однако разница между явными и неявными интерфейсами – понятие, характерное только для шаблонов, поэтому остановимся на нем более подробно.</p>
<p>Явные интерфейсы обычно состоят из сигнатур функций, то есть имен функций, типов параметров, возвращаемого значения и т. д. Так, открытый интерфейс класса Widget</p>
<empty-line/><p><code>class Widget {</code></p>
<p><code>public:</code></p>
<p><code>Widget();</code></p>
<p><code>virtual ~Widget();</code></p>
<p><code>virtual std::size_t size() const;</code></p>
<p><code>virtual void normalize();</code></p>
<p><code>void swap(Widget&amp; other);</code></p>
<p><code>};</code></p>
<empty-line/><p>состоит из конструктора, деструктора и функций size, normalize и swap вместе с типами их параметров, возвращаемых значений и признаков константности (интерфейс также включает генерируемые компилятором конструктор копирования и оператор присваивания – см. правило 5). В состав интерфейса могут входить также typedefbi.</p>
<p>Неявный интерфейс несколько отличается. Он не базируется на сигнатурах функций. Вместо этого он состоит из корректных <emphasis>выражений.</emphasis> Посмотрим еще раз на условия в начале шаблона doProcessing:</p>
<empty-line/><p><code>template&lt;typename T&gt;</code></p>
<p><code>void doProcessing(T&amp; w)</code></p>
<p><code>{</code></p>
<p><code>if(w.size() &gt; 10 &amp;&amp; w != someNastyWidget) {</code></p>
<p><code>...</code></p>
<empty-line/><p>Неявному интерфейсу T (типа переменной w) присущи следующие ограничения:</p>
<p>• Он должен предоставлять функцию-член по имени size, которая возвращает целое значение.</p>
<p>• Он должен поддерживать функцию operator!=, которая сравнивает два объекта типа T. (Здесь мы предполагаем, что someNastyWidget имеет тип T.)</p>
<p>Благодаря возможности перегрузки операторов ни одно из этих требований не должно удовлетворяться в обязательном порядке. Да, T должен поддерживать функцию-член size, хотя стоит упомянуть, что эта функция может быть унаследована от базового класса. Но эта функция не обязана возвращать целочисленный тип. Она даже может вообще не возвращать числовой тип. Вообще-то она даже не обязана возвращать тип, для которого определен operator&gt;! Нужно лишь, чтобы она возвращала объект такого типа X, что может быть вызван operator&gt;, которому передаются параметры типа X и int (потому что 10 имеет тип int). При этом функция operator&gt; может и не принимать параметра, тип которого в точности совпадает с X; достаточно, если тип ее параметра Y может быть неявно преобразован к типу X!</p>
<p>Аналогично не требуется, чтобы тип T поддерживал operator!=, достаточно будет и того, чтобы функция operator!= принимала один объект типа X и один объект типа Y. Если T можно преобразовать в X, а someNastyWidget в Y, то вызов operator!= будет корректным.</p>
<p>(Кстати говоря: мы не принимаем во внимание возможность перегрузки operator&amp;&amp;, в результате которой семантика приведенного выражения может стать уже не конъюнкцией, а чем-то совершенно иным.)</p>
<p>У большинства людей голова идет кругом, когда они начинают задумываться о неявных интерфейсах, но на самом деле ничего страшного в них нет. Неявные интерфейсы – это просто набор корректных выражений. Сами по себе выражения могут показаться сложными, но налагаемые ими ограничения достаточно очевидны.</p>
<empty-line/><p><code>if(w.size() &gt; 10 &amp;&amp; w != someNastyWidget)...</code></p>
<empty-line/><p>Мало что можно сказать об ограничениях, налагаемых функциями size, operator&gt;, operator&amp;&amp; или operator!=, но идентифицировать ограничения всего выражения в целом легко. Условная часть предложения if должна быть булевским выражением, поэтому независимо от конкретных типов результат вычисления (w.size() &gt; 10 &amp;&amp; w!= someNastyWidget) должен быть совместим с bool. Это та часть неявного интерфейса, которую шаблон doProcessing налагает на свой параметр типа T. Кроме того, для работы doProcessing необходимо, чтобы интерфейс типа T допускал обращения к конструктору копирования, а также функциям normalize, size и swap.</p>
<p>Ограничения, налагаемые неявными интерфейсами на параметры шаблона, так же реальны, как ограничения, налагаемые явными интерфейсами на объекты класса: и те, и другие проверяются на этапе компиляции. Вы не можете использовать объекты способами, противоречащими явным интерфейсам их классов (такой код не скомпилируется), и точно так же вы не пытайтесь использовать в шаблоне объект, не поддерживающий неявный интерфейс, которого требует шаблон (опять же, код не скомпилируется).</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• И классы, и шаблоны поддерживают интерфейсы и полиморфизм.</p>
<p>• Для классов интерфейсы определены явно и включают главным образом сигнатуры функций. Полиморфизм проявляется во время исполнения – через виртуальные функции.</p>
<p>• Для параметров шаблонов интерфейсы неявны и основаны на корректных выражениях. Полиморфизм проявляется во время компиляции – через конкретизацию и разрешение перегрузки функций.</p>
</section><section><title><p>Правило 42: Усвойте оба значения ключевого слова typename</p>
</title><p><emphasis>Вопрос: какая разница между «class» и «typename» в следующем объявлении шаблона:</emphasis></p>
<empty-line/><p><code>template &lt;class T&gt; class Widget; // использует “class”</code></p>
<p><code>template &lt;typename T&gt; class Widget; // использует “typename”</code></p>
<empty-line/><p>Ответ: никакой. Когда в шаблоне объявляется параметр типа, class и type-name означают абсолютно одно и то же. Некоторые программисты предпочитают всегда писать class, потому что это слово короче. Другие (включая меня) предпочитают typename, поскольку оно говорит о том, что параметром не обязательно должен быть тип класса. Некоторые разработчики используют typename, когда допускается любой тип, и резервируют слово class для случаев, когда допускается только тип, определяемый пользователем. Но с точки зрения C++, class и typename в объявлении параметра шаблона означают в точности одно и то же.</p>
<p>Однако не всегда в C++ ключевые слова class и typename эквивалентны. Иногда вы обязаны использовать typename. Чтобы понять – когда именно, поговорим о двух типах имен, на которые можно ссылаться в шаблоне.</p>
<p>Предположим, что у нас есть шаблон функции, принимающей в качестве параметра совместимый с STL-контейнер, содержащий объекты, которые могут быть присвоены величинам типа int. Далее предположим, что эта функция просто печатает значение второго элемента. Это не очень содержательная функция, которая к тому же и реализована по-дурацки. Как я уже говорил, она даже не будет компилироваться, но забудьте об этом на время – все это не так глупо, как кажется:</p>
<empty-line/><p><code>template &lt;typename C&gt; // печатает второй</code></p>
<p><code>void print2nd(const C&amp; container) // элемент контейнера</code></p>
<p><code>{ // <emphasis>это некорректный C++!</emphasis></code></p>
<p><code>if (container.size() &gt;= 2) {</code></p>
<p><code>C::const_iterator iter(container.begin()); // получить итератор,</code></p>
<p><code>// указывающий на первый</code></p>
<p><code>// элемент</code></p>
<p><code>++iter; // сместиться на второй</code></p>
<p><code>// элемент</code></p>
<p><code>int value = *iter; // скопировать элемент в int</code></p>
<p><code>std::cout &lt;&lt; value; // напечатать int</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/><p>Я выделил в этой функции две локальные переменные – iter и value. Типом iter является C::const_iterator – он зависит от параметра шаблона C. Имена в шаблоне, которые зависят от параметра шаблона, называются <emphasis>зависимыми именами.</emphasis> Зависимое имя внутри класса я буду называть <emphasis>вложенным зависимым именем.</emphasis> C::const_iterator – это вложенное зависимое имя. Фактически это даже <emphasis>вложенное зависимое имя типа,</emphasis> то есть вложенное имя, которое относится к типу.</p>
<p>Другая локальная переменная в print2nd – value – имеет тип int, а int – это имя, которое не зависит ни от какого параметра шаблона. Такие имена называются <emphasis>независимыми.</emphasis></p>
<p>Вложенные зависимые имена могут стать причиной затруднений на этапе синтаксического анализа исходного текста компилятором. Например, предположим, что мы реализуем print2nd еще более глупо, написав в начале такой код:</p>
<empty-line/><p><code>template &lt;typename C&gt; // печатает второй элемент контейнера</code></p>
<p><code>void print2nd(const C&amp; container) // <emphasis>это некорректный C++!</emphasis></code></p>
<p><code>{</code></p>
<p><code>C::const_iterator *x;</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>Выглядит так, будто мы объявили x как локальную переменную – указатель на C::const_iterator. Но это только видимость, поскольку мы «знаем», что C::const_iterator является типом. А что, если в классе C есть статический член данных по имени const_iterator и что, если x будет именем глобальной переменной? В этом случае приведенный код не будет объявлять локальную переменную, а окажется умножением C::const_iterator на x! Звучит невероятно, но это <emphasis>возможно,</emphasis> и авторы синтаксических анализаторов исходного кода на C++ должны позаботиться обо всех возможных вариантах входных данных, даже самых сумасшедших.</p>
<p>Пока о C ничего не известно, мы не можем узнать, является ли C::const_iterator типом или нет, а во время разбора шаблона print2nd компилятор ничего о C не знает. В C++ предусмотрено правило, разрешающее эту неопределенность: если синтаксический анализатор встречает вложенное зависимое имя в шаблоне, он предполагает, что это <emphasis>не</emphasis> имя типа, если только вы не укажете это явно. По умолчанию вложенные зависимые имена <emphasis>не</emphasis> являются типами. Есть исключение из этого правила, о котором я расскажу чуть ниже.</p>
<p>Имея это в виду, посмотрите опять на начало print2nd:</p>
<empty-line/><p><code>template &lt;typename C&gt;</code></p>
<p><code>void print2nd(const C&amp; container)</code></p>
<p><code>{</code></p>
<p><code>if (container.size() &gt;= 2) {</code></p>
<p><code>C::const_iterator iter(container.begin()); // предполагается, что</code></p>
<p><code>... // это <emphasis>не </emphasis>имя типа</code></p>
<empty-line/><p>Теперь должно быть ясно, почему это некорректный C++. Объявление iter имеет смысл только в случае, если C::const_iterator является типом, но мы не сообщили C++ об этом, потому C++ предполагает, что это не так. Чтобы исправить ситуацию, мы должны сообщить C++, что C::const_iterator – это тип. Для этого мы помещаем ключевое слово typename непосредственно перед ним:</p>
<empty-line/><p><code>template &lt;typename C&gt; // это корректный С++</code></p>
<p><code>void print2nd(const C&amp; container)</code></p>
<p><code>{</code></p>
<p><code>if (container.size() &gt;= 2) {</code></p>
<p><code>typename C::const_iterator iter(container.begin());</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/><p>Общее правило просто: всякий раз, когда вы обращаетесь к вложенному зависимому имени в шаблоне, вы должны предварить его словом typename (скоро я опишу исключение).</p>
<p>Слово typename следует использовать для идентификации только вложенных зависимых имен типов; для других имен оно не применяется. Вот пример шаблона функции, который принимает и контейнер, и итератор для этого контейнера:</p>
<empty-line/><p><code>template &lt;typename C&gt; // допускается typename (как и “class”)</code></p>
<p><code>void f(const C&amp; container, // typename не допускается</code></p>
<p><code>typename C::iterator iter); // typename требуется</code></p>
<empty-line/><p>C не является вложенным зависимым именем типа (оно не вложено внутрь чего-либо, зависимого от параметра шаблона), поэтому его не нужно предварять словом typename при объявлении контейнера, но C::iterator – это вложенное зависимое имя типа, поэтому перед ним следует поставить typename.</p>
<p>Из правила «typename должно предварять вложенные зависимые имена типов» есть исключение: typename не должно предварять вложенные зависимые имена типов в списке базовых классов или в идентификаторе базового класса в списке инициализации членов. Например:</p>
<empty-line/><p><code>template &lt;typename T&gt;</code></p>
<p><code>class Derived: public Base&lt;T&gt;::Nested { // список базовых классов:</code></p>
<p><code>public: // <emphasis>typename не допускается</emphasis></code></p>
<p><code>explicit Derived(int x)</code></p>
<p><code>:Base&lt;T&gt;::Nested(x) // идентификатор базового класса</code></p>
<p><code>{ // в списке инициализации членов:</code></p>
<p><code>// <emphasis>typename не допускается</emphasis></code></p>
<p><code>typename Base&lt;T&gt;::Nested temp; // использование вложенного</code></p>
<p><code>... // зависимого имени типа не как</code></p>
<p><code>} // идентификатора базового</code></p>
<p><code>... // класса в списке инициализации</code></p>
<p><code>}; // членов: <emphasis>typename необходимо</emphasis></code></p>
<empty-line/><p>Такая несогласованность несколько раздражает, но по мере приобретения опыта вы перестанете ее замечать.</p>
<p>Рассмотрим еще один пример использования typename, потому нечто подобное можно встретить в реальном коде. Предположим, что мы пишем шаблон функции, которая принимает итератор, и хотим сделать локальную копию – temp – объекта, на который этот итератор указывает. Это можно сделать примерно так:</p>
<empty-line/><p><code>template &lt;typename IterT&gt;</code></p>
<p><code>void workWithIterator(IterT iter)</code></p>
<p><code>{</code></p>
<p><code>typename std::iterator_traits&lt;IterT&gt;::value_type temp(*iter);</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>Не пугайтесь при виде выражения std::iterator_traits&lt;IterT&gt;::value_type. Здесь просто используются стандартные классы-характеристики (traits) (см. правило 47). Так, на C++ говорят «тип того, на что указывает объект типа *IterT». В этом предложении объявлена локальная переменная (temp) того же типа, что и объекты, на которые указывает IterT, а затем она инициализирована значением, на которое указывает iter. Если IterT будет типа vector&lt;int&gt;::iterator, то temp будет иметь тип int. Если же IterT будет типа vector&lt;string&gt;::iterator, то temp будет иметь тип string. Поскольку std::iterator_traits&lt;IterT&gt;::value_type – это вложенное зависимое имя типа (value_type вложено внутрь iterator_traits&lt;IterT&gt;, а IterT – параметр шаблона), мы должны предварить его словом typename.</p>
<p>Если вам неприятно даже видеть выражение std::iterator_traits&lt;IterT&gt;::value_type, представьте, каково набирать его на клавиатуре. Если вы, как и большинство программистов, считаете, что набрать такое более одного раза немыслимо, определите псевдоним для этого типа посредством typedef. Для имен членов классов-характеристик, к каковым относится value_type, (см. в правиле 47 информацию о классах-характеристиках), принято соглашение, согласно которому имя typedef должно совпадать с именем члена. Таким образом, определение локального typedef обычно выглядит так:</p>
<empty-line/><p><code>template &lt;typename IterT&gt;</code></p>
<p><code>void workWithIterator(IterT iter)</code></p>
<p><code>{</code></p>
<p><code>typedef typename std::iterator_traits&lt;IterT&gt;::value_type value_type;</code></p>
<p><code>value_type temp(*iter);</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>Многих программистов соседство typedef и typename поначалу раздражает, но это логическое следствие из правила обращения к вложенным зависимым именам типов. Вы скоро привыкнете. К тому же у вас есть на то веские причины. Сколько раз вы готовы напечатать std::iterator_traits&lt;IterT&gt;::value_type?</p>
<p>В качестве заключительного замечания я должен упомянуть, что не все компиляторы настаивают на строгом выполнении правил, касающихся ключевого слова typename. Некоторые принимают код, в котором typename требуется, но пропущено; некоторые принимают код, где typename присутствует, но не допускается; и некоторые (обычно это касается старых компиляторов) отвергают typename даже там, где оно необходимо. Это значит, что взаимосвязи между typename и вложенными зависимыми имен типов могут стать причиной некоторых не очень серьезных ошибок при переносе программ на другую платформу.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• В объявлениях параметров шаблона ключевые слова class и typename взаимозаменяемы.</p>
<p>• Используйте typename для идентификации вложенных зависимых имен типов, если они не встречаются в списке базовых классов или в качестве идентификатора базового класса в списках инициализации членов.</p>
</section><section><title><p>Правило 43: Необходимо знать, как обращаться к именам в шаблонных базовых классах</p>
</title><p>Предположим, что нам нужно написать программу, которая будет посылать сообщения нескольким компаниям. Сообщения должны отправляться как в зашифрованной форме, так и в форме открытого текста. Если во время компиляции у нас достаточно информации для определения того, какие сообщения должны быть отправлены каким компаниям, то мы можем прибегнуть к решению, основанному на шаблонах:</p>
<empty-line/><p><code>class CompanyA {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>void sendClearText(const std::string&amp; msg);</code></p>
<p><code>void sendEncryptedText(const std::string&amp; msg);</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class CompanyB{</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>void sendClearText(const std::string&amp; msg);</code></p>
<p><code>void sendEncryptedText(const std::string&amp; msg);</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>... // классы для других компаний</code></p>
<p><code>class MsgInfo {...}; // класс, содержащий информацию,</code></p>
<p><code>// используемую для создания</code></p>
<p><code>// сообщения</code></p>
<p><code>template&lt;typename Company&gt;</code></p>
<p><code>class MsgSender {</code></p>
<p><code>public:</code></p>
<p><code>... // конструктор, деструктор и т. п.</code></p>
<p><code>void sendClear(const MsgInfo&amp; info)</code></p>
<p><code>{</code></p>
<p><code>std::string msg;</code></p>
<p><code><emphasis>создать msg из info</emphasis></code></p>
<p><code>Company c;</code></p>
<p><code>c.sendClearText(msg);</code></p>
<p><code>}</code></p>
<p><code>void sendSecret(const MsgInfo&amp; info) // аналогично sendClear, но вызывает</code></p>
<p><code>{...} // c.sendEncrypted</code></p>
<p><code>};</code></p>
<empty-line/><p>Эта программа будет работать. Но предположим, что иногда мы хотим протоколировать некоторую информацию при отправке сообщений. Такую возможность легко добавить, написав производный класс, и, на первый взгляд, разумно это сделать следующим образом:</p>
<empty-line/><p><code>template &lt;typename Company&gt;</code></p>
<p><code>class LoggingMsgSender: public MsgSender&lt;Company&gt; {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>void sendClearMsg(const MsgInfo&amp; info)</code></p>
<p><code>{</code></p>
<p><code><emphasis>записать в протокол перед отправкой;</emphasis></code></p>
<p><code>sendClear(info); // вызвать функцию из базового класса</code></p>
<p><code>// <emphasis>этот код не будет компилироваться!</emphasis></code></p>
<p><code><emphasis>записать в протокол после отправки;</emphasis></code></p>
<p><code>}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Отметим, что функция, отправляющая сообщение, в производном классе называется иначе (sendClearMsg), чем в базовом (sendClear). Это хорошее решение, потому что таким образом мы обходим проблему сокрытия унаследованных имен (см. правило 33), а равно сложности, возникающие при переопределении наследуемых невиртуальных функций (см. правило 36). Но этот код не будет компилироваться, по крайней мере, компилятором, совместимым со стандартом. Такой компилятор решит, что функции sendClear не существует. Мы видим, что эта функция определена в базовом классе, но компилятор не станет искать ее там. Попытаемся понять – почему.</p>
<p>Проблема в том, что когда компилятор встречает определение шаблона класса LoggingMsgSender, он не знает, какому классу тот наследует. Понятно, что классу MsgSender&lt;Company&gt;, но Company – параметр шаблона, который не известен до момента конкретизации LoggingMsgSender. Не зная, что такое Company, невозможно понять, как выглядит класс MsgSender&lt;Company&gt;. В частности, не существует способа узнать, есть ли в нем функция sendClear.</p>
<p>Чтобы яснее почувствовать, в чем сложность, предположим, что у нас есть класс CompanyZ, описывающий компанию, которая настаивает на том, чтобы все сообщения шифровались:</p>
<empty-line/><p><code>class CompanyZ { // этот класс не представляет</code></p>
<p><code>public: // функции sendCleartext</code></p>
<p><code>...</code></p>
<p><code>void sendEncrypted(const std::string&amp; msg);</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Общий шаблон MsgSender не подходит для CompanyZ, потому что в нем определена функция sendClear, которая для объектов класса CompanyZ не имеет смысла. Чтобы решить эту проблему, мы можем создать специализированную версию MsgSender для CompanyZ:</p>
<empty-line/><p><code>template &lt;&gt; // полная специализация MsgSender;</code></p>
<p><code>class MsgSender &lt;CompanyZ&gt; { // отличается от общего шаблона</code></p>
<p><code>public: // только отсутствием функции</code></p>
<p><code>... // sendCleartext</code></p>
<p><code>void sendSecret(const MsgInfo&amp; info)</code></p>
<p><code>{...}</code></p>
<p><code>};</code></p>
<empty-line/><p>Обратите внимание на синтаксическую конструкцию «template&lt;&gt;» в начале определения класса. Она означает, что это и не шаблон, и не автономный класс. Это специализированная версия шаблона MsgSender, которая должна использоваться, если параметром шаблона является CompanyZ. Называется это <emphasis>полной специализацией шаблона</emphasis> : шаблон MsgSender специализирован для типа CompanyZ, и эта специализация применяется, коль скоро в качестве параметра указан тип CompanyZ, никакие другие особенности параметров шаблона во внимание не принимаются.</p>
<p>Имея специализацию шаблона MsgSender для CompanyZ, снова рассмотрим производный класс LoggingMsgSender:</p>
<empty-line/><p><code>template &lt;typename Company&gt;</code></p>
<p><code>class LoggingMsgSender: public MsgSender&lt;Company&gt; {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>void sendClearMsg(const MsgInfo&amp; info)</code></p>
<p><code>{</code></p>
<p><code><emphasis>записать в протокол перед отправкой;</emphasis></code></p>
<p><code>sendClear(info); // если Company == CompanyZ,</code></p>
<p><code>// то этой функции не существует</code></p>
<p><code><emphasis>записать в протокол после отправки;</emphasis></code></p>
<p><code>}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Как следует из комментария, этот код просто не имеет смысла, если базовым классом является MsgSender&lt;CompanyZ&gt;, так как в нем нет функции sendClear. Поэтому C++ отвергнет такой вызов; компилятор понимает, что шаблон базового класса можно специализировать, и интерфейс, предоставляемый этой специализацией, может быть не таким, как в общем шаблоне. В результате компилятор обычно не ищет унаследованные имена в шаблонных базовых классах. В некотором смысле, когда мы переходим от «объектно-ориентированного C++» к «C++ с шаблонами» (см. правило 1), наследование перестает работать.</p>
<p>Чтобы исправить ситуацию, нужно как-то заставить C++ отказаться от догмы «не заглядывай в шаблонные базовые классы». Добиться этого можно тремя способами. Во-первых, можно предварить обращения к функциям из базового класса указателем this:</p>
<empty-line/><p><code>template &lt;typename Company&gt;</code></p>
<p><code>class LoggingMsgSender: public MsgSender&lt;Company&gt; {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>void sendClearMsg(const MsgInfo&amp; info)</code></p>
<p><code>{</code></p>
<p><code><emphasis>записать в протокол перед отправкой</emphasis></code></p>
<p><code>;</code></p>
<p><code>this-&gt;sendClear(info); // порядок! Предполагается, что</code></p>
<p><code>// sendClear будет унаследована</code></p>
<p><code><emphasis>записать в протокол после отправки</emphasis></code></p>
<p><code>;</code></p>
<p><code>}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Во-вторых, можно воспользоваться using-объявлением. Мы уже обсуждали эту тему в правиле 33, где было сказано, что using-объявлением делает скрытые имена из базового класса видимыми в производном классе. Поэтому мы можем переписать sendClearMsg следующим образом:</p>
<empty-line/><p><code>template &lt;typename Company&gt;</code></p>
<p><code>class LoggingMsgSender: public MsgSender&lt;Company&gt; {</code></p>
<p><code>public:</code></p>
<p><code>using MsgSender&lt;Company&gt;::sendClear; // сообщает компилятору о том, что</code></p>
<p><code>... // sendClear есть в базовом классе</code></p>
<p><code>void sendClearMsg(const MsgInfo&amp; info)</code></p>
<p><code>{</code></p>
<p><code>...</code></p>
<p><code>sendClear(info); // нормально, предполагается, что</code></p>
<p><code>... // sendClear будет унаследована</code></p>
<p><code>}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Хотя using-объявление будет работать как здесь, так и в правиле 33, но используются они для решения разных задач. Здесь проблема не в том, что имена из базового класса скрыты за именами, объявленными в производном классе, а в том, что компилятор вообще не станет производить поиск в области видимости базового класса, если только вы явно не попросите его об этом.</p>
<p>И последний способ заставить ваш код компилироваться – явно указать, что вызываемая функция находится в базовом классе:</p>
<empty-line/><p><code>template &lt;typename Company&gt;</code></p>
<p><code>class LoggingMsgSender: public MsgSender&lt;Company&gt; {</code></p>
<p><code>pubilc:</code></p>
<p><code>...</code></p>
<p><code>void sendClearMsg(const MsgInfo&amp; info)</code></p>
<p><code>{</code></p>
<p><code>...</code></p>
<p><code>MsgSender&lt;Company&gt;::sendClear(info); // нормально, предполагается, что</code></p>
<p><code>... // sendClear будет унаследована</code></p>
<p><code>}</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Но этот способ хуже прочих, посколько если вызываемая функция виртуальна, то явная квалификация отключает динамическое связывание.</p>
<p>С точки зрения видимости имен, все три подхода эквивалентны: они обещают компилятору, что любая специализация шаблона базового класса будет поддерживать интерфейс, предоставленный общим шаблоном. Такое обещание – это все, что необходимо компилятору во время синтаксического анализа производного шаблонного класса, подобного LoggingMsgSender, но если данное обещание не будет выполнено, истина всплывет позже. Например, если в программе есть такой код:</p>
<empty-line/><p><code>LoggingMsgSender&lt;CompanyZ&gt; zMsgSender;</code></p>
<p><code>MsgInfo msgData;</code></p>
<p><code>... // поместить info в msgData</code></p>
<p><code>zMsgSender.sendClearMsg(msgData); // ошибка! не скомпилируется</code></p>
<empty-line/><p>то вызов sendClearMsg не скомпилируется, потому что в этой точке компилятор знает, что базовый класс – это специализация шаблона MsgSender&lt;CompanyZ&gt; и в нем нет функции sendClear, которую sendClearMsg пытается вызвать.</p>
<p>Таким образом, суть дела в том, когда компилятор диагностирует неправильные обращения к членам базового класса – раньше (когда анализируются определения шаблонов производного класса) или позже (когда эти шаблоны конкретизируются переданными в шаблон аргументами). C++ предпочитает раннюю диагностику, и поэтому предполагает, что о содержимом базовых классов, конкретизируемых из шаблонов, не известно ничего.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• В шаблонах производных классов ссылки на имена из шаблонов базовых классов осуществляются с помощью префикса «this-&gt;», using-объявления либо посредством явного указания базового класса.</p>
</section><section><title><p>Правило 44: Размещайте независимый от параметров код вне шаблонов</p>
</title><p>Шаблоны – чудесный способ сэкономить время и избежать дублирования кода. Вместо того чтобы вводить код 20 похожих классов, в каждом из которых по 15 функций-членов, вы набираете текст одного шаблона и поручаете компилятору сгенерировать 20 конкретных классов и все 300 необходимых вам функций. (Функции-члены шаблонов классов неявно генерируются, только когда программа к ним обращается, поэтому все 300 функций-членов вы получите, лишь если будете все их использовать.) Шаблоны функций не менее привлекательны. Вместо написания множества однотипных функций вы пишете один шаблон и позволяете компиляторам проделать все остальное. Ну разве не восхитительная технология?</p>
<p>Да… иногда. Если вы не будете внимательны, то использование шаблонов может привести к <emphasis>разбуханию</emphasis> кода. Так называется дублирование в двоичной программе кода, данных или того и другого. В результате компактный и лаконичный исходный код в объектном виде становится громоздким и тяжелым. Хорошего в этом мало, поэтому нужно знать, как избежать такой неприятности.</p>
<p>Основной инструмент для этого – анализ <emphasis>общности и изменчивости</emphasis> имен, но в самой этой идее нет ничего необычного. Даже если вы никогда в жизни не писали шаблонов, таким анализом вам приходится заниматься постоянно.</p>
<p>Когда вы пишете функцию и обнаруживаете, что некоторая часть ее реализации мало чем отличается от реализации другой функции, разве вы дублируете код? Конечно, нет. Вы исключаете общую часть из обеих функций, помещаете ее в третью, а первые две вызывают эту третью функцию. Иными словами, вы анализируете эти две функции на предмет выявления общих и отличающихся частей, перемещаете общие части в новую функцию, а отличающиеся части оставляете на месте. Аналогично, если вы пишете класс и выясняется, что некоторые части этого класса в точности совпадают с частями другого класса, вы не станете их дублировать, а просто вынесете общие части в новый класс, а затем воспользуетесь наследованием или композицией (см. правила 32, 38 и 39), предоставив исходному классу доступ к общим средствам. Отличающиеся части исходных классов остаются на месте.</p>
<p>При написании шаблонов выполняется такой же анализ, и способы борьбы с дублированием аналогичны. Однако имеются новые особенности. В нешаблонном коде дублирование видно сразу: трудно не заметить повторения кода в двух функциях или классах. В шаблонном коде дублирование не бросается в глаза: есть только одна копия исходного кода шаблона, поэтому вам нужно тренироваться, чтобы легко находить места, где в результате конкретизации шаблона может возникнуть дублирование.</p>
<p>Предположим, например, что вы хотите написать шаблон для квадратных матриц фиксированного размера, которые, помимо всего прочего, поддерживают операцию обращения матрицы.</p>
<empty-line/><p><code>template&lt;typename T, std::size_t n&gt; // шаблон матрицы размерностью n x n,</code></p>
<p><code>class SquareMatrix { // состоящей из объектов типа T;</code></p>
<p><code>public: // см. ниже информацию о параметре size_t</code></p>
<p><code>...</code></p>
<p><code>void invert(); // обращение матрицы на месте</code></p>
<p><code>};</code></p>
<empty-line/><p>Этот шаблон принимает параметр типа T, а также параметр типа size_t, <emphasis>не являющийся типом.</emphasis> Параметры, не являющиеся типами, используются реже, чем параметры-типы, но они совершенно законны и, как в данном примере, могут быть вполне естественными.</p>
<p>Теперь рассмотрим такой код:</p>
<empty-line/><p><code>SquareMatrix&lt;double, 5&gt; sm1;</code></p>
<p><code>...</code></p>
<p><code>sm1.invert(); // вызов SquareMatrix&lt;double, 5&gt;::invert()</code></p>
<p><code>SquareMatrix&lt;double, 10&gt; sm2;</code></p>
<p><code>...</code></p>
<p><code>sm2.invert(); // вызов SquareMatrix&lt;double, 10&gt;::invert()</code></p>
<empty-line/><p>Здесь будут конкретизированы две копии функции invert. Они не идентичны, потому что одна из них работает с матрицами 5x5, а другая – с матрицами 10x10, но во всем остальном, кроме констант 5 и 10, эти функции ничем не отличаются. Это – классический пример разбухания кода в результате применения шаблонов.</p>
<p>Что вы делаете, когда есть две функции, абсолютно одинаковые, за исключением того, что в одной используется константа 5, а в другой – 10? Естественно, вы создаете функцию, которая принимает параметр, а затем вызываете ее, один раз передавая в качестве параметра 5, а другой раз – 10. Вот первая попытка проделать тот же трюк в реализации шаблона SquareMatrix:</p>
<empty-line/><p><code>template&lt;typename T&gt; // базовый класс, не зависящий</code></p>
<p><code>class SquareMatrixBase { // от размерности матрицы</code></p>
<p><code>protected:</code></p>
<p><code>...</code></p>
<p><code>void invert(std::size_t matrixSize); // обратить матрицу заданной</code></p>
<p><code>... // размерности</code></p>
<p><code>};</code></p>
<p><code>template&lt;typename T, std::size_t n&gt;</code></p>
<p><code>class SquareMatrix: private SquareMatrixBase&lt;T&gt; {</code></p>
<p><code>private:</code></p>
<p><code>using SquareMatrixBase&lt;T&gt;::invert; // чтобы избежать сокрытия базовой</code></p>
<p><code>// версии invert; см. правило 33</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>void invert() {this-&gt;invert(n);} // встроенный вызов версии invert</code></p>
<p><code>}; // из базового класса</code></p>
<p><code>// см. ниже – почему</code></p>
<p><code>// применяется “this-&gt;”</code></p>
<empty-line/><p>Как видите, параметризованная версия функции invert находится в базовом классе – SquareMatrixBase. Как и SquareMatrix, SquareMatrixBase – шаблон, но в отличие от SquareMatrix, он имеет только один параметр – тип объектов в матрице, но не имеет параметра size. Поэтому все матрицы, содержащие объекты заданного типа, будут разделять общий класс SquareMatrixBase. И, значит, все они разделят единственную копию функции invert из данного класса.</p>
<p>Назначение SquareMatrixBase::invert – помочь избежать дублирования кода в производных классах, поэтому using-объявление помещено в секцию protected, а не public. Дополнительные расходы на вызов этой функции нулевые, поскольку в производных классах ее вызовы invert встроены (встраивание неявное – см. правило 30). Во встроенных функциях применяется нотация «this-&gt;», потому что в противном случае, как следует из правила 43, имена функций из шаблонного базового класса (SquareMatrixBase&lt;T&gt;) будут скрыты от подклассов. Отметим также, что наследование SquareMatrix от SquareMatrixBase – закрытое. Это отражает тот факт, что базовый класс введен только для одной цели – упростить реализацию производных, и не означает наличия концептуального отношения «является» между SquareMatrixBase и SquareMatrix (о закрытом наследовании см. правило 39).</p>
<p>До сих пор все шло хорошо, но имеется одна проблема, которую нам еще предстоит решить. Откуда класс SquareMatrixBase узнает, с какими данными он должен работать? Размерность матрицы ему известна из параметра, но как узнать, где находятся сами данные конкретной матрицы? По-видимому, это известно только производному классу. А как производный класс может передать эту информацию базовому, чтобы тот мог выполнить обращение матрицы?</p>
<p>Один из возможных способов – добавить дополнительный параметр в функцию SquareMatrixBase::invert, скажем, указатель на начало участка памяти, где размещаются данные матрицы. Это будет работать, но, скорее всего, invert – не единственная функция в классе SquareMatrix, которая может быть написана так, что не будет зависеть от размерности, и перенесена в класс SquareMatrixBase. Если таких функций будет несколько, всем им понадобится знать, где находятся данные матрицы. Нам придется в каждую добавлять новый параметр, и получится, что мы многократно передаем SquareMatrixBase одну и ту же информацию. Как-то неправильно это.</p>
<p>Есть альтернатива – хранить указатель на данные матрицы в SquareMatrixBase. И там же можно хранить размерность матрицы. Получается такой код:</p>
<empty-line/><p><code>template&lt;typename T&gt;</code></p>
<p><code>class SquareMatrixBase {</code></p>
<p><code>protected:</code></p>
<p><code>SquareMatrixBase(std::size_t n, T pMem) // сохраняет размерность</code></p>
<p><code>:size(n), pData(pMem){} // и указатель на данные матрицы</code></p>
<p><code>void setData(T *ptr) { pData = ptr;} // присвоить значение pData</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>std::size_t size; // размерность матрицы</code></p>
<p><code>T *pData; // указатель на данные матрицы</code></p>
<p><code>};</code></p>
<empty-line/><p>Это позволяет производным классам решать, как выделять память. Возможна, в частности, реализация, при которой данные матрицы сохраняются прямо в объекте SquareMatrix:</p>
<empty-line/><p><code>template&lt;typename T, size_t size&gt;</code></p>
<p><code>class SquareMatrix: private SquareMatrixBase {</code></p>
<p><code>public:</code></p>
<p><code>SquareMatrix() // передать базовому классу размерность</code></p>
<p><code>:SquareMatrixBase&lt;t&gt;(n, data) {} // матрицы и указатель на данные</code></p>
<p><code>...</code></p>
<p><code>private:</code></p>
<p><code>T data(n*n);</code></p>
<p><code>};</code></p>
<empty-line/><p>Объекты такого типа не нуждаются в динамическом выделении памяти, но зато могут быть очень большими. Вместо этого можно выделять память для данных матрицы из кучи:</p>
<empty-line/><p><code>template&lt;typename T, size_t size&gt;</code></p>
<p><code>class SquareMatrix: private SquareMatrixBase {</code></p>
<p><code>public:</code></p>
<p><code>SquareMatrix() // присвоить указателю на данные</code></p>
<p><code>:SquareMatrixBase&lt;t&gt;(n, 0), // в базовом классе значение null</code></p>
<p><code>pData(new T(n*n)) // выделить память для данных матрицы,</code></p>
<p><code>{this-&gt;setDataPtr(pData.get();} // сохранить указатель на нее и передать</code></p>
<p><code>... // его копию базовому классу</code></p>
<p><code>private:</code></p>
<p><code>boost::scoped_array&lt;T&gt; pData; // о классе boost::scoped_array</code></p>
<p><code>}; // см. правило 13</code></p>
<empty-line/><p>Независимо от того, где хранятся данные, с точки зрения «разбухания» кода важно лишь, что теперь многие (быть может, все) функции-члены SquareMatrix оказываются просто встроенными вызовами их версий из базового класса, которые теперь будут разделяются всеми матрицами, содержащими данные одного и того же типа, независимо от их размера. В то же время объекты SquareMatrix разных размеров относятся к разным типам. Поэтому, несмотря на то что классы SquareMatrix&lt;double, 5&gt; и SquareMatrix&lt;double, 10&gt; пользуются одними и теми же функциями, определенными в SquareMatrixBase&lt;double&gt;, не получится передать функции, ожидающей параметра типа SquareMatrix&lt;double, 10&gt;, объект типа SquareMatrix&lt;double, 5&gt;. Хорошо, не правда ли?</p>
<p>Да, хорошо, но не бесплатно. Для функции invert с жестко «зашитой» в исходный текст размерностью матрицы, скорее всего, был бы сгенерирован более эффективный код, чем разделяемой функции, которой размерность передается в качестве параметра либо хранится в самом объекте. Например, «зашитая» размерность может быть константой времени компиляции, так что к ней будут применимы различные виды оптимизации, в частности встраивание константы непосредственно в машинную команду в виде непосредственного операнда. Для функции, не зависящей от размерности, такой номер не пройдет.</p>
<p>С другой стороны, наличие только одной версии invert для разных размерностей уменьшает объем исполняемого кода, а это, в свою очередь, уменьшит размер рабочего множества программы и улучшит локальность ссылок в кэше команд. Это может ускорить исполнение программы настолько, что все потери эффективности по сравнению с зависящей от размерности версией будут с лихвой компенсированы. Какой эффект окажется доминирующим? Единственный способ получить ответ – попробовать оба варианта и исследовать поведение на вашей конкретной платформе с репрезентативными наборами данных.</p>
<p>Другой фактор, влияющий на эффективность, – это размеры объектов. Если вы не будете внимательны, то перенос независимых от размерности функций в базовый класс может привести к увеличению размера каждого объекта. Например, в только что приведенном коде для каждого объекта SquareMatrix имеется указатель на его данные в классе SquareMatrixBase, несмотря даже на то, что производный класс и так может получить эти данные. Это увеличивает размер каждого объекта SquareMatrix, по крайней мере, на размер указателя. Можно модифицировать класс так, чтобы необходимость в этих указателях отпала, но это компромисс. Например, если завести в базовом классе защищенный член для хранения указателя на данные матрицы, то мы пожертвуем инкапсуляцией (см. правило 22). Это также может привести к усложнению алгоритмов управления ресурсами. Если в базовом классе хранится указатель на данные матрицы, то память для этих данных может быть либо выделена динамически, либо физически находиться внутри объекта производного класса (как мы видели). Так как же базовый класс определит, следует ли удалять указатель? Ответы на такие вопросы существуют, но чем изощреннее ваш дизайн, тем сложнее все получается. В некоторый момент умеренное дублирование кода может даже показаться спасением.</p>
<p>В этом правиле мы обсуждаем только разбухание кода из-за параметров шаблонов, не являющихся типами, но и параметры-типы могут привести к тому же. Например, на многих платформах int и long имеют одно и то же двоичное представление, поэтому функции-члены, скажем, для vector&lt;int&gt; и vector&lt;long&gt;, могут оказаться идентичными – разбухание в чистом виде. Некоторые компоновщики объединяют идентичные реализации функций, а некоторые – нет, и, значит, некоторые шаблоны, конкретизированные для int и для long, на одних платформах приводят к разбуханию, а на других – нет. Аналогично на большинстве платформ все типы указателей имеют одинаковое двоичное представление, поэтому шаблоны с параметрами указательных типов (например, list&lt;int*&gt;, list&lt;const int*&gt;, list&lt;SquareMatrix&lt;long,3&gt;*&gt; и т. п.) зачастую могли бы использовать общие реализации всех функций-членов. Как правило, это означает, что функции-члены, которые работают со строго типизованными указателями (например, T*) должны внутри себя вызывать функции, работающие с нетипизированными указателями (то есть void*). В некоторых реализациях стандартной библиотеки C++ такой подход применен к шаблонам vector, deque и list и им подобным. Если вас беспокоит опасность разбухания кода из-за использования шаблонов, возможно, стоит поступить аналогично.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Шаблоны генерируют множество классов и функций, поэтому любой встречающийся в шаблоне код, который не зависит от параметров шаблона, приводит к разбуханию кода.</p>
<p>• Разбухания из-за параметров шаблонов, не являющихся типами, часто можно избежать, заменив параметры шаблонов параметрами функций или данными-членами класса.</p>
<p>• Разбухание из-за параметров-типов можно ограничить, обеспечив общие реализации для случаев, когда шаблон конкретизируется типами с одинаковым двоичным представлением.</p>
</section><section><title><p>Правило 45: Разрабатывайте шаблоны функций-членов так, чтобы они принимали «все совместимые типы»</p>
</title><p><emphasis>Интеллектуальные указатели</emphasis> – это объекты, которые ведут себя во многом подобно обычным указателям, но добавляют функциональность, которую последние не предоставляют. Например, в правиле 13 объясняется, как можно использовать стандартные классы auto_ptr и tr1::shared_ptr для автоматического удаления динамически выделенных ресурсов в нужное время. Итераторы STL-контейнеров почти всегда являются интеллектуальными указателями. Понятно, что от обычного указателя нельзя ожидать, что он будет сдвигаться на следующий узел связанного списка в результате выполнения операции «++», но итератор списка list::iterator работает именно так.</p>
<p>Для чего обычные указатели хороши – так это для поддержки неявных преобразований типов. Указатели на объекты производных классов неявно преобразуются в указатели на объекты базовых классов, указатели на неконстантные объекты – в указатели на константные и т. п. Например, рассмотрим некоторые преобразования, которые могут происходить в трехуровневой иерархии:</p>
<empty-line/><p><code>class Top {...};</code></p>
<p><code>class Middle: public Top {...};</code></p>
<p><code>class Bottom: public Middle {...};</code></p>
<p><code>Top *pt1 = new Middle; // преобразует Middle* в Top*</code></p>
<p><code>Top *pt2 = new Bottom; // преобразует Middle* в Bottom*</code></p>
<p><code>Const Top *pct2 = pt1; // преобразует Top* в const Top*</code></p>
<empty-line/><p>Эмулировать такие преобразования с помощью определяемых пользователем «интеллектуальных» указателей не просто. Для этого нужно, чтобы компилировался такой код:</p>
<empty-line/><p><code>Template&lt;typename T&gt;</code></p>
<p><code>class SmartPtr {</code></p>
<p><code>public:</code></p>
<p><code>explicit SmartPtr(T *realPtr); // интеллектуальные указатели обычно</code></p>
<p><code>... // инициализируются встроенными</code></p>
<p><code>}; // указателями</code></p>
<p><code>SmartPtr&lt;Top&gt; pt1 = // преобразует SmartPtr&lt;Middle&gt;</code></p>
<p><code>SmartPtr&lt;Middle&gt;(new Middle); // в SmartPtr&lt;Top&gt;</code></p>
<p><code>SmartPtr&lt;Top&gt; pt2 = // преобразует SmartPtr&lt;Bottom&gt;</code></p>
<p><code>SmartPtr&lt;Bottom&gt;(new Bottom); // SmartPtr&lt;Top&gt;</code></p>
<p><code>SmartPtr&lt;const Top&gt; pct2 = pt1;</code></p>
<empty-line/><p>Разные конкретизации одного шаблона не связаны каким-либо отношением, поэтому компилятор считает, что SmartPtr&lt;Middle&gt; и SmartPtr&lt;Top&gt; – совершенно разные классы, не более связанные друг с другом, чем, например, vector&lt;float&gt; и Widget. Чтобы можно было осуществлять преобразования между разными классами SmartPtr, необходимо явно написать соответствующий код. В приведенном выше примере каждое предложение создает новый объект интеллектуального указателя, поэтому для начала сосредоточимся на написании конструкторов, которые будут вести себя так, как нам нужно. Ключевое наблюдение состоит в том, что невозможно написать сразу все необходимые конструкторы. В приведенной иерархии мы можем сконструировать SmartPtr&lt;Top&gt; из SmartPtr&lt;Middle&gt; или SmartPtr&lt;Bottom&gt;, но если в будущем иерархия будет расширена, то придется добавить возможность конструирования объектов SmartPtr&lt;Top&gt; из других типов интеллектуальных указателей. Например, если мы позже добавим такой класс:</p>
<empty-line/><p><code>class BelowBottom: public Bottom {...};</code></p>
<empty-line/><p>то нужно будет поддержать создание объектов SmartPtr&lt;Top&gt; из SmartPtr&lt;Below-Bottom&gt;, и, очевидно, не хотелось бы ради этого модифицировать шаблон SmartPtr.</p>
<p>В принципе, нам может понадобиться неограниченное число конструкторов. Поскольку шаблон может быть конкретизирован для генерации неограниченного числа функций, похоже, что нам нужен не <emphasis>конструктор-функция</emphasis> для SmartPtr, а <emphasis>конструктор-шаблон.</emphasis> Это пример <emphasis>шаблона функции-члена</emphasis> (часто называемого <emphasis>шаблонного члена),</emphasis> то есть шаблона, генерирующего функции-члены класса:</p>
<empty-line/><p><code>template&lt;typename T&gt;</code></p>
<p><code>class SmartPtr {</code></p>
<p><code>public:</code></p>
<p><code>template&lt;typename U&gt; // шаблонный член</code></p>
<p><code>SmartPtr(const SmartPtr&lt;U&gt;&amp; other); // для «обобщенного</code></p>
<p><code>... // конструктора копирования»</code></p>
<p><code>};</code></p>
<empty-line/><p>Здесь говорится, что для каждой пары типов T и U класс SmartPtr&lt;T&gt; может быть создан из SmartPtr&lt;U&gt;, потому что SmartPtr&lt;T&gt; имеет конструктор, принимающий параметр типа SmartPtr&lt;U&gt;. Подобные конструкторы, создающие один объект из другого, тип которого является другой конкретизацией того же шаблона (например, SmartPtr&lt;T&gt; из SmartPtr&lt;U&gt;), иногда называют <emphasis>обобщенными конструкторами копирования.</emphasis></p>
<p>Обобщенный конструктор копирования в приведенном выше примере не объявлен с модификатором explicit. И это сделано намеренно. Преобразования типов между встроенными типами указателей (например, из указателя на производный класс к указателю на базовый класс) происходят неявно и не требуют приведения, поэтому разумно и для интеллектуальных указателей эмулировать такое поведение. Именно поэтому и не указано слово explicit в объявлении обобщенного конструктора шаблона.</p>
<p>Будучи объявлен описанным выше образом, обобщенный конструктор копирования для SmartPtr предоставляет больше, чем нам нужно. Да, мы хотим иметь возможность создавать SmartPtr&lt;Top&gt; из SmartPtr&lt;Bottom&gt;, но вовсе не просили создавать SmartPtr&lt;Bottom&gt; из SmartPtr&lt;Top&gt;, потому что это противоречит смыслу открытого наследования (см. правило 32). Мы также не хотим создавать SmartPtr&lt;int&gt; из SmartPtr&lt;double&gt;, потому что не существует неявного преобразования int* в double*. Каким-то образом мы должны сузить многообразие функций-членов, которые способен генерировать этот шаблон.</p>
<p>Предполагая, что SmartPtr написан по образцу auto_ptr и tr1::shared_ptr, то есть предоставляет функцию-член get, которая возвращает копию встроенного указателя, хранящегося в объекте «интеллектуального» указателя (см. правило 15), мы можем воспользоваться реализацией шаблонного конструктора, чтобы ограничить набор преобразований:</p>
<empty-line/><p><code>template&lt;typename T&gt;</code></p>
<p><code>class SmartPtr {</code></p>
<p><code>public:</code></p>
<p><code>template&lt;typename U&gt;</code></p>
<p><code>SmartPtr(const SmartPtr&lt;U&gt;&amp; other) // инициировать этот хранимый</code></p>
<p><code>:heldPtr(other.get()) {...} // указатель указателем, хранящимся</code></p>
<p><code>// в другом объекте</code></p>
<p><code>T *get() const { return heldPtr;}</code></p>
<p><code>...</code></p>
<p><code>private: // встроенный указатель,</code></p>
<p><code>T *heldPtr; // хранящийся в «интеллектуальном»</code></p>
<p><code>};</code></p>
<empty-line/><p>Мы используем список инициализации членов, чтобы инициализировать член данных SmartPtr&lt;T&gt; типа T* указателем типа U*, который хранится в Smart-Ptr&lt;U&gt;. Этот код откомпилируется только тогда, когда существует неявное преобразование указателя U* в T*, а это как раз то, что нам нужно. Итак, SmartPtr&lt;T&gt; теперь имеет обобщенный копирующий конструктор, который компилируется только тогда, когда ему передается параметр совместимого типа.</p>
<p>Использование шаблонных функций-членов не ограничивается конструкторами. Еще одно полезное применение таких функций – поддержка присваивания. Например, класс shared_ptr из TR1 (см. правило 13) поддерживает конструирование из всех совместимых встроенных указателей, tr1::shared_ptr, auto_ptr и tr1::weak_ptr (см. правило 54), а также наличие в правой части оператора присваивания объекта любого из этих типов, кроме tr1::weak_ptr. Ниже приведен фрагмент спецификации TR1 для tr1::shared_ptr; обратите внимание, что при объявлении параметров шаблона используется ключевое слов class, а не typename. Как объясняется в правиле 42, в данном контексте они означают одно и то же.</p>
<empty-line/><p><code>template&lt;class T&gt; class shared_ptr {</code></p>
<p><code>public:</code></p>
<p><code>template&lt;class Y&gt; // конструирует из</code></p>
<p><code>explicit shared_ptr(Y *p); // любого совместимого</code></p>
<p><code>template&lt;class Y&gt; // встроенного указателя,</code></p>
<p><code>shared_ptr(shared_ptr&lt;Y&gt; const&amp; r); // shared_ptr,</code></p>
<p><code>template&lt;class Y&gt; // weak_ptr или</code></p>
<p><code>explicit shared_ptr(weak_ptr&lt;Y&gt; const&amp; r); // auto_ptr</code></p>
<p><code>template&lt;class Y&gt;</code></p>
<p><code>explicit shared_ptr(auto_ptr&lt;Y&gt;&amp; r);</code></p>
<p><code>template&lt;class Y&gt; // присваивает</code></p>
<p><code>explicit shared_ptr&amp; operator=(shared_ptr&lt;Y&gt; const&amp; r); // любой</code></p>
<p><code>template&lt;class Y&gt; // совместимый</code></p>
<p><code>explicit shared_ptr&amp; operator=(auto_ptr&lt;Y&gt; const&amp; r); // shared_ptr или</code></p>
<p><code>... // auto_ptr</code></p>
<p><code>};</code></p>
<empty-line/><p>Все эти конструкторы объявлены как explicit, за исключением обобщенного конструктора копирования. Это значит, что неявные преобразования от одного типа shared_ptr к другому допускаются, но <emphasis>неявные</emphasis> преобразования от встроенного указателя или другого «интеллектуального» указателя не допускаются. <emphasis>(Явные</emphasis> преобразования – например, с помощью приведения типов – разрешены). Также интересно отметить, что при передаче объекта auto_ptr конструктору tr1::shared_ptr и оператору присваивания параметр указывается без модификатора const, тогда как передаваемые параметры типа tr1::shared_ptr и tr1::weak_ptr константны. Это следствие того факта, что в отличие от других классов объекты auto_ptr модифицируются при копировании (см. правило 13).</p>
<p>Шаблонные функции-члены – чудесная вещь, но они не отменяют основных правил языка. В правиле 5 объясняется, что две из четырех функций-членов, которые компиляторы могут генерировать автоматически, – это конструктор копирования и оператор присваивания. В классе tr1::shared_ptr объявлен обобщенный конструктор копирования, и ясно, что в случае совпадения типов T и Y конкретизация обобщенного конструктора копирования может быть сведена к созданию «обычного» конструктора копирования. Поэтому возникает вопрос, что будет делать компилятор в случае, когда один объект tr1::shared_ptr конструируется из другого объекта того же типа: генерировать обычный конструктор копирования для tr1::shared_ptr или конкретизировать обобщенный конструктор копирования из шаблона?</p>
<p>Как я сказал, шаблонные члены не отменяют основных правил языка, а из этих правил следует, что если конструктор копирования нужен, а вы не объявляете его, то он будет сгенерирован автоматически. Объявление в классе обобщенного конструктора копирования (шаблонного члена) не предотвращает генерацию компилятором обычного конструктора копирования. Поэтому если вы хотите полностью контролировать все аспекты конструирования путем копирования, то должны объявить как обобщенный конструктор копирования, так и обычный. То же касается присваивания. Приведем фрагмент определения класса tr1::shared_ptr, который иллюстрирует это положение:</p>
<empty-line/><p><code>template&lt;class T&gt; class shared_ptr {</code></p>
<p><code>public:</code></p>
<p><code>shared_ptr(shared_ptr const&amp; r); // конструктор копирования</code></p>
<p><code>template&lt;class Y&gt; // обобщенный</code></p>
<p><code>shared_ptr(shared_ptr&lt;Y&gt; const&amp; r); // конструктор копирования</code></p>
<p><code>shared_ptr&amp; operator=(shared_ptr const&amp; r); // оператор присваивания</code></p>
<p><code>template&lt;class Y&gt; // обобщенный оператор</code></p>
<p><code>shared_ptr&amp; operator=(shared_ptr&lt;Y&gt; const&amp; r); // присваивания</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Используйте шаблонные функции-члены для генерации функций, принимающих все совместимые типы.</p>
<p>• Если вы объявляете шаблоны обобщенных конструкторов копирования или обобщенного оператора присваивания, то по-прежнему должны объявить обычный конструктор копирования и оператор присваивания.</p>
</section><section><title><p>Правило 46: Определяйте внутри шаблонов функции, не являющиеся членами, когда желательны преобразования типа</p>
</title><p>В правиле 24 объясняется, почему только к свободным функциям применяются неявные преобразования типов всех аргументов. В качестве примера была приведена функция operator* для класса Rational. Прежде чем продолжить чтение, рекомендую вам освежить этот пример в памяти, потому что сейчас мы вернемся к этой теме, рассмотрев безобидные, на первый взгляд, модификации примера из правила 24. Отличие только в том, что и класс Rational, и operator* в нем сделаны шаблонами:</p>
<empty-line/><p><code>template &lt;typename T&gt;</code></p>
<p><code>class Rational {</code></p>
<p><code>public:</code></p>
<p><code>Rational(const T&amp; numerator = 0, // см. в правиле 20 – почему</code></p>
<p><code>const T&amp; denominator = 1); // параметр передается по ссылке</code></p>
<p><code>const T numerator() const; // см. в правиле 28 – почему</code></p>
<p><code>const T denominator() const; // результат возвращается по</code></p>
<p><code>... // значению, а в правиле 3 –</code></p>
<p><code>// почему они константны</code></p>
<p><code>};</code></p>
<p><code>template &lt;typename T&gt;</code></p>
<p><code>const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs,</code></p>
<p><code>const Rational&lt;T&gt;&amp; rhs)</code></p>
<p><code>{...}</code></p>
<empty-line/><p>Как и в правиле 24, мы собираемся поддерживать смешанную арифметику, поэтому хотелось бы, чтобы приведенный ниже код компилировался. Мы не ожидаем подвохов, потому что аналогичный код в правиле 24 работал. Единственное отличие в том, что класс Rational и функция-член operator* теперь шаблоны:</p>
<empty-line/><p><code>Raional&lt;int&gt; oneHalf(1, 2); // это пример из правила 24,</code></p>
<p><code>// но Rational – теперь шаблон</code></p>
<p><code>Ratinal&lt;int&gt; result = oneHalf * 2; // ошибка! Не компилируется</code></p>
<empty-line/><p>Тот факт, что этот код не компилируется, наводит на мысль, что в шаблоне Rational есть нечто, отличающее его от нешаблонной версии. И это на самом деле так. В правиле 24 компилятор знал, какую функцию мы пытаемся вызвать (operator*, принимающую два параметра типа Rational), здесь же ему об этом ничего не известно. Поэтому компилятор пытается <emphasis>решить,</emphasis> какую функцию нужно конкретизировать (то есть создать) из шаблона operator*. Он знает, что имя этой функции operator* и она принимает два параметра типа Rational&lt;T&gt;, но для того чтобы произвести конкретизацию, нужно выяснить, что такое T. Проблема в том, что компилятор не может этого сделать.</p>
<p>Пытаясь вывести T, компилятор смотрит на типы аргументов, переданных при вызове operator*. В данном случае это Rational&lt;int&gt; (тип переменной oneHalf) и int (тип литерала 2). Каждый параметр рассматривается отдельно.</p>
<p>Вывод на основе типа oneHalf сделать легко. Первый параметр operator* объявлен как Rational&lt;T&gt;, а первый аргумент, переданный operator* (oneHalf), имеет тип Rational&lt;int&gt;, поэтому T должен быть int. К сожалению, вывести тип другого параметра не так просто. Из объявления известно, что тип второго параметра operator* равен Rational&lt;T&gt;, но второй аргумент, переданный функции operator* (число 2), имеет тип int. Как компилятору определить, что есть T в данном случае? Можно ожидать, что он воспользутся не-explicit конструктором, чтобы преобразовать 2 в Rational&lt;int&gt; и таким образом сделать вывод, что T есть int, но на деле этого не происходит. Компилятор не поступает так потому, что функции неявного преобразования типа <emphasis>никогда</emphasis> не рассматриваются при выводе аргументов шаблона. Никогда. Да, такие преобразования используются при вызовах функций, но перед тем, как вызывать функцию, нужно убедиться, что она существуют. Чтобы убедиться в этом, необходимо вывести типы параметров для всех потенциально подходящих шаблонов функций (чтобы можно было конкретизировать правильную функцию). Но неявные преобразования типов посредством вызова конструкторов при выводе аргументов шаблона не рассматриваются. В правиле 24 никаких шаблонов не было, поэтому и проблема вывода аргументов шаблона не возникала. Здесь же мы имеем дело с шаблонной частью C++ (см. правило 1), и она выходит на первый план.</p>
<p>Мы можем помочь компилятору в выводе аргументов шаблона, воспользовавшись объявлением дружественной функции в шаблонном классе. Это означает, что класс Rational&lt;T&gt; может объявить operator* для Rational&lt;T&gt; как функцию-друга. К шаблонам классов процедура вывода аргументов не имеет отношения (она применяется только к шаблонам функций), поэтому тип T всегда известен в момент конкретизации Rational&lt;T&gt;. Это упрощает объявление соответствующей функции operator* как друга класса Rational&lt;T&gt;:</p>
<empty-line/><p><code>template &lt;typename T&gt;</code></p>
<p><code>class Rational {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>friend // объявление функции</code></p>
<p><code>const Rational operator*(const Rational&amp; lhs, // operator*</code></p>
<p><code>const Rational&amp; rhs); // (подробности см. ниже)</code></p>
<p><code>};</code></p>
<p><code>template &lt;typename T&gt; // определение функции</code></p>
<p><code>const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs, // operator*</code></p>
<p><code>const Rational&lt;T&gt;&amp; rhs)</code></p>
<p><code>{...}</code></p>
<empty-line/><p>Теперь вызовы operator* с аргументами разных типов скомпилируются, потому что при объявлении объект oneHalf типа Rational&lt;int&gt; конкретизируется класс Rational&lt;int&gt; и вместе с ним функция-друг operator*, которая принимает параметры Rational&lt;int&gt;. Поскольку объявляется <emphasis>функция</emphasis> (а не <emphasis>шаблон функции),</emphasis> компилятор может для вывода типов параметров пользоваться функциями неявного преобразования (например, не-explicit конструкторами Rational) и, стало быть, сумеет разобраться в вызове operator* с параметрами разных типов.</p>
<p>К сожалению, фраза «сумеет разобраться» в данном контексте имеет иронический оттенок, поскольку хотя код и компилируется, но не компонуется. Вскоре мы займемся этой проблемой, но сначала я хочу сделать одно замечание о синтаксисе, используемом для объявления функции operator* в классе Rational.</p>
<p>Внутри шаблона класса имя шаблона можно использовать как сокращенное обозначение шаблона вместе с параметрами, поэтому внутри Ratonal&lt;T&gt; разрешается писать просто Rational вместо Ratonal&lt;T&gt;. В данном примере это экономит лишь несколько символов, но когда есть несколько параметров с длинными именами, это помогает уменьшить размер исходного кода и одновременно сделать его яснее. Я вспомнил об этом, потому что operator* объявлен как принимающий и возвращающий Rational вместо Rational&lt;T&gt;. Также корректно было бы объявить operator* следующим образом:</p>
<empty-line/><p><code>template &lt;typename T&gt;</code></p>
<p><code>class Rational {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>friend</code></p>
<p><code>const Rational&lt;T&gt; operator*(const Rational&lt;T&gt;&amp; lhs,</code></p>
<p><code>const Rational&lt;T&gt;&amp; rhs);</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Однако проще (и часто так и делается) использовать сокращенную форму.</p>
<p>Теперь вернемся к проблеме компоновки. Код, содержащий вызов с параметрами различных типов, компилируется, потому что компилятор знает, что мы хотим вызвать вполне определенную функцию (operator*, принимающую параметры типа Rational&lt;int&gt; и Rational&lt;int&gt;), но эта функция только <emphasis>объявлена</emphasis> внутри Rational, но не <emphasis>определена</emphasis> там. Наша цель – заставить шаблон функции operator*, не являющейся членом класса, предоставить это определение, но таким образом ее не достичь. Если мы объявляем функцию самостоятельно (а так и происходит, когда она находится внутри шаблона Rational), то должны позаботиться и об ее определении. В данном случае мы нигде не привели определения, поэтому компоновщик его и не находит.</p>
<p>Простейший способ исправить ситуацию – объединить тело operator* с его объявлением:</p>
<empty-line/><p><code>template &lt;typename T&gt;</code></p>
<p><code>class Rational {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>friend Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)</code></p>
<p><code>{</code></p>
<p><code>return Rational(lhs.numerator() * rhs.numerator(), // та же</code></p>
<p><code>lhs.denominator () * rhs.denominator()); // реализация,</code></p>
<p><code>} // что и</code></p>
<p><code>// в правиле 24</code></p>
<p><code>};</code></p>
<empty-line/><p>Наконец-то все работает как нужно: вызовы operator* с параметрами смешанных типов компилируются, компонуются и запускаются. Ура!</p>
<p>Интересное наблюдение, касающееся этой техники: использование отношения дружественности никак не связано с желанием получить доступ к закрытой части класса. Чтобы сделать возможными преобразования типа для всех аргументов, нам нужна функция, не являющаяся членом (см. правило 24); а для того чтобы получить автоматическую конкретизацию правильной функции, нам нужно объявить ее внутри класса. Единственный способ объявить свободную функцию внутри класса – сделать ее другом (friend). Что мы и делаем. Необычно? Да. Эффективно? Вне всяких сомнений.</p>
<p>Как объясняется в правиле 30, функции, определенные внутри класса, неявно объявляются встроенными; это касается и функций-друзей, подобных нашей operator*. Вы можете минимизировать эффект от неявного встраивания, сделав так, чтобы operator* не делала ничего, помимо вызова вспомогательной функции, определенной вне класса. В данном случае в этом нет особой необходимости, потому что функция operator* и так состоит всего из одной строки, но для более сложных функций с телом это может оказаться желательным. Поэтому стоит иметь в виду идиому «иметь друга, вызывающего вспомогательную функцию».</p>
<p>Тот факт, что Rational – это шаблонный класс, означает, что вспомогательная функция обычно также будет шаблоном, поэтому код в заголовочном файле, определяющем Rational, обычно выглядит примерно так:</p>
<empty-line/><p><code>template &lt;typename T&gt; class Ratonal; // объявление</code></p>
<p><code>// шаблона Rational</code></p>
<p><code>template &lt;typename T&gt; // объявление</code></p>
<p><code>const Rational&lt;T&gt; doMultiply(const Rational&lt;T&gt;&amp; lhs, // шаблона</code></p>
<p><code>const Rational&lt;T&gt;&amp; rhs); // вспомогательной</code></p>
<p><code>// функции</code></p>
<p><code>template &lt;typename T&gt;</code></p>
<p><code>class Rational {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>friend</code></p>
<p><code>const Rational operator*( const Rational&amp; lhs,</code></p>
<p><code>const Rational&amp; rhs) // друг объявляет</code></p>
<p><code>{ return doMultiply(lhs, rhs};} // вспомогательную</code></p>
<p><code>... // функцию</code></p>
<p><code>};</code></p>
<empty-line/><p>Многие компиляторы требуют, чтобы все определения шаблонов находились в заголовочных файлах, поэтому может понадобиться определить в заголовке еще и функцию doMultiply. Как объясняется в правиле 30, такие шаблоны не обязаны быть встроенными. Вот как это может выглядеть:</p>
<empty-line/><p><code>template &lt;typename T&gt; // определение шаблона</code></p>
<p><code>const Rational&lt;T&gt; doMultiply( const Rational&lt;T&gt;&amp; lhs, // вспомогательной</code></p>
<p><code>const Rational&lt;T&gt;&amp; rhs) // функции</code></p>
<p><code>{ // в заголовочном файле</code></p>
<p><code>return Rational(lhs.numerator() * rhs.numerator(), // при необходимости</code></p>
<p><code>lhs.denominator () * rhs.denominator());</code></p>
<p><code>}</code></p>
<empty-line/><p>Конечно, будучи шаблоном, doMultiply не поддерживает умножения значений разного типа, но ей это и не нужно. Она вызывается только из operator*, который обеспечивает поддержку параметров смешанного типа! По существу, <emphasis>функция</emphasis> operator* поддерживает любые преобразования типа, необходимые для перемножения объектов класса Rational, а затем передает эти два объекта соответствующей конкретизации <emphasis>шаблона</emphasis> doMultiply, которая и выполняет собственно операцию умножения. Кооперация в действии, не так ли?</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Когда вы пишете шаблон класса, в котором есть функции, нуждающиеся в неявных преобразованиях типа для всех параметров, определяйте такие функции как друзей внутри шаблона класса.</p>
</section><section><title><p>Правило 47: Используйте классы-характеристики для предоставления информации о типах</p>
</title><p>В основном библиотека STL содержит шаблоны контейнеров, итераторов и алгоритмов, но есть в ней и некоторые служебные шаблоны. Один из них называется advance. Шаблон advance перемещает указанный итератор на заданное расстояние:</p>
<empty-line/><p><code>template &lt;typename T, typename DistT&gt; // перемещает итератор iter</code></p>
<p><code>void advance(Iter T&amp; iter, DistT d); // на d элементов вперед</code></p>
<p><code>// если d &lt; 0, то перемещает iter</code></p>
<p><code>// назад</code></p>
<empty-line/><p>Концептуально advance делает то же самое, что предложение iter+=d, но таким способом advance не может быть реализован, потому что только итераторы с произвольным доступом поддерживают операцию +=. Для менее мощных итераторов advance реализуется путем повторения операции ++ или – ровно d раз.</p>
<p>А вы не помните, какие есть категории итераторов в STL? Не страшно, дадим краткий обзор. Существует пять категорий итераторов, соответствующих операциям, которые они поддерживают. <emphasis>Итераторы ввода</emphasis> ( <emphasis>input iterators)</emphasis> могут перемещаться только вперед, по одному шагу за раз, и позволяют читать только то, на что они указывают в данный момент, причем прочитать значение можно лишь один раз. Они моделируют указатель чтения из входного файла. К этой категории относится библиотечный итератор C++ iostream_iterator. <emphasis>Итераторы вывода (output iterators)</emphasis> устроены аналогично, но служат для вывода: перемещаются только вперед, по одному шагу за раз, позволяют записывать лишь в то место, на которое указывают, причем записать можно только один раз. Они моделируют указатель записи в выходной файл. К этой категории относится итератор ostream_iterator. Это самые «слабые» категории итераторов. Поскольку итераторы ввода и вывода могут перемещаться только в прямом направлении и позволяют лишь читать или писать туда, куда указывают, причем лишь единожды, они подходят только для однопроходных алгоритмов.</p>
<p>Более мощная категория итераторов состоит из <emphasis>однонаправленных итераторов</emphasis> (forward iterators). Такие итераторы могут делать все, что делают итераторы ввода и вывода, плюс разрешают читать и писать в то место, на которое указывают, более одного раза. Это делает их удобными для многопроходных алгоритмов. STL не предоставляет реализацию однонаправленных связных списков, но в некоторых библиотеках они есть (и обычно называются slist); итераторы таких контейнеров являются однонаправленными. Итераторы кэшированных контейнеров в библиотеке TR1 (см. правило 54) также могут быть однонаправленными.</p>
<p><emphasis>Двунаправленные итераторы</emphasis> (bidirectional iterators) добавляют к функциональности однонаправленных итераторов возможность перемещения назад. Итераторы для STL-контейнера list относятся к этой категории, равно как и итераторы для set, multiset, map и multimap.</p>
<p>Наиболее мощная категория итераторов – это <emphasis>итераторы с произвольным доступом</emphasis> (random access iterators). Итераторы этого типа добавляют к функциям двунаправленных итераторов «итераторную арифметику», то есть возможность перемещения вперед и назад на заданное расстояние, затрачивая на это постоянное время. Такая арифметика аналогична арифметике указателей, что неудивительно, поскольку итераторы с произвольным доступом моделируют встроенные указатели, а встроенные указатели могут вести себя как итераторы с произвольным доступом. Итераторы для vector, deque и string являются итераторами с произвольным доступом.</p>
<p>Для каждой из пяти категорий итераторов C++ в стандартной библиотеке имеется соответствующая «структура-тэг» (tag struct):</p>
<empty-line/><p><code>struct input_iterator_tag {};</code></p>
<p><code>struct output_iterator_tag {};</code></p>
<p><code>struct forward_iterator_tag: public input_iterator_tag {};</code></p>
<p><code>struct bidirectional_iterator_tag: public forward_iterator_tag {};</code></p>
<p><code>struct random_access_iterator_teg: public bidirectional_iterator_tag {};</code></p>
<empty-line/><p>Отношения наследования между этими структурами корректно выражают взаимосвязь типа «является» (см. правило 32): верно, что все однонаправленные итераторы являются также итераторами ввода и т. д. Вскоре мы увидим примеры использования такого наследования.</p>
<p>Но вернемся к операции advance. Поскольку у разных итераторов возможности различны, то можно было при реализации advance воспользоваться «наименьшим общим знаменателем», то есть организовать цикл, в котором итератор увеличивается или уменьшается на единицу. Но такой подход требует линейных затрат времени. Итераторы с произвольным доступом обеспечивают доступ к любому элементу контейнера за постоянное время, и, конечно, мы бы хотели воспользоваться этим преимуществом, коль скоро оно имеется.</p>
<p>В действительности хотелось бы реализовать advance как-то так:</p>
<empty-line/><p><code>template&lt;typename IterT, typename DistT&gt;</code></p>
<p><code>void advance(IterT&amp; iter, DistT d)</code></p>
<p><code>{</code></p>
<p><code>if (<emphasis>iter является итератором с произвольным доступом</emphasis>) {</code></p>
<p><code>iter += d; // использовать итераторную арифметику</code></p>
<p><code>} // для итераторов с произвольным доступом</code></p>
<p><code>else {</code></p>
<p><code>if(d&gt;=0) {while (d–) ++iter;} // вызывать ++ или – в цикле</code></p>
<p><code>else {while(d++) –iter;} // для итераторов других категорий</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/><p>Но для этого нужно уметь определять, является ли iter итератором с произвольным доступом, что, в свою очередь, требует знания о том, что его тип – IterT – относится к категории итераторов с произвольным доступом. Другими словами, нам нужно получить некоторую информацию о типе. Именно для этого и служат характеристики (traits): получить информацию о типе во время компиляции.</p>
<p>Traits – это не ключевое слово и не предопределенная конструкция в C++; это техника и соглашение, которому следуют программисты. Одним из требований, предъявляемых к ней, является то, что она должна одинаково хорошо работать и для встроенных типов, и для типов, определяемых пользователем. Например, при вызове для обычного указателя (типа const char*) или значения типа int операция advance должна работать, а это значит, что техника характеристик должна быть применима и к встроенным типам.</p>
<p>Тот факт, что характеристики должны работать со встроенными типами, означает, что нельзя рассчитывать на размещение специальной информации внутри типа, потому что в указателях никакую информацию не разместишь. Поэтому характеристическая информация о типе должна быть внешней по отношению к типу. Стандартная техника заключается в помещении ее в шаблон, для которого существует одна или несколько специализаций. Для итераторов в стандартной библиотеке существует шаблон iterator_traits:</p>
<empty-line/><p><code>template&lt;typename IterT&gt; // шаблон для информации</code></p>
<p><code>struct iterator_traits; // о типах итераторов</code></p>
<empty-line/><p>Как видите, iterator_traits – это структура. По соглашению характеристики всегда реализуются в виде структур. Другое соглашение заключается в том, что структуры, используемые для их реализации, почему-то называются <emphasis>классами-</emphasis> характеристиками.</p>
<p>Смысл iterator_traits состоит в том, что для каждого типа IterT определяется псевдоним typedef iterator_category для структуры iterator_traits&lt;IterT&gt;. Этот typedef идентифицирует категорию, к которой относится итератор IterT.</p>
<p>Реализация этой идеи в iterator_traits состоит из двух частей. Первая – вводится требование, чтобы все определяемые пользователем типы итераторов имели внутри себя вложенный typedef с именем iterator_category, который задает соответствующую структуру-тэг. Например, итераторы deque являются итераторами с произвольным доступом, поэтому класс итераторов deque должен выглядеть примерно так:</p>
<empty-line/><p><code>template &lt;…&gt;</code></p>
<p><code>class deque {</code></p>
<p><code>public:</code></p>
<p><code>class iterator {</code></p>
<p><code>public:</code></p>
<p><code>typedef random_access_iterator_tag iterator_category;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Итераторы для контейнеров list являются двунаправленными, поэтому для них объявление выглядит так:</p>
<empty-line/><p><code>template &lt;…&gt;</code></p>
<p><code>class list {</code></p>
<p><code>public:</code></p>
<p><code>class iterator {</code></p>
<p><code>public:</code></p>
<p><code>typedef bidirectional_iterator_tag iterator_category;</code></p>
<p><code>};</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>В шаблоне iterator_traits просто повторен находящийся внутри класса итератора typedef:</p>
<empty-line/><p><code>// iterator_category для типа IterT – это то, что сообщает о нем сам IterT</code></p>
<p><code>// см. в правиле 42 информацию об использовании “typedef typename”</code></p>
<p><code>template &lt;typename IterT&gt;</code></p>
<p><code>struct iterator_traits {</code></p>
<p><code>typedef typename IterT::iterator_category iterator_category;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Это работает с пользовательскими типами, но не подходит для итераторов, которые являются указателями, потому что не существует указателей с вложенными typedef. Поэтому во второй части шаблона iterator_traits реализована поддержка итераторов, являющихся указателями.</p>
<p>С этой целью iterator_traits представляет <emphasis>частичную специализацию шаблонов</emphasis> для типов указателей. Указатели ведут себя как итераторы с произвольным доступом, поэтому в iterator_traits для них указана именно эта категория:</p>
<empty-line/><p><code>template &lt;typename IterT&gt; // частичная специализация шаблона</code></p>
<p><code>struct iterator_traits&lt;IterT*&gt; // для встроенных типов указателей</code></p>
<p><code>{</code></p>
<p><code>typedef random_access_iterator_tar iterator_category;</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Теперь вы должны понимать, как проектируется и реализуется класс-характеристика:</p>
<p>• Идентифицировать информацию о типе, которую вы хотели бы сделать доступной (например, для итераторов – это их категория).</p>
<p>• Выбрать имя для обозначения этой информации (например, iterator_category).</p>
<p>• Предоставить шаблон и набор его специализаций (например, iterator_traits), которые содержат информацию о типах, которые вы хотите поддерживать.</p>
<p>Имея шаблон iterator_traits, – на самом деле std::iterator_traits, потому что он является частью стандартной библиотеки C++, – мы можем уточнить наш псевдокод для advance:</p>
<empty-line/><p><code>template&lt;typename IterT, typename DistT&gt;</code></p>
<p><code>void advance(IterT&amp; iter, DistT d)</code></p>
<p><code>{</code></p>
<p><code>if (typeid(typename std::iterator_traits&lt;IterT&gt;::iterator_category)==</code></p>
<p><code>typeid(std::random_access_iterator_tag))</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>Выглядит многообещающе, но это не совсем то, что нужно. Во-первых, возникнет проблема при компиляции, но ее мы рассмотрим в правиле 48; а пока остановимся на более фундаментальном обстоятельстве. Тип IterT известен на этапе компиляции, поэтому iterator_traits&lt;IterT&gt;::iterator_category также может быть определен во время компиляции. Но предложение if вычисляется во время исполнения. Зачем делать во время исполнения нечто такое, что можно сделать во время компиляции? Это пустая трата времени и раздувание исполняемого кода.</p>
<p>Что нам нужно – так это условная конструкция (например, предложение if..else) для типов, которая вычислялась бы во время компиляции. К счастью, в C++ есть необходимые нам средства. Это не что иное, как перегрузка.</p>
<p>Когда вы перегружаете некоторую функцию f, вы указываете параметры разных типов для различных версий. Когда вызывается f, компилятор выбирает наиболее подходящую из перегруженных версий, основываясь на переданных аргументах. Компилятор, по сути, говорит: «Если эта версия лучше всего соответствует переданным параметрам, вызову ее; если лучше подходит другая версия – остановлюсь на ней, и так далее». Видите? Условная конструкция для типов во время компиляции. Чтобы заставить advance работать нужным нам образом, следует всего лишь создать две версии перегруженной функции, объявив в качестве параметра для каждой из них объекты iterator_category разных типов. Я назову эти функции doAdvance:</p>
<empty-line/><p><code>template&lt;typename IterT, typename DistT&gt; // использовать эту</code></p>
<p><code>void doAdvance(IterT&amp; iter, DistT d, // реализацию для</code></p>
<p><code>std::random_access_iterator_tag) // итераторов</code></p>
<p><code>{ // с произвольным доступом</code></p>
<p><code>iter += d;</code></p>
<p><code>}</code></p>
<p><code>template&lt;typename IterT, typename DistT&gt; // использовать эту</code></p>
<p><code>void doAdvance(IterT&amp; iter, DistT d, // реализацию для</code></p>
<p><code>std::bidirectional_iterator_tag) // двунаправленных</code></p>
<p><code>{ // итераторов</code></p>
<p><code>if(d &gt;= 0) {while(d–) ++iter;}</code></p>
<p><code>else {while (d++) –iter;}</code></p>
<p><code>}</code></p>
<p><code>template&lt;typename IterT, typename DistT&gt; // использовать</code></p>
<p><code>void doAdvance(IterT&amp; iter, DistT d, // эту реализацию</code></p>
<p><code>std::input_iterator_tag) // для итераторов</code></p>
<p><code>{ // ввода</code></p>
<p><code>if(d &lt; 0) {</code></p>
<p><code>throw std::out_of_range(“Отрицательное направление”); // см. ниже</code></p>
<p><code>}</code></p>
<p><code>while (d–) ++iter;</code></p>
<p><code>}</code></p>
<empty-line/><p>Поскольку forward_iterator_tag наследует input_iterator_tag, то версия do-Advance для input_iterator_tag будет работать и с однонаправленными итераторами. Это дополнительный аргумент в пользу наследования между разными структурами iterator_tag. Фактически это аргумент в пользу <emphasis>любого</emphasis> открытого наследования: иметь возможность писать код для базового класса, который будет работать также и для производных от него классов.</p>
<p>Спецификация advance допускает как положительные, так и отрицательные значения сдвига для итераторов с произвольным доступом и двунаправленных итераторов, но поведение не определено, если вы попытаетесь сдвинуть на отрицательное расстояние итератор ввода или однонаправленный итератор. Реализации, которые я проверял, просто предполагают, что d – не отрицательно, поэтому входят в <emphasis>очень</emphasis> длинный цикл, пытаясь отсчитать «вниз» до нуля, если им передается отрицательное значение. В коде, приведенном выше, я показал вариант, в котором вместо этого возбуждается исключение. Обе реализации корректны. Это проклятие неопределенного поведения: вы <emphasis>не можете предсказать,</emphasis> что произойдет.</p>
<p>Имея разные перегруженные версии doAdvance, функции advance остается только вызвать их, передав в качестве дополнительного параметра объект, соответствующий типу категории итератора, чтобы компилятор мог применить механизм разрешения перегрузки для вызова правильной реализации:</p>
<empty-line/><p><code>template &lt;typename IterT, typename DistT&gt;</code></p>
<p><code>void advance(IterT&amp; iter, DistT d)</code></p>
<p><code>{</code></p>
<p><code>doAdvance( // вызвать версию</code></p>
<p><code>iter, d, // doAdvance</code></p>
<p><code>typename // соответствующую</code></p>
<p><code>std::iterator_traits&lt;IterT&gt;::iterator_category() // категории</code></p>
<p><code>); // итератора iter</code></p>
<p><code>}</code></p>
<empty-line/><p>Подведем итоги – как нужно использовать класс-характеристику:</p>
<p>• Создать набор перегруженных «рабочих» функций либо шаблонов функций (например, doAdvance), которые отличаются параметром-характеристикой. Реализовать каждую функцию в соответствии с переданной характеристикой.</p>
<p>• Создать «ведущую» функцию либо шаблон функции (например, advance), которая вызывает рабочие функции, передавая информацию, предоставленную классом-характеристикой.</p>
<p>Классы-характеристики широко используются в стандартной библиотеке. Так, класс iterator_traits, помимо iterator_category, представляет еще четыре вида информации об итераторах (наиболее часто используется value_type; в правиле 42 показан пример его применения). Есть еще char_traits, который содержит информацию о символьных типах, и numeric_limits, который хранит информацию о числовых типах, например минимальных и максимальных значениях и т. п. Имя numeric_limits немного сбивает с толку, поскольку нарушает соглашение, в соответствии с которыми имена классов-характеристик должны оканчиваться на «traits», но тут уж ничего не поделаешь, придется смириться.</p>
<p>В библиотеке TR1 (см. правило 54) есть целый ряд новых классов-характеристик, которые предоставляют информацию о типах, включая is_fundamental&lt;T&gt; (где T – встроенный тип), is_array&lt;T&gt; (где T – тип массива) и is_base_of&lt;T1,T2&gt; (то есть является ли T1 тем же, что и T2, либо его базовым классом). Всего TR1 добавляет к стандартному C++ более 50 классов-характеристик.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Классы-характеристики делают доступной информацию о типах во время компиляции. Они реализованы с применением шаблонов и их специализаций.</p>
<p>• В сочетании с перегрузкой классы-характеристики позволяют проверять типы во время компиляции.</p>
</section><section><title><p>Правило 48: Изучите метапрограммирование шаблонов</p>
</title><p>Метапрограммирование шаблонов (template metaprogramming – TMP) – это процесс написания основанных на шаблонах программ на C++, исполняемых во время компиляции. На минуту задумайтесь об этом: шаблонная метапрограмма – это программа, написанная на C++, которая исполняется <emphasis>внутри компилятора C+ +.</emphasis> Когда TMP-программа завершает исполнение, ее результат – фрагменты кода на C++, конкретизированные из шаблонов, – компилируется как обычно.</p>
<p>Если эта идея не поразила вас до глубины души, значит, вы недостаточно напряженно думали о ней.</p>
<p>C++ не предназначался для метапрограммирования шаблонов, но с тех пор, как технология TMP была открыта в начале 90-х годов, она оказалась настолько полезной, что, вероятно, и в сам язык, и в стандартную библиотеку будут включены расширения, облегчающие работу с TMP. Да, TMP было именно открыто, а не придумано. Средства, лежащие в основе TMP, появились в C++ вместе с шаблонами. Нужно было только, чтобы кто-то заметил, как они могут быть использованы изобретательным и неожиданным образом.</p>
<p>Технология TMP дает два преимущества. Во-первых, она позволяет делать такие вещи, которые иными способами сделать было бы трудно либо вообще невозможно. Во-вторых, поскольку шаблонные метапрограммы исполняются во время компиляции C++, они могут переместить часть работы со стадии исполнения на стадию компиляции. В частности, некоторые ошибки, которые обычно всплывают во время исполнения, можно было бы обнаружить при компиляции. Другое преимущество – это то, что программы C++, написанные с использованием TMP, можно сделать эффективными почти во всех смыслах: компактность исполняемого, код быстродействия, потребления памяти. Но коль скоро часть работы переносится на стадию компиляции, то, очевидно, компиляция займет больше времени. Для компиляции программ, в которых применяется технология TMP, может потребоваться <emphasis>намного</emphasis> больше времени, чем для компиляции аналогичных программ, написанных без применения TMP.</p>
<p>Рассмотрим псевдокод шаблонной функции advance, представленный на стр. 227 (см. правило 47; возможно, имеет смысл перечитать это правило сейчас, поскольку ниже я предполагаю, что вы знакомы с изложенным в нем материалом). Я выделил в этом фрагменте часть, написанную на псевдокоде:</p>
<empty-line/><p><code>template&lt;typename IterT, typename DistT&gt;</code></p>
<p><code>void advance(IterT&amp; iter, DistT d)</code></p>
<p><code>{</code></p>
<p><code>if (<emphasis>iter является итератором с произвольным доступом</emphasis>) {</code></p>
<p><code>iter += d; // использовать итераторную арифметику</code></p>
<p><code>} // для итераторов с произвольным доступом</code></p>
<p><code>else {</code></p>
<p><code>if(d&gt;=0) {while (d–) ++iter;} // вызывать ++ или – в цикле</code></p>
<p><code>else {while(d++) –iter;} // для итераторов других категорий</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/><p>Мы можем использовать typeid, чтобы заменить псевдокод реальным кодом. Тогда задача будет решена «нормальным» для C++ способом – вся работа выполняется во время исполнения:</p>
<empty-line/><p><code>template&lt;typename IterT, typename DistT&gt;</code></p>
<p><code>void advance(IterT&amp; iter, DistT d)</code></p>
<p><code>{</code></p>
<p><code>if (typeid(typename std::iterator_traits&lt;IterT&gt;::iterator_category)==</code></p>
<p><code>typeid(std::random_access_iterator_tag))</code></p>
<p><code>iter += d; // использовать итеративную арифметику</code></p>
<p><code>} // для итераторов с произвольным доступом</code></p>
<p><code>else {</code></p>
<p><code>if(d&gt;=0) {while (d–) ++iter;} // вызывать ++ или – в цикле</code></p>
<p><code>else {while(d++) –iter;} // для итераторов других категорий</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/><p>В правиле 47 отмечено, что подход, основанный на typeid, менее эффективен, чем при использовании классов-характеристик, поскольку в этом случае: (1) проверка типа происходит во время исполнения, а не во время компиляции, и (2) код, выполняющий проверку типа, должен быть включен в исполняемую программу. Фактически этот пример показывает, как технология TMP может порождать более эффективные программы на C++, потому что характеристики – это и <emphasis>есть</emphasis> частный случай TMP. Напомню, что характеристики делают возможным вычисление выражения if…else во время компиляции.</p>
<p>Я уже отмечал выше, что некоторые вещи технология TMP позволяет сделать проще, чем «нормальный» C++, и advance можно считать иллюстраций этого утверждения. В правиле 47 упоминается о том, что основанная на typeid реализация advance может привести к проблемам во время компиляции, и вот вам пример такой ситуации:</p>
<empty-line/><p><code>std::list&lt;int&gt;::iterator iter;</code></p>
<p><code>...</code></p>
<p><code>advance(iter, 10); // сдвинуть iter на 10 элементов вперед</code></p>
<p><code>// не скомпилируется для приведенной</code></p>
<p><code>// выше реализации</code></p>
<empty-line/><p>Рассмотрим версию advance, которая будет сгенерирована для этого вызова. После подстановки типов iter и 10 в качестве параметров шаблона IterT и DistT мы получим следующее:</p>
<empty-line/><p><code>void advance(std::list&lt;int&gt;::iterator&amp; iter, int d)</code></p>
<p><code>{</code></p>
<p><code>if (typeid(std::iterator_traits&lt;std::list&lt;int&gt;::iterator&gt;::iterator_category)==</code></p>
<p><code>typeid(std::random_access_iterator_tag))</code></p>
<p><code>iter += d; // ошибка!</code></p>
<p><code>}</code></p>
<p><code>else {</code></p>
<p><code>if(d&gt;=0) {while (d–) ++iter;}</code></p>
<p><code>else {while(d++) –iter;}</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/><p>Проблема в выделенной строке, где встречается оператор +=. В данном случае мы пытаемся использовать += для типа list&lt;int&gt;::iterator, но list&lt;int&gt;::iterator – это двунаправленный итератор (см. правило 47), поэтому он не поддерживает +=. Оператор += поддерживают только итераторы с произвольным доступом. Мы знаем, что никогда не попытаемся исполнить предложение, содержащее +=, потому что для list&lt;int&gt;::iterator проверка с привлечением typeid никогда не выполнится успешно, но компилятор-то обязан гарантировать, что весь исходный код корректен, даже если он никогда не исполняется, а «iter += d» – некорректный код в случае, когда iter не является итератором с произвольным доступом. Решение же на основе технологии TMP предполагает, что код для разных типов вынесен в разные функции, каждая из которых использует только операции, применимые к типам, для которых она написана.</p>
<p>Было доказано, что технология TMP представляет собой полную машину Тьюринга, то есть обладает достаточной мощью для любых вычислений. Используя TMP, вы можете объявлять переменные, выполнять циклы, писать и вызывать функции и т. д. Но такие конструкции выглядят совершенно иначе, чем их аналоги из «нормального» C++. Например, в правиле 47 показано, как в TMP условные предложения if…else выражаются с помощью шаблонов и их специализаций. Но такие конструкции можно назвать «TMP уровня ассемблера». В библиотеках для работы с TMP (например, MPL из Boost – см. правило 55) предлагается более высокоуровневый синтаксис, хотя его также нельзя принять за «нормальный» С++.</p>
<p>Чтобы взглянуть на TMP с другого боку, посмотрим, как там выглядят циклы. Технология TMP не предоставляет настоящих циклических конструкций, поэтому цикл моделируется с помощью рекурсии. (Если вы не очень уверенно владеете рекурсией, придется освоиться с ней прежде, чем приступать к использованию TMP. Ведь TMP – по существу функциональный язык, а для таких языков рекурсия – то же, что телевидение для американской поп-культуры – неотъемлемая принадлежность.) Но и рекурсия-то не совсем обычная, поскольку при реализации циклов TMP нет рекурсивных вызовов функций, а есть рекурсивные <emphasis>конкретизации шаблонов.</emphasis></p>
<p>Аналогом программы «Hello World» на TMP является вычисление факториала во время компиляции. Конечно, она, как и «Hello World», не поразит воображение, но обе полезны для демонстрации базовых возможностей языка. Вычисление факториала с помощью TMP сводится к последовательности рекурсивных конкретизаций шаблона. Кроме того, демонстрируется один из способов создания и использования переменных в TMP. Смотрите:</p>
<empty-line/><p><code>template&lt;unsigned n&gt; // общий случай: значение Factorial&lt;n&gt; – это</code></p>
<p><code>struct Factorial { // произведение n и Factorial&lt;n-1&gt;</code></p>
<p><code>enum { value = n*Factorial&lt;n-1&gt;::value };</code></p>
<p><code>};</code></p>
<p><code>template&lt;&gt; // частный случай: значение Factorial&lt;0&gt; –</code></p>
<p><code>struct Factorial&lt;0&gt; { // это 1</code></p>
<p><code>enum { value = 1 };</code></p>
<p><code>};</code></p>
<empty-line/><p>Имея такую шаблонную метапрограмму (на самом деле просто единственную шаблонную метафункцию Factorial), вы получаете значение факториала n, обращаясь к Factorial&lt;n&gt;::value.</p>
<p>Циклическая часть кода возникает там, где конкретизация шаблона Factorial&lt;n&gt; ссылается на конкретизацию шаблона Factorial&lt;n-1&gt;. Как во всякой рекурсивной программе, здесь есть особый случай, прекращающий рекурсию. В данном случае это специализация шаблона Factorial&lt;0&gt;.</p>
<p>Каждая конкретизация шаблона Factorial является структурой struct, и в каждой структуре используется «трюк с перечислением» (см. правило 2) для объявления переменной TMP с именем value. В переменной value хранится текущее значение факториала. Если бы в TMP были настоящие циклы, то значение value обновлялось бы на каждой итерации цикла. Но поскольку в TMP место циклов заменяет рекурсивная конкретизация шаблонов, то каждая конкретизация получает свою собственную копию value, и значение копии соответствует «итерации цикла».</p>
<p>Использовать Factorial можно следующим образом:</p>
<empty-line/><p><code>int main()</code></p>
<p><code>{</code></p>
<p><code>std::cout &lt;&lt; Factorial&lt;5&gt;::value; // печатается 120</code></p>
<p><code>std::cout &lt;&lt; Factorial&lt;10&gt;::value; // печатается 3628800</code></p>
<p><code>}</code></p>
<empty-line/><p>Если вы находите описанный прием элегантным, значит, вы стали на путь превращения в метапрограммиста шаблонов. Если же все эти шаблоны, специализации, рекурсивные конкретизации, трюк с перечислением и необходимость набирать нечто вроде Factorial&lt;n-1&gt;::value не вызывают у вас восторга, стало быть, вы вполне нормальный программист C++.</p>
<p>Конечно, шаблон Factorial в такой же мере демонстрирует полезность TMP, как «Hello World» – полезность любого обычного языка программирования. Чтобы понять, почему о TMP стоит знать, важно представлять себе, чего можно достичь с помощью этой технологии. Вот три примера:</p>
<p>• <strong>Обеспечение корректности единиц измерения.</strong> В научных и инженерных приложениях важно, чтобы единицы измерения (например, массы, расстояния, времени и т. п.) правильно сочетались. Присваивание переменной, представляющей массу, значения переменной, представляющей скорость, – это ошибка, но деление переменной расстояния на переменную времени и присваивание результата переменной скорости правильно. Используя TMP, можно обеспечить (во время компиляции), что все комбинации единиц измерения в программе будут корректны, независимо от того, насколько сложны вычисления. (Это пример того, как можно использовать TMP для ранней диагностики ошибок.) Одним интересным аспектом такого использования TMP может быть поддержка вычисления дробных степеней. Смысл в том, чтобы дроби сокращались во время компиляции, то есть чтобы компилятор мог подтвердить, например, что единица времени в степени 1/2 – это то же самое, что единица времени в степени 4/8.</p>
<p>• <strong>Оптимизация операций с матрицами.</strong> В правиле 21 объясняется, что некоторые функции, включая operator*, должны возвращать новые объекты, а в правиле 44 представлен класс SquareMatrix, поэтому рассмотрим такой код:</p>
<empty-line/><p><code>typedef SquareMatrix&lt;double, 10000&gt; BigMatrix;</code></p>
<p><code>BigMatrix m1, m2, m3, m4, m5; // создать матрицы</code></p>
<p><code>... // и присвоить им значения</code></p>
<p><code>BigMatrix result = m1 * m2 * m3 * m4 * m5; // вычислить произведение</code></p>
<empty-line/><p>Вычисление result «нормальным» способом приводит к созданию четырех временных матриц, по одной для каждого вызова operator*. Более того, независимые операции умножения порождают последовательность из четырех циклов по элементам матрицы. Но применение передовой шаблонной технологии, тесно связанной с TMP и получившей название <emphasis>шаблоны выражений</emphasis> (expression templates), позволяет избежать создания временных объектов и объединить циклы, причем все это без изменения приведенного выше пользовательского кода. В результате программа требует меньше памяти и выполняется значительно быстрее.</p>
<p><strong>• Генерация специализированных реализаций паттернов проектирования.</strong> Паттерны проектирования, подобные Strategy (см. правило 35), Observer, Visitor и т. п., могут быть реализованы многими способами. Используя основанную на TMP технологию, называемую <emphasis>проектирование на основе политик</emphasis> (policy-based design), можно создавать шаблоны, представляющие независимые проектные решения («политики»), которые могут быть соответствующим образом скомбинированы для порождения реализаций паттернов с заданным поведением. Например, эта техника применялась для того, чтобы из нескольких шаблонов, реализующих различное поведение «интеллектуальных» указателей, породить (во время компиляции) любой из <emphasis>сотен</emphasis> разных типов «интеллектуальных» указателей. В результате обобщения, выходящего за рамки привычных программных конструкций, к примеру паттернов проектирования и «интеллектуальных» указателей, эта технология ложится в основу так называемого <emphasis>порождающего программирования</emphasis> (generative programming).</p>
<p>Технология TMP предназначена не для всех. Применяемый в ней синтаксис интуитивно не очевиден, а поддерживающий инструментарий не развит. (Отладчики для шаблонных метапрограмм? Ну насмешили, право!) Поскольку это вспомогательный язык, открытый сравнительно недавно, то применяемые в нем соглашения носят пока экспериментальный характер. Тем не менее повышение эффективности за счет переноса части со стадии исполнения на стадию компиляции может оказаться значительным, а возможность выразить поведение, которое трудно или невозможно реализовать во время исполнения, также весьма привлекательно.</p>
<p>Поддержка TMP растет. Вероятно, в следующей версии C++ будет реализована явная поддержка этой технологии, в TR1 это уже декларировано (см. правило 54). Начали появляться книги, посвященные этой теме, а информация о TMP в Internet становится все богаче. Видимо, TMP никогда не станет главным направлением развития, но для некоторых программистов (особенно разработчиков библиотек) она почти наверняка займет важное место.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Метапрограммирование шаблонов позволяет перенести часть работы со стадии исполнения на стадию компиляции. За счет этого можно раньше обнаружить ошибки и повысить производительность программ.</p>
<p>• Технология TMP может быть использована для генерации кода на основе комбинации политик, а также чтобы предотвратить генерацию кода, некорректного для определенных типов данных.</p>
</section></section><section><title><p>Глава 8</p>
<p>Настройка new и delete</p>
</title><section><p>В наши дни, когда вычислительные среды снабжены встроенной поддержкой «сборки мусора» (как, например, Java и. NET), ручной подход C++ к управлению памятью может показаться несколько устаревшим. Однако многие разработчики, создающие требовательные к ресурсам прикладные программы, выбирают C++ <emphasis>именно потому,</emphasis> что он позволяет управлять памятью вручную. Такие разработчики изучают, как используется память в их программах, и разрабатывают собственные процедуры распределения и освобождения памяти с целью достичь максимально возможной производительности (с точки зрения как времени, так и потребления памяти) своих систем.</p>
<p>Для этого нужно понимать, как организованы процедуры управления памятью в C++. Именно этой теме и посвящена настоящая глава. Два основных компонента здесь – это процедура выделения и освобождения памяти (операторы new и delete), а вспомогательная роль отводится обработчику new – функции, которая вызывается, когда new не может удовлетворить запрос на выделение памяти.</p>
<p>С управлением памятью в многопоточной среде связаны дополнительные сложности, не возникающие в однопоточных системах, поскольку «куча» – это модифицируемый глобальный ресурс, доступ к которому должен быть синхронизирован. Во многих правилах из настоящей главы идет речь об использовании модифицируемых статических данных. Эта тема всегда настораживает программистов, разрабатывающих многопоточные программы. Без правильной синхронизации, отсутствия взаимных блокировок в алгоритмах и тщательного проектирования с целью предотвращения одновременного доступа, обращения к процедурам работы с памятью могут легко привести к повреждению структур данных, управляющих кучей. Вместо того чтобы постоянно напоминать вам об этой опасности, я говорю об этом только здесь и предполагаю, что вы будете помнить об этом при чтении остальной части главы.</p>
<p>Следует помнить и о том, что операторы new и delete применимы только к выделению и освобождению одиночных объектов. Память для массивов выделяет operator new[] и освобождает operator delete[] (в обоих случаях «[]» является частью имен функций). Если явно не оговорено противное, то все сказанное об операторах new и delete касается также new[] и delete[].</p>
<p>И наконец, отмечу, что в случае STL-контейнеров выделением памяти из кучи управляют объекты-распределители, ассоциированные с самими контейнерами, а не напрямую new и delete. В этой главе ничего не говорится о распределителях памяти в STL.</p>
</section><section><title><p>Правило 49: Разберитесь в поведении обработчика new</p>
</title><p>Когда оператор new не может удовлетворить запрос на выделение памяти, он возбуждает исключение. Когда-то он возвращал нулевой указатель, и некоторые старые компиляторы все еще так и поступают. Вы можете столкнуться с таким устаревшим поведением, но я отложу его обсуждение до конца правила.</p>
<p>Прежде чем возбудить исключение в ответ на невозможность удовлетворить запрос на выделение памяти, оператор new вызывает определенную пользователем функцию, называемую <emphasis>обработчиком new (new-handler).</emphasis> (На самом деле это не совсем так. Реальное поведение new несколько сложнее. Подробности описаны в правиле 51.) Чтобы задать функцию, обрабатывающую нехватку памяти, клиенты вызывают set_new_handler – стандартную библиотечную функцию, объявленную в заголовочном файле &lt;new&gt;:</p>
<empty-line/><p><code>namespace std {</code></p>
<p><code>typedef void (*new_handler)();</code></p>
<p><code>new_handler set_new_handler(new_handler p) throw();</code></p>
<p><code>}</code></p>
<empty-line/><p>Как видите, new_handler – это typedef для указателя на функцию, которая ничего не принимает и не возвращает, а set_new_handler – функция, которая принимает и возвращает new_handler (конструкция throw() в конце объявления set_new_handler – это спецификация исключения; по существу, она сообщает, что функция не возбуждает никаких исключений, хотя на самом деле все несколько интереснее; подробности см. в правиле 29).</p>
<p>Параметр set_new_handler – это указатель на функцию, которую operator new вызывает при невозможности выделить запрошенную память. Возвращаемое set_new_handler значение – указатель на функцию, которая использовалась для этой цели перед вызовом set_new_handler.</p>
<p>Используется set_new_handler следующим образом:</p>
<empty-line/><p><code>// функция, которая должна быть вызвана, если operator new</code></p>
<p><code>// не может выделить память</code></p>
<p><code>void outOfMem()</code></p>
<p><code>{</code></p>
<p><code>std::cerr &lt;&lt; “Невозможно удовлетворить запрос на выделение памяти\n”;</code></p>
<p><code>std::abort();</code></p>
<p><code>}</code></p>
<p><code>int main()</code></p>
<p><code>{</code></p>
<p><code>std::set_new_handler(outOfMem);</code></p>
<p><code>int *pBigDataArray = new int[100000000L];</code></p>
<p><code>...</code></p>
<p><code>}</code></p>
<empty-line/><p>Если operator new не может выделить память для размещения 100 000 000 целых чисел, будет вызвана функция outOfMem, и программа завершится, выдав сообщение об ошибке. (Кстати, подумайте, что случится, если память должна быть динамически выделена во время вывода сообщения об ошибке в cerr…)</p>
<p>Когда operator new не может удовлетворить запрос в памяти, он будет вызывать обработчик new до тех пор, пока он не <emphasis>сумеет</emphasis> найти достаточно памяти. Код, приводящий к повторным вызовам, показан в правиле 51, но и такого высокоуровневого описания достаточно, чтобы сделать вывод о том, что правильно спроектированная функция-обработчик new должна делать что-то одно из следующего списка:</p>
<p>• <strong>Найти дополнительную память.</strong> В результате следующая попытка выделить память внутри operator new может завершиться успешно. Один из способов реализовать такую стратегию – выделить большой блок памяти в начале работы программы, в затем освободить его при первом вызове обработчика new.</p>
<p>• <strong>Установить другой обработчик new.</strong> Если текущий обработчик не может выделить память, то, возможно, ему известен какой-то другой, который сможет это сделать. Если так, то текущий обработчик может установить вместо себя другой (вызвав set_new_handler). В следующий раз, когда operator new обратится к обработчику, будет вызван последний установленный. (В качестве альтернативы обработчик может изменить <emphasis>собственное</emphasis> поведение, чтобы при следующем вызове сделать что-то другое. Добиться этого можно, например, путем модификации некоторых статических, определенных в пространстве имен или глобальных данных, влияющих на его поведение.)</p>
<p>• <strong>Убрать обработчик new,</strong> то есть передать нулевой указатель set_new_handler. Если обработчик не установлен, то operator new сразу возбудит исключение при неудачной попытке выделить память.</p>
<p>• <strong>Возбудить исключение</strong> типа bad_alloc либо некоторого типа, унаследованного от bad_alloc. Такие исключения не перехватывает operator new, поэтому они распространяются до того места, где была запрошена память.</p>
<p>• <strong>Не возвращать управление</strong> – обычно вызвав abort или exit.</p>
<p>Эти варианты выбора обеспечивают вам достаточную гибкость в реализации функций-обработчиков new.</p>
<p>Иногда обработать ошибки при выделении памяти можно и другими способами, зависящими от класса распределяемого объекта:</p>
<empty-line/><p><code>class X {</code></p>
<p><code>public:</code></p>
<p><code>static void outOfMemory();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class Y {</code></p>
<p><code>public:</code></p>
<p><code>static void outOfMemory();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>X *p1 = new X; // если выделить память не удалось,</code></p>
<p><code>// вызвать X::outOfMemory</code></p>
<p><code>Y *p2 = new Y; // если выделить память не удалось,</code></p>
<p><code>// вызвать Y::outOfMemory</code></p>
<empty-line/><p>С++ не поддерживает специфичных для класса обработчиков new, но он и не нуждается в них. Вы можете реализовать такое поведение самостоятельно. Для этого просто в каждом классе определяете собственную версию set_new_handler и operator new. Определенная в классе функция set_new_handler класса позволит пользователям задать обработчик new для класса (точно так же, как обычный set_new_handler устанавливает глобальный обработчик new). Принадлежащий классу operator new гарантирует, что при выделении памяти для объектов этого класса вместо глобального обработчика new будет использован тот, что определен в данном классе.</p>
<p>Предположим, вы хотите обработать ошибки выделения памяти для класса Widget. Понадобится функция, которая будет вызываться, когда operator new не может выделить достаточно памяти для объекта Widget, поэтому вы объявляете статический член типа new_handler для хранения указателя на обработчик new для класса. Тогда Widget будет выглядеть примерно так:</p>
<empty-line/><p><code>class Widget {</code></p>
<p><code>public:</code></p>
<p><code>static std::new_handler set_new_handler(std::new_handler p) throw();</code></p>
<p><code>static void *operator new(std::size_t size) throw(std::bad_alloc);</code></p>
<p><code>private:</code></p>
<p><code>static std::new_handler currentHandler;</code></p>
<p><code>};</code></p>
<empty-line/><p>Статические члены класса должны быть определены вне самого класса (если только они не константные целые – см. правило 2), поэтому:</p>
<empty-line/><p><code>std::new_handler Widget::currentHandler = 0; // инициализировать нулем</code></p>
<p><code>// в файле реализации класса</code></p>
<empty-line/><p>Функция set_new_handler в классе Widget сохранит переданный ей указатель и вернет тот указатель на функцию, действовавшую ранее. Так же поступает и стандартная версия set_new_handler:</p>
<empty-line/><p><code>static std::new_handler set_new_handler(std::new_handler p) throw()</code></p>
<p><code>{</code></p>
<p><code>std::new_handler oldHandler = currentHandler;</code></p>
<p><code>currentHandler = p;</code></p>
<p><code>return oldHandler;</code></p>
<p><code>}</code></p>
<empty-line/><p>А вот что должен делать operator new из класса Widget.</p>
<p>1. Вызвать стандартный set_new_handler, указав в качестве параметра функцию-обработчик ошибок из класса Widget. В результате обработчик new из класса Widget будет установлен в качестве глобального.</p>
<p>2. Вызвать глобальный operator new для реального выделения памяти. Если произойдет ошибка, глобальный operator new вызовет обработчик new, принадлежащий Widget, поскольку эта функция была установлена в качестве глобального обработчика. Если это ни к чему не приведет, то глобальный operator new возбудит исключение bad_alloc. В этом случае operator new из класса Widget должен восстановить исходный обработчик new, а затем распространить исключение. Чтобы гарантировать, что исходный обработчик всегда восстанавливается, класс Widget трактует его как ресурс и следует совету правила 13 об использовании управляющих ресурсами объектов для предотвращения утечек.</p>
<p>3. Если глобальный operator new в состоянии выделить достаточно памяти для объекта Widget, то operator new класса Widget возвращает указатель на выделенную память. Деструктор объекта, самостоятельно управляющего глобальным обработчиком new, автоматически восстанавливает тот глобальный обработчик, который был установлен перед вызовом operator new класса Widget.</p>
<p>Теперь посмотрим, как все это выразить на C++. Начнем с класса, управляющего ресурсами, который не содержит ничего, кроме основных операций, диктуемых идиомой RAII: захват ресурса во время конструирования объекта и освобождение при его уничтожении (см. правило 13):</p>
<empty-line/><p><code>class NewHandlerHolder {</code></p>
<p><code>public:</code></p>
<p><code>explicit NewHandlerHolder(std::new_handler nh) // получить текущий</code></p>
<p><code>:handler(nh) {} // обработчик new</code></p>
<p><code>~NewHandlerHolder() // освободить его</code></p>
<p><code>{ std::set_new_handler(handler);}</code></p>
<p><code>private:</code></p>
<p><code>std::new_handler handler; // запомнить его</code></p>
<p><code>NewHandlerHolder(const NewHandlerHolder&amp;); // предотвратить</code></p>
<p><code>NewHandlerHolder&amp; // копирование</code></p>
<p><code>operator=(const NewHandlerHolder&amp;); // (см. правило 14)</code></p>
<p><code>};</code></p>
<empty-line/><p>Это делает реализацию оператора new для Widget совсем простой:</p>
<empty-line/><p><code>void Widget::orerator new(std::size_td size) throw(std::bad_aloc)</code></p>
<p><code>{</code></p>
<p><code>NewHandlerHolder // установить обработчик</code></p>
<p><code>h(std::set_new_handler(currentHandler)); // new из класса Widget</code></p>
<p><code>return ::operator new(size); // выделить память или</code></p>
<p><code>// возбудить исключение</code></p>
<p><code>} // восстановить глобальный</code></p>
<p><code>// обработчик new</code></p>
<empty-line/><p>Пользователи класса Widget применяют эти средства следующим образом:</p>
<empty-line/><p><code>void outOfMem(); // объявление функции, которую нужно</code></p>
<p><code>// вызвать, если выделить память</code></p>
<p><code>// для Widget не удается</code></p>
<p><code>Widget::set_new_handler(outOfmem); // установка outOfMem в качестве</code></p>
<p><code>// обработчика new для Widget</code></p>
<p><code>Widget *pw1 = new Widget; // если выделить память не удалось,</code></p>
<p><code>// вызывается outOfMem</code></p>
<p><code>std::string *ps = new std::string; // если выделить память не удалось,</code></p>
<p><code>// вызывается глобальный обработчик new</code></p>
<p><code>// (если есть)</code></p>
<p><code>Widget::set_new_handler(0); // отменяет обработчик new</code></p>
<p><code>Widget *pw1 = new Widget; // если выделить память не удалось,</code></p>
<p><code>// сразу же возбуждается исключение (никакого</code></p>
<p><code>// обработчика new сейчас нет)</code></p>
<empty-line/><p>Код, реализующий эту схему, один и тот же (независимо от класса), поэтому разумно было бы повторно использовать его в других местах. Простой способ сделать это – создать «присоединяемый» базовый класс, то есть базовый класс, который предназначен для того, чтобы подклассы могли унаследовать одно-единственное средство, в данном случае способность устанавливать специфичный для класса обработчик new. Затем превратите базовый класс в шаблон, чтобы каждый производный класс мог получать разные копии данных.</p>
<p>При таком подходе принадлежащая базовому классу часть позволяет подклассам наследовать необходимые им функции set_new_handler и operator new, а шаблонная часть гарантирует, что у каждого подкласса будет собственный член данных currentHandler. Звучит сложновато, но код выглядит обнадеживающе знакомым. Фактически единственным отличием является то, что теперь он доступен любому классу:</p>
<empty-line/><p><code>template&lt;typename T&gt; // «присоединяемый» базовый класс для</code></p>
<p><code>class NewHandlerSupport { // поддержки специфичной для класса</code></p>
<p><code>public: // функции set_new_handler</code></p>
<p><code>static std::new_handler set_new_handler(std::new_handler p) throw();</code></p>
<p><code>static void *operator new(std::size_t size) throw(std::bad_alloc);</code></p>
<p><code>... // другие версии оператора new – см. правило 52</code></p>
<p><code>private:</code></p>
<p><code>static std::new_handler currentHandler;</code></p>
<p><code>};</code></p>
<p><code>template&lt;typename T&gt;</code></p>
<p><code>std::new_handler</code></p>
<p><code>NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw()</code></p>
<p><code>{</code></p>
<p><code>std::new_handler oldHandler = currentHandler;</code></p>
<p><code>currentHandler = p;</code></p>
<p><code>return oldHandler;</code></p>
<p><code>}</code></p>
<p><code>template&lt;typename T&gt;</code></p>
<p><code>void *NewHandlerSupport&lt;T&gt;::operator(std::size_t size)</code></p>
<p><code>throw(std::bad_alloc)</code></p>
<p><code>{</code></p>
<p><code>NewHandlerHolder h(std::set_new_handler(currentHandler);</code></p>
<p><code>return ::operator new(size);</code></p>
<p><code>}</code></p>
<p><code>// currentHandler в любом классе инициализируется значением null</code></p>
<p><code>template&lt;typename T&gt;</code></p>
<p><code>std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = 0;</code></p>
<empty-line/><p>С этим шаблоном класса добавление поддержки set_new_handler к Widget очень просто: Widget просто наследуется от NewHandlerSupport&lt;Widget&gt;. (Это может показаться экстравагантным, но ниже я подробно объясню, что здесь происходит.)</p>
<empty-line/><p><code>class Widget: public NewHandlerSupport&lt;Widget&gt; {</code></p>
<p><code>... // как раньше, но без декларации</code></p>
<p><code>}; // set_new_handler или operator new</code></p>
<empty-line/><p>Это все, что нужно сделать в классе Widget, чтобы предоставить специфичный для класса обработчик set_new_handler.</p>
<p>Но может быть, вас беспокоит тот факт, что Widget наследует классу New-HandlerSupport&lt;Widget&gt;? Если так, то ваше беспокойство усилится, когда вы заметите, что NewHandlerSupport никогда не использует свой параметр типа T. Он не нуждается в нем. Единственное, что нам нужно, – это отдельная копия NewHandlerSupport, а точнее его статический член currentHandler для каждого класса, производного от NewHandlerSupport. Параметр шаблона T просто отличает один подкласс от другого. Механизм шаблонов автоматически генерирует копию currentHandler для каждого типа T, для которого он конкретизируется.</p>
<p>А что касается того, что Widget наследует шаблонному базовому классу, который принимает Widget как параметр типа, не пугайтесь, это только поначалу кажется непривычным. На практике это очень удобная техника, имеющая собственное название, которое отражает тот факт, что никому из тех, кто видит ее в первый раз, она не кажется естественной. А называется она <emphasis>курьезный рекурсивный шаблонный паттерн</emphasis> (curious recurring template pattern – CRTP). Честное слово.</p>
<p>Однажды я опубликовал статью, в которой писал, что лучше было бы это назвать ее «Сделай Это Для Меня», потому что Widget наследует NewHandler-Support&lt;Widget&gt; и как бы говорит: «Я – Widget, и я хочу наследовать классу NewHandlerSupport для Widget». Никто не станет пользоваться предложенным мной названием (даже я сам), но если думать о CRTP как о способе сказать «сделай это для меня», то вам будет проще понять смысл наследование шаблону.</p>
<p>Шаблоны, подобные NewHandlerSupport, упрощают добавление специфичных для класса обработчиков new к любому классу, которому это нужно. Однако наследование присоединяемому классу приводит к множественному наследованию, и прежде чем вставать на этот путь, вам, возможно, стоит перечитать правило 40.</p>
<p>До 1993 года C++ требовал, чтобы оператор new возвращал нулевой указатель, если не мог выделить нужную память. Теперь же operator new в этом случае должен возбуждать исключение bad_alloc. Но огромный объем кода на C++ был написан до того, как компиляторы стали поддерживать новую спецификацию. Комитет по стандартизации C++ не хотел отметать весь код, основанный на сравнении с null, поэтому было решено предоставить альтернативные формы operator new, обеспечивающие традиционное поведение с возвращением null при неудаче. Эти формы известны под названием «nothrow» (не возбуждающие исключений), потому что в них используются объекты nothrow (определенные в заголовке &lt;new&gt;) в точке, где используется new:</p>
<empty-line/><p><code>class Widget {...};</code></p>
<p><code>Widget *pw1 = new Widget; // возбуждает bad_alloc, если</code></p>
<p><code>// выделить память не удалось</code></p>
<p><code>if(pw1 == 0) ... // эта проверка <emphasis>должна</emphasis></code></p>
<p><code>// завершиться неудачно</code></p>
<p><code>Widget *pw2 = new (std::nothrow)Widget; // возвращает 0, если выделить</code></p>
<p><code>// память не удалось</code></p>
<p><code>if(pw2 == 0) ... // эта проверка может</code></p>
<p><code>// завершиться успешно</code></p>
<empty-line/><p>Не возбуждающий исключений оператор new предоставляет менее надежные гарантии относительно исключений, чем кажется на первый взгляд. В выражении «new (std::nothrow)Widget» происходят две вещи. Во-первых, nothrow-версия оператора new вызывается для выделения памяти, достаточной для размещения объекта Widget. Если получить память не удалось, то оператор new возвращает нулевой указатель, как нам и хотелось. Если же память выделить удалось, то вызывается конструктор Widget, и в этой точке все гарантии заканчиваются. Конструктор Widget может делать все, что угодно. Он может сам по себе запросить с помощью new какую-то память, и если он это делает, никто не заставляет его использовать nothrow. Хотя вызов оператора new в «new (std::nothrow)Widget» не возбуждает исключений, к конструктору Widget это не относится. И если он возбудит исключение, то оно будет распространяться как обычно. Вывод? Применение nothrow new гарантирует только то, что данный operator new не возбудит исключений, но не дает никаких гарантий относительно выражения, подобного «new (std::nothrow)Widget». А потому вряд ли стоит вообще прибегать к nothrow new.</p>
<p>Независимо от того, используете вы «нормальный» (возбуждающий исключения) new или же вариант nothrow, важно, чтобы вы понимали поведение обработчика new, поскольку он вызывается обеими формами.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• set_new_handler позволяет указать функцию, которая должна быть вызвана, если запрос на выделение памяти не может быть удовлетворен.</p>
<p>• Полезность nothrow new ограничена, поскольку эта форма применимо только для выделения памяти; последующие вызовы конструктора могут по-прежнему возбуждать исключения.</p>
</section><section><title><p>Правило 50: Когда имеет смысл заменять new и delete</p>
</title><p>Вернемся к основам. Прежде всего зачем кому-то может понадобиться подменять предлагаемые компилятором версии operator new и operator delete? Существуют, по крайней мере, три распространенные причины.</p>
<p>• <strong>Чтобы обнаруживать ошибки применения.</strong> Если не освобождать (с помощью оператора delete) память, выделенную оператором new, это приведет к утечкам памяти. Вызов delete более одного раза для одного и того же участка памяти, выделенного new, приведет к неопределенному поведению программы. Если оператор new будет вести список выделенных адресов, а оператор delete удалять адреса освобожденных областей из списка, то такие ошибки легко обнаружить. Аналогично различные ошибки в программе могут приводить к записи за концом выделенного блока (переполнению буфера) либо с адреса, предшествующего началу выделенного блока. Специализированная версия оператора new может запрашивать блоки большего размера и в неиспользуемое место до и после области, доступной пользователям, записывать некоторую комбинацию битов («сигнатуры»). При этом оператор delete может проверять наличие такой сигнатуры. Если ее нет, значит, память была затерта, и оператор delete может запротоколировать этот факт вместе со значением указателя, для которого это обнаружилось.</p>
<p>• <strong>Чтобы повысить эффективность.</strong> Версии операторов new и delete, поставляемые вместе с компилятором, универсальны. Они должны быть приемлемы как для долго работающих программ (например, Web-серверов), так и для программ, работающих менее одной секунды. Они должны уметь обрабатывать серии запросов на выделение больших блоков памяти, малых блоков, а также смеси тех и других. Они должны адаптироваться к широкому диапазону вариантов использования – от динамического выделения нескольких блоков большого размера, которые существуют на протяжении всего времени работы программы, до выделения и освобождения памяти для большого количества мелких объектов с малым временем жизни. Они должны предотвращать фрагментацию «кучи», ибо если этого не делать, то в конце концов будет невозможно удовлетворить запрос на выделение большого блока памяти, даже если суммарно такой объем имеется, но разнесен по множеству мелких участков.</p>
<p>Учитывая все требования, предъявляемые к менеджерам памяти, неудивительно, что поставляемые с компиляторами операторы new и delete придерживаются усредненной стратегии. Они работают достаточно хорошо для всех, но оптимально – ни для кого. Если вы хорошо представляете, как динамическая память используется в вашей программе, вы сможете написать собственные версии операторов new и delete, превосходящие по эффективности стандартные. Под «превосходством» я подразумеваю, что они работают быстрее (иногда на много порядков) и требуют меньше памяти (до 50 %). Для некоторых, но отнюдь не для всех, приложений замена поставляемых new и delete собственными версиями – простой способ ощутимого повышения производительности.</p>
<p>• <strong>Чтобы собирать статистику использования.</strong> Прежде чем перейти к написанию собственных new и delete, благоразумно собрать информацию о том, как ваша программа использует динамическую память. Как распределены выделяемые блоки по размерам? Как распределяется их время жизни? Порядок выделения и освобождения в основном следует принципу FIFO («первым вошел – первым вышел») или же LIFO («последним вошел – первым вышел»)? Или никакой закономерности не наблюдается? Изменяется ли характер использования памяти со временем, то есть существует ли разница в порядке выделения-освобождения памяти между разными стадиями исполнения? Какой максимальный объем динамически выделенной памяти используется в каждый момент времени?</p>
<p>По существу, написание пользовательских версий new и delete – довольно простая задача. Например, рассмотрим вкратце, как можно реализовать глобальный оператор new с контролем записи за границами выделенного блока. Правда, в нем есть множество дефектов, но пока не будем обращать на них внимания.</p>
<empty-line/><p><code>static const int signature = 0xDEADBEEF;</code></p>
<p><code>typedef unsigned char Byte;</code></p>
<p><code>// в этом коде есть несколько дефектов – см. ниже</code></p>
<p><code>void *operator new(std:size_t size) throw(std::bad_alloc)</code></p>
<p><code>{</code></p>
<p><code>using namespace std;</code></p>
<p><code>size_t realSize=size+2*sizeof(int); // увеличить размер запрошенного</code></p>
<p><code>// блока, чтобы можно было разместить</code></p>
<p><code>// сигнатуры</code></p>
<p><code>void *pMem = malloc(realSize); // вызвать malloc для получения памяти</code></p>
<p><code>if(!pMem) throw(bad_alloc);</code></p>
<p><code>// записать сигнатуру в первое и последнее слово выделенного блока</code></p>
<p><code>*(static_cast&lt;int&gt;pMem)) = signature;</code></p>
<p><code>*(reinterpret_cast&lt;int*&gt;(static_cast&lt;Byte*&gt;(pMem)+realSize-sizeof(int))) =</code></p>
<p><code>signature;</code></p>
<p><code>// вернуть указатель на память сразу за начальной сигнатурой</code></p>
<p><code>return static_cast&lt;Byte*&gt;(pMem)+sizeof(int);</code></p>
<p><code>}</code></p>
<empty-line/><p>Большинство недостатков этой версии оператора new связаны с тем, что он не вполне соответствует соглашениям C++ относительно функций с таким именем. Например, в правиле 51 объясняется, что все операторы new должны включать цикл вызова функции-обработчика new, чего этот вариант не делает. Этому соглашению посвящено правило 51, поэтому сейчас я хочу сосредоточиться на более тонком моменте: <emphasis>выравнивании.</emphasis></p>
<p>Многие компьютерные архитектуры требуют, чтобы данные конкретных типов были размещены в памяти по вполне определенным адресам. Например, архитектура может требовать, чтобы указатели размещались по адресам, кратным четырем (то есть были выровнены на границу четырехбайтового слова), а данные типа double начинались с адреса, кратного восьми. Если не придерживаться этого соглашения, то возможны аппаратные ошибки во время исполнения. Другие архитектуры более терпимы, хотя и могут демонстрировать более высокую производительность, если удовлетворены требования выравнивания. Например, на архитектуре Intel x86 значения типа double могут быть выровнены по границе любого байта, но доступ к ним будет значительно быстрее, если они выровнены по восьмибайтовым границам.</p>
<p>Выравнивание важно, потому что C++ требует, чтобы все указатели, возвращаемые оператором new, были выровнены для <emphasis>любого</emphasis> типа данных. Функция malloc подчиняется этим же требованиям, поэтому использование указателя, возвращенного malloc, безопасно. Но в приведенном выше операторе new мы не возвращаем указатель, полученный от malloc, а возвращаем <emphasis>указатель, смещенный от</emphasis> возвращенного malloc <emphasis>на размер int.</emphasis> Нет никаких гарантий, что это безопасно! Если клиент вызовет оператор new, чтобы получить память, достаточную для размещения double (либо если мы напишем оператор new[] для выделения памяти под массив значений типа double), а потом запустим программу на машине, где int занимает 4 байта, а значения double должны быть выровнены по границам восьмибайтовых блоков, то, скорее всего, вернем неправильно выровненный указатель. Это может вызвать аварийную остановку программы. Или же просто замедлить ее работу. В любом случае, это совсем не то, что мы хотели.</p>
<p>Внимание к подобным деталям отличает менеджеры памяти профессионального качества от тех, что делают на скорую руку программисты, вынужденные отвлекаться на другие задачи. Написать собственный менеджер памяти, который почти работает, достаточно просто. Написать такой, который работает <emphasis>хорошо,</emphasis> намного сложнее. Вообще говоря, я не рекомендую заниматься этим делом, если только нет настоятельной потребности.</p>
<p>Во многих случаях ее нет. Некоторые компиляторы имеют переключатели, позволяющие отлаживать и протоколировать работу функций управления памятью. Поверхностное знакомство с документацией по вашему компилятору может исключить необходимость в написании собственных версий new и delete. На многих платформах доступны коммерческие продукты, позволяющие заменить функции управления памятью, поставляемые с компиляторами. Чтобы воспользоваться их расширенной функциональностью и (предположительно) повышенной производительностью, придется лишь заново компоновать программу (ну и, само собой, заплатить).</p>
<p>Другой вариант – менеджеры памяти с открытым кодом. Они есть для многих платформ, поэтому можете скачать и попробовать. Один из таких распределителей памяти с открытым кодом – библиотека Pool из проекта Boost (см. правило 55). Библиотека Pool предлагает распределители памяти, оптимизированные для использования в одной из наиболее часто встречающихся ситуаций, где может быть оказаться полезным нестандартный менеджер памяти: распределение памяти для большого количества мелких объектов. Во многих книгах по C++, включая и ранние редакции этой, приводится код высокопроизводительного распределителя памяти для мелких объектов, но часто опускаются такие «скучные» детали, как переносимость, соглашения о выравнивании, безопасность относительно потоков и т. п. В реальные библиотеки включен гораздо более устойчивый код. Даже если вы решите написать собственные new и delete, знакомство версий с открытым кодом, вероятно, даст вам понимание тех деталей, которые отличают «почти работающие» системы от действительно работающих. Выравнивание – одна из таких деталей. Стоило бы отметить, что в отчет TR1 (см. правило 54) включена поддержка для выявления требований выравнивания, специфичных для конкретного типа.</p>
<p>Тема настоящего правила – вопрос о том, когда имеет смысл подменять версии new и delete по умолчанию – на глобальном уровне или на уровне класса. Теперь мы можем ответить на этот вопрос более подробно.</p>
<p><strong>• Чтобы обнаруживать ошибки использования</strong> (как было сказано выше).</p>
<p><strong>• Чтобы собирать статистику об использовании динамически распределенной памяти</strong> (также было сказано выше).</p>
<p><strong>• Для ускорения процесса распределения и освобождения памяти.</strong> Распределители общего назначения часто (хотя и не всегда) работают намного медленнее, чем оптимизированные версии, особенно если последние специально разработаны для объектов определенного типа. Специфичные для класса распределители являются примерами выделения блоков фиксированного размера, вроде тех, что представляет библиотека Pool из проекта Boost. Если ваше приложение однопоточное, но менеджер памяти, поставляемый с компилятором, по умолчанию потокобезопасный, то вы можете получить заметный рост производительности, написав менеджер памяти для однопоточных приложений. Конечно, прежде чем решить, что нужно переписывать операторы new и delete для повышения скорости, убедитесь с помощью профилирования, что эти функции действительно являются узким местом.</p>
<p><strong>• Чтобы уменьшить накладные расходы, характерные для стандартного менеджера памяти.</strong> Менеджеры памяти общего назначения часто (хотя не всегда) не только медленнее оптимизированных версий, но и потребляют больше памяти. Это происходит из-за того, что с каждым выделенным блоком связаны некоторые накладные расходы. Распределители, оптимизированные для мелких объектов (как, например, Pool), позволяют почти избавиться от этих расходов.</p>
<p><strong>• Чтобы компенсировать субоптимальное выравнивание в распределителях по умолчанию.</strong> Как я уже упоминал, самый быстрый доступ к значениям double на архитектуре x86 получается тогда, когда они выровнены по восьмибайтным границам. К сожалению, операторы new, поставляемые с некоторыми компиляторами, не гарантируют восьмибайтового выравнивания при динамическом выделении double. В этих случаях замена оператора new по умолчанию на специальный, который гарантирует такое выравнивание, может дать заметный рост производительности программы.</p>
<p><strong>• Чтобы сгруппировать взаимосвязанные объекты друг с другом.</strong> Если вы знаете, что определенные структуры данных обычно используются вместе, и хотите минимизировать частоту ошибок из-за отсутствия страницы в физической памяти при работе с такими данными, то, возможно, имеет смысл создать отдельную кучу для подобных структур, чтобы они были собраны вместе, или на столь небольшом числе страниц, насколько возможно. Версии операторов new и delete с размещением (см. правило 52) могут обеспечить такую группировку.</p>
<p><strong>• Чтобы получить нестандартное поведение.</strong> Иногда может понадобиться, чтобы операторы new и delete делали нечто, чего поставляемые с компилятором версии делать не умеют. Например, вам нужно распределять и освобождать блоки памяти в разделяемой памяти, но для операций с такой памятью у вас только программный интерфейс C. Написание специальных версий new и delete (возможно, с размещением – см. правило 52) позволит вам обернуть C API в классы C++. Вы также можете написать специальный оператор delete, который заполняет освобождаемую память нулями, чтобы повысить степень защиты данных в приложении.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Есть много причин для написания специальных версий new и delete, включая повышение производительности, отладку ошибок при работе с кучей, а также сбор информации об использовании памяти.</p>
</section><section><title><p>Правило 51: Придерживайтесь принятых соглашений при написании new и delete</p>
</title><p>В правиле 50 объясняется, зачем могут понадобиться собственные версии операторов new и delete, но ничего не говорится о соглашениях, которых следует придерживаться при их написании. Следовать этим соглашениям не так уж сложно, но некоторые из них противоречат интуиции, поэтому знать о них необходимо.</p>
<p>Начнем с оператора new. От отвечающего стандарту оператора new требуется, чтобы он возвращал правильное значение, вызывал обработчика new, когда запрошенную память не удается выделить (см. правило 49), и правильно обрабатывал запросы на выделения нуля байтов. Кроме того, надо принять меры к тому, чтобы нечаянно не скрыть «нормальную» форму new, хотя это в большей мере касается интерфейса класса, чем требований реализации (см. правило 52).</p>
<p>Обеспечить правильность возвращаемого оператором new значения легко. Если вы можете выделить запрошенную память, то возвращаете указатель на нее. Если не можете, то следуете рекомендациям из правила 49 и возбуждаете исключение типа bad_alloc.</p>
<p>Однако все не так просто, потому что оператор new пытается выделить память не один раз, и после каждой неудачи вызывает функцию-обработчик new. Предполагается, что это сможет что-то сделать для освобождения некоторого объема памяти. Только тогда, когда указатель на обработчик new равен нулю, оператор new возбуждает исключение.</p>
<p>Забавно, но C++ требует, чтобы оператор new возвращал корректный указатель даже тогда, когда запрошено 0 байтов памяти. (Такое странное поведение упрощает реализацию некоторых вещей в других местах языка.) С учетом этого случая псевдокод для оператора new (нечлена класса) выглядит так:</p>
<empty-line/><p><code>void *operator new(std::size_t size) throw(std::bad_alloc)</code></p>
<p><code>{ // ваш оператор new может принимать</code></p>
<p><code>using namespace std; // дополнительные параметры</code></p>
<p><code>if (size == 0) { // обработать запрос на 0 байтов,</code></p>
<p><code>size = 1; // считая, что нужно выделить 1 байт</code></p>
<p><code>}</code></p>
<p><code>while(true) {</code></p>
<p><code><emphasis>попытка выделить size байтов;</emphasis></code></p>
<p><code>if(<emphasis>выделить удалось</emphasis>)</code></p>
<p><code>return (<emphasis>указатель на память</emphasis>);</code></p>
<p><code>// выделить память не удалось; проверить, установлена ли</code></p>
<p><code>// функция-обработчик new (см. ниже)</code></p>
<p><code>new_handler globalHandler = set_new_handler(0);</code></p>
<p><code>set_new_handler(globalHandler);</code></p>
<p><code>if(globalHandler) (*globalHandler)();</code></p>
<p><code>else throw std::bad_alloc();</code></p>
<p><code>}</code></p>
<p><code>}</code></p>
<empty-line/><p>Трактовка запроса на 0 байтов так, как если бы запрашивался 1 байт, выглядит сомнительно, но это просто, это корректно, это работает, к тому же на сколько часто вы собираетесь запрашивать 0 байтов?</p>
<p>Вам также может не понравиться то место в псевдокоде, где указатель на функцию-обработчик устанавливается в нуль, а затем восстанавливается его прежнее значение. К сожалению, нет способа непосредственно получить указатель на текущий обработчик new, поэтому приходится вызывать set_new_handler, чтобы получить его текущее значение. Грубо, но тоже эффективно, по крайней мере, в однопоточной программе. В многопоточной среде, возможно, понадобится какой-то механизм синхронизации для безопасного манипулирования (глобальными) структурами данных, связанными с функцией-обработчиком new.</p>
<p>В правиле 49 отмечено, что оператор new содержит бесконечный цикл, и в приведенном выше коде этот цикл присутствует: «while(true)». Единственный способ выйти из цикла – успешно выделить память либо выполнить в функции-обработчике одно из описанных в правиле 49 действий: сделать доступной больше памяти, установить другой обработчик, убрать текущий обработчик, возбудить исключение типа, производного от bad_alloc, либо не возвращать управления вовсе. Теперь вам должно быть ясно, почему обработчик new должен вести себя подобным образом. Если он нарушит это соглашение, то цикл внутри оператора new никогда не завершится.</p>
<p>Многие не понимают, что функция-член operator new наследуется производными классами. Это может привести к некоторым интересным осложнениям. Заметьте, что в приведенном псевдокоде operator new производится попытка выделить size байтов (если только size не равно нулю). Естественно, ведь size – это аргумент, переданный функции. Однако, как объясняется в правиле 50, одной из причин написания специального менеджера памяти является оптимизация размещения объектов <emphasis>определенного</emphasis> класса, но не любых его подклассов. Иными словами, если в классе X определен оператор new, то предполагается, что он рассчитан на объекты размера sizeof(X) – ни больше, ни меньше. Из-за наследования, однако, появляется возможность вызвать оператор new базового класса, чтобы выделить память для объекта производного класса:</p>
<empty-line/><p><code>class Base {</code></p>
<p><code>public:</code></p>
<p><code>static void *operator new(std::size_t size) throw(std::bad_alloc);</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>class Derived: public Base // в подклассе не объявлен operator new</code></p>
<p><code>{...};</code></p>
<p><code>Derived *p = new Derived; // вызывается Base::operator new!</code></p>
<empty-line/><p>Если определенный в классе Base оператор new не был спроектирован с учетом этой проблемы (а такая вероятность есть), то для корректной работы в случае, когда поступил запрос на выделение памяти «неправильного» размера, лучше всего обратиться к стандартному оператору new:</p>
<empty-line/><p><code>void *Base::operator new(std::size_t) throw(std::bad_alloc)</code></p>
<p><code>{</code></p>
<p><code>if(size != sizeof(Base)) // если size «неправильный»</code></p>
<p><code>return ::operator new(size); // вызвать стандартный оператор new</code></p>
<p><code>// для обработки запроса</code></p>
<p><code>... // в противном случае обработать запрос</code></p>
<p><code>// здесь</code></p>
<p><code>}</code></p>
<empty-line/><p>Я слышу возгласы: «Подождите! Вы забыли проверить патологический случай с нулевым размером!» На самом деле нет. Проверка присутствует, просто она является частью сравнения с sizeof(Base). C++ иногда предъявляется странные требования, например все автономные объекты должны иметь ненулевой размер (см. правило 39). По определению, sizeof(Base) никогда не может вернуть нуль, поэтому если size равно нулю, то запрос будет переадесован::operator new, и обязанность правильно обработать запрос возлагается на него.</p>
<p>Если вы хотите управлять распределением памяти для массивов на уровне класса, то нужно будет реализовать оператор new[] – специально для массивов. (Эта функция обычно называется «new для массивов», потому что трудно представить, как надо произносить «operator new[]»). Если вы решите написать operator new[], то помните, что она должна лишь выделить блок неформатированной памяти. Вы не можете ничего делать с еще не существующими объектами в этом массиве. Фактически вы даже не можете определить, сколько объектов будет в этом массиве. Во-первых, вы не знаете размер объекта. А ведь из-за наследования может быть вызван оператор new[] базового класса для выделения памяти под массив объектов производного класса, которые обычно больше объектов базового класса. Поэтому вы не можете предполагать внутри Base::operator new[], что размер каждого объекта равен sizeof(Base), а значит, нельзя предполагать, что общее количество объектов в массиве будет равно <emphasis>(запрошенное число</emphasis> байmов)/sizeof(Base). Во-вторых, параметр size_t, переданный оператору new[], может соответствовать большему объему памяти, чем займут сами объекты, потому что, как объясняется в правиле 16, в динамически выделенных массивах может резервироваться место для хранения числа элементов массива.</p>
<p>Это все соглашения, которым вы должны следовать при написании оператора new[]. Что касается оператора delete, то с ним все проще. Почти все, что вам нужно знать, – это то, что C++ гарантирует безопасность освобождения памяти по нулевому адресу, поэтому и вы должны предоставить такую гарантию. Вот псевдокод для оператора delete, не являющегося членом класса:</p>
<empty-line/><p><code>void operator delete(void *rawMemory) throw()</code></p>
<p><code>{</code></p>
<p><code>if(rawMemory == 0) return; // ничего не делать, если передан нулевой</code></p>
<p><code>// указатель</code></p>
<p><code><emphasis>освободить память, на которую указывает rawMemory</emphasis></code></p>
<p><code>;</code></p>
<p><code>}</code></p>
<empty-line/><p>Версия этой функции, являющаяся членом класса, также проста, за исключением того, что нужно проверить размер того, что вы собираетесь освобождать. Предполагая, что оператор new, определенный в классе, передает запрос на выделение «неправильного» количества байтов глобальному::operator new, вы также должны передать информацию о «неверном» размере функции::operator delete:</p>
<empty-line/><p><code>class Base { // то же, что и раньше, но добавлено</code></p>
<p><code>public: // объявление operator delete</code></p>
<p><code>static void *operator new(std::size_t size) throw(std::bad_alloc);</code></p>
<p><code>static void operator delete(void *rawMemory, std::size_t size) throw();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>void Base::operator delete(void *rawMemory, std::size_t size) throw()</code></p>
<p><code>{</code></p>
<p><code>if(rawMemory == 0) return; // проверка на нулевой указатель</code></p>
<p><code>if(size != sizeof(Base)) { // если размер «неверный»,</code></p>
<p><code>::operator delete(rawMemory); // вызвать стандартный оператор</code></p>
<p><code>return; // delete для обработки запроса</code></p>
<p><code>}</code></p>
<p><code><emphasis>освободить память, на которую указывает rawMemory</emphasis></code></p>
<p><code>;</code></p>
<p><code>return;</code></p>
<p><code>}</code></p>
<empty-line/><p>Интересно, что значение типа size_t, которое C++ передает оператору delete, может быть неправильным, если удаляется объект, производный от класса, в котором нет виртуального деструктора. Одного этого уже достаточно, чтобы требовать от базового класса наличия виртуального деструктора, но в правиле 7 описана и другая, более существенная причина. Пока просто отметьте, что если вы опустили виртуальный деструктор в базовом классе, то функция operator delete может работать неправильно.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Оператор new должен содержать бесконечный цикл, который пытается выделить память, должен вызывать функцию-обработчик new, если не удается удовлетворить запрос на выделение памяти, и должен обрабатывать запрос на выделение нуля байтов. Версии оператора new уровня класса должны обрабатывать запросы на выделение блоков большего размера, чем ожидается.</p>
<p>• Оператор delete не должен ничего делать при передаче ему нулевого указателя. Версии оператора delete уровня класса должны обрабатывать запросы на освобождение блоков, которые больше, чем ожидается.</p>
</section><section><title><p>Правило 52: Если вы написали оператор new с размещением, напишите и соответствующий оператор delete</p>
</title><p>Операторы new и delete с размещением встречаются в C++ не слишком часто, поэтому в том, что вы с ними не знакомы, нет ничего страшного. Вспомните (правила 16 и 17), что когда вы пишете такое выражение new:</p>
<empty-line/><p><code>Widget *pw = new Widget;</code></p>
<empty-line/><p>то вызываются две функции: оператор new, чтобы выделить память, и конструктор Widget по умолчанию.</p>
<p>Предположим, что первый вызов завершился успешно, а второй возбудил исключение. В этом случае необходимо отменить выделение памяти, выполненное на шаге 1. В противном случае мы получим утечку памяти. Пользовательский код не может освободить память, потому что конструктор Widget возбудил исключение и pw ничего так и не было присвоено. Следовательно, пользователь так и не получил указатель на память, которая должна быть освобождена. Поэтому ответственность за отмену шага 1 возлагается на систему времени исполнения C++.</p>
<p>Исполняющая система рада бы вызвать оператор delete, соответствующий использованному на шаге 1 оператору new, но сделать это может лишь тогда, когда знает, какой именно вариант оператора delete – а их много – нужно вызвать. Это не проблема, если вы пользуетесь формами new и delete с обычными сигнатурами, потому что обычный оператор new:</p>
<empty-line/><p><code>void *operator new(std::size_t size) throw(std::bad_alloc);</code></p>
<empty-line/><p>соответствует обычному оператору delete:</p>
<empty-line/><p><code>void operator delete(void *rawMemory) throw(); // обычная сигнатура</code></p>
<p><code>// в глобальной области</code></p>
<p><code>// видимости</code></p>
<p><code>void operator delete(void *rawMemory, // наиболее распространенная</code></p>
<p><code>std::size_t size) throw(); // сигнатура в области</code></p>
<p><code>// видимости класса</code></p>
<empty-line/><p>Если вы пользуетесь только обычными формами new и delete, то исполняющая система легко найдет тот вариант delete, который знает, как отменить действие, выполненное оператором new. Проблема поиска правильного варианта delete возникает тогда, когда вы объявляете необычные формы оператора new – такие, которые принимают дополнительные параметры.</p>
<p>Например, предположим, что вы написали оператор new уровня класса, который требует задания потока ofstream, куда должна выводиться отладочная информация о выделении памяти, и вместе с ним написали также обычный оператор delete уровня класса:</p>
<empty-line/><p><code>class Widget {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>static void *operator new(std:size_t size, // необычная</code></p>
<p><code>std::ostream&amp; logStream) // форма new</code></p>
<p><code>throw(std::bad_alloc);</code></p>
<p><code>static void operator delete(void *pMemory, // обычная</code></p>
<p><code>std:size_t size) throw(); // форма delete</code></p>
<p><code>// уровня класса</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>Такое решение наверняка приведет к ошибкам, но чтобы понять, почему это так, придется познакомиться с некоторыми терминами.</p>
<p>Функция operator new, принимающая дополнительные параметры (помимо обязательного аргумента size_t), называется <emphasis>оператором new с размещением</emphasis> или <emphasis>размещающим оператором new</emphasis> (placement new). Приведенный выше оператор new как раз и является таковым. Особенно полезным бывает размещающий оператор new, для которого вторым аргументом служит указатель на область памяти, где объект должен быть сконструирован. Этот оператор new выглядит так:</p>
<empty-line/><p><code>void *operator new(std::size_t, void *pMemory) throw(); // “размещающий new”</code></p>
<empty-line/><p>Эта версия new является частью стандартной библиотеки C++, и вы получаете к ней доступ, включая в исходный текст директиву #include &lt;new&gt;. Кстати говоря, такой оператор new используется в реализации класса vector для создания объектов в выделенной для вектора памяти. Это также <emphasis>первоначальная</emphasis> версия оператора new с размещением; именно она и получила название «placement new». Таким образом, сам термин «размещающий new» перегружен. Обычно, когда говорят о <emphasis>размещающем</emphasis> new, имеют в виду эту конкретную функцию: оператор new, принимающий дополнительный аргумент типа void*. Реже так говорят о любой другой версии new, принимающей дополнительные аргументы. Обычно контекст исключает противоречивые толкования, но важно понимать, что общий термин <emphasis>«размещающий</emphasis> new» означает любую версию new, принимающую дополнительные аргументы, поскольку выражение <emphasis>«размещающий</emphasis> delete» или «delete <emphasis>с размещением»</emphasis> (которое мы сейчас обсудим) происходит от него.</p>
<p>Но вернемся к объявлению класса Widget, которое я не одобрил. Проблема в том, что этот класс открывает возможность утечки памяти. Рассмотрим следующий пользовательский код, который протоколирует информацию о выделении памяти в поток cerr при динамическом создании объектов Widget:</p>
<empty-line/><p><code>Widget *pw = new (std::cerr) Widget; // вызвать оператор new, передав cerr</code></p>
<p><code>// в качестве параметра типа ofstream;</code></p>
<p><code>// <emphasis>это ведет к утечке памяти в случае,</emphasis></code></p>
<p><code>// <emphasis>когда конструктор Widget возбуждает</emphasis></code></p>
<p><code>// <emphasis>исключение</emphasis></code></p>
<empty-line/><p>Если выделение памяти прошло успешно, но конструктор Widget возбуждает исключение, то исполняющая система отвечает за освобождение той памяти, которую успел выделить оператор new. Исполняющая система понятия не имеет, как работает вызванная версия оператора new, поэтому не может отменить результат операции самостоятельно. Вместо этого исполняющая система ищет версию оператора delete, которая принимает <emphasis>то же количество аргументов того же типа,</emphasis> что и new, и если находит его, то вызывает. В данном случае оператор new принимает дополнительный аргумент типа ostream&amp;, поэтому соответствующий оператор delete должен иметь следующую сигнатуру:</p>
<empty-line/><p><code>void operator delete(void *, std::ostream&amp;) throw();</code></p>
<empty-line/><p>По аналогии с размещающими версиями new версии оператора delete, которые принимают дополнительные параметры, называются <emphasis>размещающими delete.</emphasis> Но в классе Widget не объявлена размещающая версия оператора delete, поэтому исполняющая система не знает, как отменить то, что сделал размещающий new. В результате она не делает ничего. В этом примере <emphasis>никакой оператор delete не вызывается,</emphasis> если конструктор Widget возбуждает исключение!</p>
<p>Правило простое: если оператору new с дополнительными аргументами не соответствует оператор delete с такими же аргументами, то никакой delete не вызывается в случае необходимости отменить выделение памяти, выполненное new. Чтобы избежать утечек памяти в приведенном выше коде, Widget должен объявить размещающий оператор delete, который соответствует размещающему оператору new, который выполняет протоколирование:</p>
<empty-line/><p><code>class Widget {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>static void *operator new(std:size_t size, std::ostream&amp; logStream)</code></p>
<p><code>throw(std::bad_alloc);</code></p>
<p><code>static void operator delete(void *pMemory) throw();</code></p>
<p><code>static void operator delete(void *pMemory, std::ostream&amp; logStream)</code></p>
<p><code>throw();</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><p>С этим изменением, если конструктор Widget возбудит исключение в предложении</p>
<empty-line/><p><code>Widget *pw = new (std::cerr) Widget; // как раньше, но теперь никаких</code></p>
<p><code>// утечек</code></p>
<empty-line/><p>то автоматически будет вызван соответственный размещающий оператор delete, так что Widget гарантирует, что никаких утечек памяти по этой причине не будет.</p>
<p>Посмотрим, что произойдет, если никаких исключений нет (как обычно и бывает), а в пользовательском коде присутствует явный вызов delete:</p>
<empty-line/><p><code>delete pw; // вызов обычного оператора delete</code></p>
<empty-line/><p>Как сказано в комментарии, здесь вызывается обычный оператор delete, а не размещающая версия. Размещающий delete вызывается, <emphasis>только</emphasis> если возбуждает исключение конструктор, следующий за вызовом размещающего new. Если delete применяется к указателю (в примере выше – pw), то версия delete с размещением <emphasis>никогда</emphasis> не будет вызвана.</p>
<p>Это значит, что для предотвращения всех утечек памяти, ассоциированных с размещающей версией new, вы должны также предоставить и обычный оператор delete (на случай, если в конструкторе не возникнет исключений), и размещающую версию с теми же дополнительными аргументами, что и у размещающего new (если таковой имеется). Поступайте так, и вы никогда не потеряете сон из-за неуловимых утечек памяти. Ну, по крайней мере, из-за утечек памяти <emphasis>по этой причине.</emphasis></p>
<p>Кстати, поскольку имена функций-членов скрывают одноименные функции в объемлющих контекстах (см. правило 33), вы должны быть осторожны, чтобы избежать того, что операторы new уровня класса скроют другие версии new (в том числе обычные), на которые рассчитывают пользователи. Например, если у вас есть базовый класс, в котором объявлена только размещающая версия оператора new, пользователи обнаружат, что обычная форма new стала недоступной:</p>
<empty-line/><p><code>class Base {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>static void *operator new(std::size_t size, // скрывает обычные</code></p>
<p><code>std::ostream&amp; logStream) // глобальные формы</code></p>
<p><code>throw(std::bad_alloc);</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>Base *pb = new Base; // ошибка! Обычная форма</code></p>
<p><code>// оператора new скрыта</code></p>
<p><code>Base *pb = new (std::cerr)Base; // правильно, вызывается</code></p>
<p><code>// размещающий new из Base</code></p>
<empty-line/><p>Аналогично оператор new в производных классах скрывает и глобальную, и унаследованную версии оператора new:</p>
<empty-line/><p><code>class Derived: public Base {</code></p>
<p><code>public:</code></p>
<p><code>...</code></p>
<p><code>static void *operator new(std::size_t size) // переопределяет</code></p>
<p><code>throw(std::bad_alloc); // обычную форму new</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<p><code>Derived *pd = new (std::cerr)Derived; // ошибка! заменяющая</code></p>
<p><code>// форма теперь скрыта</code></p>
<p><code>Derived *pd = new Derived; // правильно, вызывается</code></p>
<p><code>// оператор new из Derived</code></p>
<empty-line/><p>В правиле 33 достаточно подробно рассмотрен этот вид сокрытия имен в классе, но при написании функций распределения памяти нужно помнить, что по умолчанию C++ представляет следующие формы оператора new в глобальной области видимости:</p>
<empty-line/><p><code>void operator new(std::size_t) throw(bad_alloc); // обычный new</code></p>
<p><code>void operator new(std::size_t, void*) throw(bad_alloc); // размещающий new</code></p>
<p><code>void operator new(std::size_t, // new, не возбуждающий</code></p>
<p><code>const std::nothrow_t&amp;) throw(); // исключений –</code></p>
<p><code>// см. правило 49</code></p>
<empty-line/><p>Если вы объявляете любой оператор new в классе, то тем самым скрываете все эти стандартные формы. Убедитесь, что вы сделали их доступными в дополнение к любым специальным формам new, объявленным вами в классе, если только в ваши намерения не входит запретить использование этих форм пользователям класса. И для каждого оператора new, к которому вы даете доступ, должен быть также предоставлен соответствующий оператор delete. Если вы хотите, чтобы эти функции вели себя обычным образом, просто вызывайте соответствующие глобальные их версии из своих функций.</p>
<p>Самый простой способ – создать базовый класс, содержащий все нормальные формы new и delete:</p>
<empty-line/><p><code>class StandardNewDeleteForms {</code></p>
<p><code>public:</code></p>
<p><code>// нормальные new/delete</code></p>
<p><code>static void *operator new(std::size_t size) throw(bad_alloc)</code></p>
<p><code>{ return ::operator new(size);}</code></p>
<p><code>static void operator delete(void *pMemory) throw()</code></p>
<p><code>{ ::operator delete(pMemory);}</code></p>
<p><code>// размещающие new/delete</code></p>
<p><code>static void *operator new(std::size_t size, void *ptr) throw(bad_alloc)</code></p>
<p><code>{ return ::operator new(size, ptr);}</code></p>
<p><code>static void operator delete(void *pMemory, void *ptr) throw()</code></p>
<p><code>{ ::operator delete(pMemory, ptr);}</code></p>
<p><code>// не возбуждающие исключений new/delete</code></p>
<p><code>static void *operator new(std::size_t, const std::nothrow_t&amp; nt) throw()</code></p>
<p><code>{ return ::operator new(size, nt)}</code></p>
<p><code>static void operator delete(void *pMemory, const std::nothrow_t&amp;) throw()</code></p>
<p><code>{ ::operator delete(pMemory, nt);}</code></p>
<p><code>};</code></p>
<empty-line/><p>Пользователи, которые хотят пополнить свой арсенал специальными формами new, применяют наследование и using-объявления (см. правило 33), чтобы получить доступ к стандартным формам:</p>
<empty-line/><p><code>class Widget: public StandardNewDeleteForms { // наследование</code></p>
<p><code>public: // стандартных форм</code></p>
<p><code>using StandardNewDeleteForms::operator new; // сделать эти формы</code></p>
<p><code>using StandardNewDeleteForms::operator delete; // видимыми</code></p>
<p><code>static void *operator new(std::size_t size, // добавляется</code></p>
<p><code>std::ostream&amp; logStream) // специальный</code></p>
<p><code>throw(bad_alloc); // размещающий new</code></p>
<p><code>static void operator delete(void *pMemory, // добавляется</code></p>
<p><code>std::ostream&amp; logStream) // соответствующий</code></p>
<p><code>throw(); // размещающий delete</code></p>
<p><code>...</code></p>
<p><code>};</code></p>
<empty-line/><subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Когда вы пишете размещающую версию оператора new, убедитесь, что не забыли о соответственном размещающем операторе delete. Если его не будет, то в вашей программе могут возникать тонкие, трудноуловимые утечки памяти.</p>
<p>• Объявляя размещающие версии new и delete, позаботьтесь о том, чтобы нечаянно не скрыть нормальных версий этих функций.</p>
</section></section><section><title><p>Глава 9</p>
<p>Разное</p>
</title><section><p>Несмотря на то что эта глава состоит всего из трех правил, все они очень важны.</p>
<p>В первом правиле подчеркивается, что предупреждения компилятора – не пустяк, на который можно не обращать внимания. По крайней мере, если вы хотите, чтобы ваши программы вели себя правильно. Во втором представлен обзор стандартной библиотеки C++, включая и новую функциональность, предложенную в отчете TR1. И наконец, в последнем правиле представлен обзор проекта Boost – возможно, наиболее важного Web-сайта, посвященного общим вопросам применения C++. Игнорируя советы, изложенные в этих правилах, писать эффективные программы на C++ как минимум нелегко.</p>
</section><section><title><p>Правило 53: Обращайте внимание на предупреждения компилятора</p>
</title><p>Многие программисты зачастую игнорируют предупреждения компилятора. В конце концов, если бы проблема была по-настоящему серьезной, компилятор выдал бы ошибку! Подобные рассуждения могут быть сравнительно безвредными при работе с какими-нибудь другими языками, но в отношении C++ можно поручиться, что создатели компиляторов точнее вас оценивают истинное положение дел. Например, ниже приведена ошибка, которую рано или поздно допускает каждый из нас:</p>
<empty-line/><p><code>class B {</code></p>
<p><code>public:</code></p>
<p><code>virtual void f() const;</code></p>
<p><code>};</code></p>
<p><code>class D: public B {</code></p>
<p><code>public:</code></p>
<p><code>virtual void f();</code></p>
<p><code>};</code></p>
<empty-line/><p>Предполагается, что функция D::f будет переопределять виртуальную функцию B::f, но ошибка состоит в следующем: в классе B функция-член f – константная, а в D она не объявляется как const. Один из известных мне компиляторов сообщает следующее:</p>
<empty-line/><p><code>warning: D::f() hides virtual B::f()</code></p>
<p><code>(предупреждение: D::f() скрывает virtual B::f())</code></p>
<empty-line/><p>Многие неопытные программисты, получив подобное сообщение, говорят себе: «Конечно, D::f скрывает B::f – так и должно быть!» Они неправы. Вот что пытается сказать компилятор: f, объявленная в B, не была объявлена повторно в D, а полностью спрятана (объяснение причины этого явления см. в правиле 33). Если оставить без внимания данное предупреждение, это почти наверняка приведет к ошибочному поведению программы, и, чтобы найти причину, потребуются долгие часы отладки – при том, что компилятор давно уже все обнаружил.</p>
<p>По мере того как вы приобретете опыт работы с предупреждениями конкретного компилятора, уже нетрудно будет понимать, что означают различные сообщения (к сожалению, нередко реальное значение сообщения кардинально отличается от <emphasis>предполагаемого).</emphasis> Потренировавшись, вы впоследствии сможете спокойно игнорировать целый ряд предупреждений, хотя обычно лучше писать код, при компиляции которого компилятор не выдает никаких предупреждений, даже при выборе наивысшего уровня диагностики. Как бы то ни было, прежде чем отклонить предупреждение, важно убедиться, что вы точно вникли в его смысл.</p>
<p>Раз уж мы затронули тему предупреждений, стоит заметить, что они по своей природе зависимы от реализации, поэтому не следует слишком расслабляться и перекладывать на компилятор обнаружение ваших ошибок. Например, код с сокрытием функции, приведенный выше, проходит через другой (к сожалению, широко распространенный) компилятор без каких-либо предупреждений.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Принимайте всерьез предупреждения компилятора и старайтесь добиться того, чтобы ваш код вообще не вызывал предупреждений, даже при задании максимального уровня диагностики.</p>
<p>• Не впадайте в зависимость от предупреждений компилятора, потому что разные компиляторы предупреждают о разных вещах. При переходе на новый компилятор могут пропасть некоторые предупреждения, на которые вы привыкли полагаться.</p>
</section><section><title><p>Правило 54: Ознакомьтесь со стандартной библиотекой, включая TR1</p>
</title><p>Стандарт C++ (документ, описывающий язык и его библиотеку) был ратифицирован в 1998 году. В 2003 году были внесены небольшие изменения, исправляющие ошибки. Комитет по стандартизации, однако, продолжает работать, и появление «Версии 2.0» стандарта C++ ожидается примерно в 2008 году. Неопределенность относительно точной даты объясняет, почему обычно при ссылке на следующую версию C++ говорят «С++0х» (версию C++ 200х-го года).</p>
<p>Предположительно, C++0x будет описывать некоторые интересные дополнения к самому языку, но большая часть новой функциональности C++ будет иметь вид добавлений к стандартной библиотеке. Мы уже знаем кое-что из того, что появится в библиотеке, потому что это специфицировано в документе, известном под названием TR1 («Technical Report 1»), созданном рабочей группой по библиотеке C++. Комитет по стандартизации сохраняет за собой право модифицировать описанную в TR1 функциональность, прежде чем она будет включена в официальный стандарт C++0x, но существенные изменения маловероятны. С практической точки зрения, TR1 возвещает начало новой редакции C++, которую можно было бы назвать стандартом C++ 1.1. Нельзя быть эффективно работающим программистом C++, не будучи знакомым с функциональностью, описанной в TR1, потому что она полезна для библиотек и приложений почти любого типа.</p>
<p>Прежде чем дать краткий обзор того, что включено в TR1, стоит вспомнить основные части стандартной библиотеки C++, специфицированные в C++98:</p>
<p>• <strong>Стандартная библиотека шаблонов (STL),</strong> включающая контейнеры (vector, string, map и т. п.); итераторы; алгоритмы (find, sort, transform и т. п.); функциональные объекты (less, greater и т. п.) и различные адаптеры контейнеров и функциональных объектов (stack, priority_queue, mem_fun, not1 и т. п.).</p>
<p>• <strong>Потоки ввода-вывода (iostreams),</strong> включая поддержку определенной пользователем буферизации, интернационализацию ввода-вывода и предопределенные объекты – cin, cout, cerr и clog.</p>
<p>• <strong>Поддержка интернационализации,</strong> включая возможность иметь несколько активных локалей. Типы наподобие wchar_t (обычно 16-битные char) и wstring (строки, состоящие из wchar_t), облегчающие работу с кодировкой Unicode.</p>
<p>• <strong>Поддержка численных методов,</strong> включая шаблоны для комплексных чисел (complex) и массивы чистых значений (valarray).</p>
<p>• <strong>Иерархия исключений,</strong> включая базовый класс exception, производные от него – logic_error и runtime_error, а также разнообразные классы, наследующие этим.</p>
<p>• <strong>Стандартная библиотека C89.</strong> Все, что есть в стандартной библиотеке C 1989 года, есть и в C++.</p>
<p>Если что-то из перечисленного вам незнакомо, я советую найти время и исправить ситуацию, обратившись к вашему любимому руководству по C++.</p>
<p>TR1 специфицирует 14 новых компонентов библиотеки. Все они находятся в пространстве имен std, точнее, во вложенном пространстве tr1. Таким образом, полное наименование компонента TR1 shared_ptr (см. ниже) – std::tr1::shared_ptr. В этой книге я иногда пропускаю std::, когда говорю о компонентах стандартной библиотеки, но всегда указываю префикс tr1::.</p>
<p>В настоящей книге были приведены примеры следующих компонентов TR1:</p>
<p>• <strong>«Интеллектуальные» указатели</strong> tr1::shared_ptr и tr1::weak_ptr. tr1::shared_ptr работает как встроенный указатель, но отслеживает, сколько экземпляров tr1::shared_ptr указывает на объект. Этот прием называется <emphasis>подсчет ссылок</emphasis> (reference counting). Когда уничтожается последний такой указатель (то есть счетчик ссылок на объект становится равным 0), объект автоматически удаляется. Это удобно для предотвращения утечек памяти в ациклических структурах данных, но если два или более объектов содержат ссылающиеся друг на друга указатели tr1::shared_ptr, которые образуют цикл, то счетчики ссылок могут оставаться положительными, даже если все внешние указатели на объекты, образующие цикл, будут уничтожены (то есть группа объектов в целом недостижима). В такой ситуации и наступает очередь «слабых указателей» tr1::weak_ptr. Смысл их в том, чтобы выступать в роли указателей, создающих циклы в структурах данных, основанных на применении tr1::shared_ptr, которые в противном случае были бы ацикличны. Указатели tr1::weak_ptr не участвуют в подсчете ссылок. Когда разрушается последний указатель tr1::shared_ptr на объект, то объект удаляется, даже если на него продолжает указывать какой-нибудь tr1::weak_ptr. Однако такие указатели tr1::weak_ptr автоматически помечаются как недействительные.</p>
<p>tr1::shared_ptr, может быть, наиболее полезный компонент TR1. Я многократно прибегал к нему в этой книге, в том числе в правиле 13, где объяснял, почему это так важно. (К сожалению, в книге не нашлось места для tr1::weak_ptr.)</p>
<p>• <strong>tr1::function</strong> дает возможность представить любую <emphasis>вызываемую сущность</emphasis> (то есть любую функцию или функциональный объект), чья сигнатура совместима с целевой сигнатурой. Если мы хотим обеспечить возможность регистрации функций обратного вызова, которые принимают параметр int и возвращают string, то можем сделать следующее:</p>
<empty-line/><p><code>void registerCallback(std::string func(int)); // типом параметра</code></p>
<p><code>// является функция</code></p>
<p><code>// принимающая int и</code></p>
<p><code>// возвращающая string</code></p>
<empty-line/><p>Имя параметра – func – необязательно, поэтому registerCallback может быть объявлена и так:</p>
<empty-line/><p><code>void registerCallback(std::string (int)); // то же, что выше; имя</code></p>
<p><code>// параметра опущено</code></p>
<empty-line/><p>Отметим, что «std::string (int)» – это сигнатура функции. tr1::function позволяет сделать функцию registerCallback намного более гибкой за счет того, что ее аргументом может быть любая вызываемая сущность, которая принимает параметр int или <emphasis>нечто преобразуемое в int</emphasis> и возвращает string или <emphasis>нечто преобразуемое в string.</emphasis> tr1::function принимает в качестве шаблонного параметра сигнатуру целевой функции:</p>
<empty-line/><p><code>void registerCallback(std::tr1::function&lt;std::string (int)&gt; func);</code></p>
<p><code>// параметр func – это любая вызываемая</code></p>
<p><code>// сущность с сигнатурой, совместимой</code></p>
<p><code>// с “std::string (int)”</code></p>
<empty-line/><p>Гибкость такого рода удивительно удобна. Я постарался продемонстрировать ее в правиле 35.</p>
<p>• <strong>tr1::bind</strong> делает все, на что способны адаптеры-связыватели STL bind1st и bind2nd, плюс многое другое. В отличие от связывателей, существовавших до TR1, tr1::bind может работать как с константными, так и с неконстантными функциями-членами. Допускаются также параметры, передаваемые по ссылке. Кроме того, в отличие от старых связывателей, tr1::bind не нуждается в помощи со стороны при работе с указателями на функции, поэтому обращаться к ptr_fun, mem_fun или mem_fun_ref перед вызовом tr1::bind больше нет нужды. Проще говоря, tr1::bind – это связыватель второго поколения, которое существенно лучше своих предшественников. Пример использования я привел в правиле 35.</p>
<p>Прочие компоненты TR1 я разделил на две группы. Первая группа представляет довольно дискретную, самостоятельную функциональность:</p>
<p>• <strong>Хэш-таблицы</strong> используются для реализации контейнеров, подобных set, multiset, map и multimap. Интерфейсы новых контейнеров смоделированы на основе соответствующего компонента из предыдущей версии библиотеки. Наиболее удивительны в хэш-таблицах TR1 имена: tr1::unordered_set, tr1::unordered_multiset, tr1::unordered_map, tr1::unordered_multimap. Они отражают тот факт, что в отличие от set, multiset, map или multimap, элементы кэшированных контейнеров TR1 никак не упорядочены.</p>
<p>• <strong>Регулярные выражения,</strong> включая возможность поиска и замены в строках, перебора соответствий и т. п.</p>
<p>• <strong>Кортежи (tuples)</strong> – изящные обобщения шаблона pair, уже имеющегося в стандартной библиотеке. Если объект типа pair может содержать только два объекта, то объект tr1::tuple может служить вместилищем для произвольного числа других объектов. Эмигранты из стран Python и Eiffel, возрадуйтесь! Теперь в C++ появилась горсть и вашей родной земли.</p>
<p>• <strong>tr1::array</strong> – по существу, «STL-изированный» массив, то есть массив, поддерживающий такие функции-члены, как begin и end. Размер tr1::array фиксируется при компиляции; этот объект не использует динамической памяти.</p>
<p>• <strong>tr1::mem_fn</strong> – синтаксически унифицированный способ адаптации указателей на функции-члены. Как tr1::bind обобщает связыватели bind1st и bind2nd из библиотеки C++98, так и tr1::mem_fn расширяет возможности mem_fn и mem_fn_ref.</p>
<p>• <strong>tr1::reference_wrapper</strong> – средство, предназначенное для того, чтобы придать ссылкам большее сходство с объектами. В частности, это дает возможность создавать контейнеры, которые ведут себя так, будто содержат ссылки (в действительности контейнер может содержать только объекты или указатели).</p>
<p>• <strong>Генератор случайных чисел</strong> – средство, намного превосходящее функцию rand, которую C++ унаследовал от стандартной библиотеки C.</p>
<p>• <strong>Специальные математические функции,</strong> включая полиномы Лагерра, функции Бесселя, полные эллиптические интегралы и многое другое.</p>
<p>• <strong>Расширения, совместимые с C99,</strong> – набор функций и шаблонов, предназначенных для включения в C++ многих новых средств из библиотеки C99.</p>
<p>Второй набор компонентов TR1 обеспечивает поддержку более изощренной техники программирования с применением шаблонов, включая и метапрограммирование шаблонов (см. правило 48):</p>
<p>• <strong>Характеристики типов (type traits)</strong> – набор классов для предоставления информации о типах во время компиляции (см. правило 47). По данному типу T классы-характеристики TR1 могут узнать, является ли он встроенным, обладает ли виртуальным деструктором, представляет ли пустой класс (см. правило 39), может ли быть неявно преобразован в некоторый другой тип U и многое другое. Классы-характеристики TR1 также могут также определить правильное выравнивание для данного типа, что очень важно при написании специализированных функций распределения памяти (см. правило 50).</p>
<p><strong>• tr1::result_of</strong> – шаблон, позволяющий вывести тип значения, возвращаемого функцией. При написании шаблонов часто важно иметь возможность ссылаться на тип объекта, возвращаемого при вызове функции (шаблона), но этот тип может сложным образом зависеть от типов параметров. tr1::result_of упрощает определение возвращаемого типа значения, возвращаемого функцией… tr1::result_of используется и во многих местах в самой библиотеке TR1.</p>
<p>Несмотря на то что некоторые части TR1 (в частности, tr1::bind и tr1::mem_fn) обобщают ранее существовавшие компоненты, все же TR1 содержит и немало совсем новых возможностей. Ни один из компонентов TR1 не заменяет существующих, поэтому унаследованный код будет продолжать работать.</p>
<p>Отчет TR1 сам по себе – всего лишь документ<a type="note" l:href="#n_4">[4]</a>. Чтобы воспользоваться преимуществами описанной в нем функциональности, необходим доступ к ее реализации. Рано или поздно код будет поставляться вместе с компиляторами, но в 2005 году, когда писалась настоящая книга, вероятно, не все включенное в TR1 вошло в состав имеющейся у вас реализации стандартной библиотеки. К счастью, нужные компоненты можно найти и в других местах: 10 из 14 компонентов TR1 основаны на библиотеках, доступных на сайте Boost (см. правило 55), поэтому это отличный источник TR1-подобной функциональности. Я говорю «TR1-подобной», потому что хотя значительная часть того, что описано в TR1, и базируется на библиотеках Boost, есть некоторые моменты, в которых нынешние версии Boost не вполне соответствуют спецификации TR1. Возможно, когда вы будете читать эту главу, Boost не только будет предоставлять полностью соответствующую TR1 реализацию, но также и те четыре компонента, которые вошли в TR1 независимо.</p>
<p>Если вы предпочитаете применять TR1-подобные библиотеки Boost в качестве временной меры, до тех пор, пока вместе с компиляторами не начнут поставляться собственные реализации TR1, возможно, вам придется применить трюк с пространствами имен. Все компоненты Boost находятся в пространстве имен boost, тогда как компоненты TR1 должны находиться в пространстве std::tr1. Вы можете указать компилятору, чтобы он воспринимал ссылки на пространство std::tr1 как на boost. Вот как это делается:</p>
<empty-line/><p><code>namespace std {</code></p>
<p><code>namespace tr1 = ::boost; // std::tr1 – псевдоним для пространства boost</code></p>
<p><code>}</code></p>
<empty-line/><p>Технически такое поведение считается неопределенным, потому что, как объяснено в правиле 25, запрещается добавлять что-либо в пространство имен std. На практике, однако, возникновение проблем маловероятно. Когда ваш компилятор предоставит собственную реализацию TR1, вам нужно будет только удалить показанный выше псевдоним пространства имен. Код, ссылающийся на std::tr1, останется правильным.</p>
<p>Возможно, наиболее важная часть TR1, которая не базируется на библиотеках Boost, – это хэш-таблицы. Но хэш-таблицы доступны уже много лет из нескольких источников под именами hash_set, hash_multiset, hash_map и hash_ multimap. Есть неплохой шанс, что библиотеки, поставляемые с вашим компилятором, уже содержат эти шаблоны. Если нет, попросите вашу любимую поисковую машину найти эти имена (как и их аналоги в TR1). Наверняка вы найдете несколько источников – как коммерческих, так и открытых.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Основная функциональность стандартной библиотеки C++ состоит из STL, потоков iostream и локалей. Также включена стандартная библиотека C99.</p>
<p>• TR1 добавляет поддержку «интеллектуальных» указателей (например, tr1::shared_ptr), обобщенных указателей на функции (tr1::function), кэшированных контейнеров, регулярных выражений и еще 10 компонентов.</p>
<p>• Отчет TR1 сам по себе – всего лишь спецификация. Чтобы воспользоваться преимуществами TR1, понадобится реализация. Одним из источников реализаций компонентов TR1 является проект Boost.</p>
</section><section><title><p>Правило 55: Познакомьтесь с Boost</p>
</title><p>Вы ищете высококачественные библиотеки с открытым кодом, независимые от платформ и компиляторов? Boost к вашим услугам. Вы хотели бы присоединиться к сообществу амбициозных, талантливых программистов на C++, работающих в русле современных представлений о проектировании и реализации библиотек? Boost к вашим услугам. Хотите одним глазком взглянуть на то, как будет выглядеть C++ в будущем? Boost к вашим услугам.</p>
<p>Проект Boost – это одновременно сообщество разработчиков и набор свободно распространяемых библиотек на C++. Его Web-сайт находится по адресу <a l:href="http://boost.org/">http://boost.org</a>. Сделайте закладку немедленно!</p>
<p>Существует множество организаций и Web-сайтов, посвященных C++, но Boost обладает двумя уникальными особенностями. Во-первых, он имеет тесные связи с комитетом по стандартизации C++ и способен влиять на его решения. Boost был основан членами этого комитета, и участники одного часто являются также членами другого. Вдобавок к этому Boost всегда провозглашал одной из своих целей служить платформой для тестирования средств, которые могут быть добавлены в Стандарт C++. Одним из результатов таких отношений стало то, что из 14 новых библиотек, предложенных для включения в C++ в отчете TR1 (см. правило 54), более двух третей основаны на работе, проделанной в Boost.</p>
<p>Вторая особенность Boost – процедура приема библиотек. В ее основе лежит публичное обсуждение исходного текста всеми заинтересованными лицами. Если вы хотите предложить библиотеку для Boost, начинайте с отправки письма в список рассылки для разработчиков Boost, чтобы оценить, насколько велик интерес к вашей работе, и инициировать процесс ее предварительного обсуждения. С этого начинается цикл, который на Web-сайте называется «Обсудить, улучшить, подать на рассмотрение снова. Повторять, пока не будет достигнут удовлетворительный результат».</p>
<p>В конечном итоге вы решаете, что ваша библиотека готова для формального внесения на рассмотрение. Менеджер по приемке подтверждает, что она удовлетворяет минимальным требованиям Boost. Например, она должна компилироваться как минимум двумя компиляторами (чтобы продемонстрировать переносимость). Вы также должны подтвердить, что библиотека может быть доступна на приемлемых условиях лицензирования (например, быть бесплатна для коммерческого и некоммерческого использования). Затем ваше предложение предоставляется на официальное рассмотрение сообщества Boost. Во время периода рассмотрения добровольцы изучают представленные вами материалы (исходный код, проектную документацию, пользовательскую документацию и т. п.) и задаются следующими вопросами:</p>
<p>• Насколько хороши проект и реализация?</p>
<p>• Является ли код переносимым между компиляторами и операционными системами?</p>
<p>• Будет ли библиотека использоваться теми, для кого предназначена, то есть людьми, работающими в соответствующей предметной области?</p>
<p>• Является ли документация ясной, полной и точной?</p>
<p>Замечания отправляются в список рассылки Boost, чтобы все могли с ними ознакомиться и прокомментировать. В конце периода обсуждения менеджер по приемке решает, является ли ваша библиотека принятой, условно принятой либо отвергнутой.</p>
<p>Открытое обсуждение позволяет оградить Boost от плохо написанных библиотек, но также помогает авторам уяснить для себя, что входит в понятие проектирования, реализации и документирования кросс-платформенных библиотек промышленного уровня. Для многих библиотек требуется более одного официального рассмотрения, прежде чем их сочтут достойными одобрения.</p>
<p>Boost содержит десятки библиотек, и к ним постоянно добавляются новые. Время от времени та или иная библиотека исключается, как правило, потому, что ее функциональность перекрывается более новой библиотекой, предоставляющей более широкий диапазон возможностей или лучше спроектированной (то есть более гибкой или эффективной).</p>
<p>Библиотеки сильно отличаются по размерам и областям применения. На одном полюсе находятся библиотеки, концептуально требующие лишь нескольких строк кода (но обычно после добавления обработки ошибок и обеспечения переносимости они становятся намного длиннее). Одной из таких библиотек является <strong>Conversion,</strong> которая представляет безопасные и более удобные операторы приведения. Например, входящая в нее функция numeric_cast возбуждает исключение, если преобразование одного числового типа в другой приводит к переполнению, потере значимости либо другим подобным проблемам, а функция lexical_cast позволяет привести любой тип, поддерживающий operator&lt;&lt;, к строке, что очень удобно для диагностики, протоколирования и т. п. Другую крайность составляют библиотеки, представляющие настолько широкие возможности, что им можно посвящать целые книги. Это относится к библиотеке <strong>Boost Graph Library</strong> (для программирования произвольных структур графов), и <strong>Boost MPL Library</strong> («библиотека метапрограммирования»).</p>
<p>Библиотеки Boost посвящены самым разным темам, сгрупированным в несколько основных категорий:</p>
<p>• <strong>Обработка строк и текстов.</strong> Сюда входят библиотеки для безопасного по отношению к типам форматирования (по аналогии с printf), работы с регулярными выражениями (легли в основу соответствующей функциональности TR1 – см. правило 54), а также лексического и грамматического анализа.</p>
<p>• <strong>Контейнеры.</strong> Сюда входят библиотеки для работы с массивами фиксированной длины с STL-подобным интерфейсом (см. правило 54), битовыми наборами произвольной длины, а также многомерными массивами.</p>
<p>• <strong>Функциональные объекты и высокоуровневое программирование.</strong> Эта категория объединяет несколько библиотек, которые лежат в основе функциональности TR1. Одной из наиболее интересных является библиотека Lambda, которая настолько упрощает создание функциональных объектов на лету, что вы вряд ли даже осознаете, что происходит:</p>
<empty-line/><p><code>using namespace boost::lambada; // включить средства</code></p>
<p><code>// из библиотеки Lambda</code></p>
<p><code>std::vector &lt;int&gt; v;</code></p>
<p><code>...</code></p>
<p><code>std::for_each(v.begin(), v_end(), // для каждого элемента x</code></p>
<p><code>std::cout &lt;&lt;_1*2+10&lt;&lt;”\n”); // в v напечатать x*2+10;</code></p>
<p><code>// “_1” – место для</code></p>
<p><code>// подстановки текущего</code></p>
<p><code>// элемента</code></p>
<empty-line/><p>• <strong>Обобщенное программирование.</strong> Сюда входит широкий набор классов-характеристик (см. правило 47).</p>
<p>• <strong>Метапрограммирование шаблонов</strong> (TMP – см. правило 48). Включает библиотеку утверждений (assertions) времени компиляции, а также библиотеку Boost MPL Library. Среди прочего она поддерживает STL-подобные структуры данных, описывающие сущности времени компиляции, к примеру <emphasis>типы:</emphasis></p>
<empty-line/><p><code>// создать контейнер времени компиляции, подобный списку, содержащий</code></p>
<p><code>// три типа (float, double и long double), и назвать его “floats”</code></p>
<p><code>typedef boost::mpl::list&lt;float, double, long double&gt; floats;</code></p>
<p><code>// создать новый контейнер времени компиляции, содержащий типы</code></p>
<p><code>// из “floats”, плюс “int”, вставленный в начало; назвать новый</code></p>
<p><code>// контейнер “types”</code></p>
<p><code>typedef boost::mpl::push_front&lt;floats, int&gt;::type types;</code></p>
<empty-line/><p>Такие контейнеры типов (их часто называют <emphasis>спискамии типов – typelists,</emphasis> хотя они могут быть основаны не только на классе mpl::list, но и на mpl::vector) открывают возможность написания широкого диапазона мощных и полезных TMP-приложений.</p>
<p>• <strong>Математика и численные методы.</strong> Сюда входят библиотеки для работы с рациональными числами, поиска наибольшего общего делителя и наименьшего общего кратного, а также для операций со случайными числами (еще одна библиотека, оказавшая влияние на включение соответствующей функциональности в отчет TR1).</p>
<p>• <strong>Корректность и тестирование.</strong> Сюда входят библиотеки для формализации неявных шаблонных интерфейсов (см. правило 41) и поддержки программирования на основе методологии «тестирования с самого начала».</p>
<p>• <strong>Структуры данных.</strong> Сюда отнесены библиотеки для поддержки безопасных по отношению к типам объединений (то есть «любых» неоднородных типов) и библиотека кортежей, которая нашла применение в TR1.</p>
<p>• <strong>Межъязыковая поддержка.</strong> Содержит библиотеку, обеспечивающую «бесшовное» взаимодействие между программами, написанными на языках C++ и Python.</p>
<p>• <strong>Память.</strong> Сюда входит библиотека Pool для высокопроизводительных распределителей памяти блоками фиксированного размера (см. правило 50), а также целый ряд «интеллектуальных» указателей (см. правило 13), включая те, что вошли в TR1 (но не только). Одними из таких «интеллектуальных» указателей, не включенных в TR1, являются scoped_array – похожая на auto_ptr конструкция для динамически выделенных массивов; в правиле 44 приведен пример его использования.</p>
<p>• <strong>Разное.</strong> К этой категории отнесены библиотеки для вычисления CRC, манипуляций с датами и временем, а также прохода по файловой системе.</p>
<p>Это всего лишь небольшая часть библиотек, которые имеются на сайте проекта Boost. Список далеко не полный.</p>
<p>Boost предлагает библиотеки для решения самых разных задач, но они, конечно, не покрывают всех тем, которыми занимаются программисты. Так, например, нет библиотеки для разработки графических интерфейсов, как нет и библиотек для доступа к базам данных. По крайней мере, их нет сейчас (когда я пишу эти строки). Но к тому времени, когда вы будете читать эту книгу, они могут появиться. Единственный способ узнать точно – зайти на сайт и проверить. Надеюсь, вы сделаете это прямо сейчас: <a l:href="http://boost.org/">http://boost.org</a>. Даже если вы не найдете там в точности того, что ищете, все равно обязательно обнаружите что-то интересное для себя.</p>
<subtitle><strong><emphasis>Что следует помнить</emphasis></strong></subtitle><p>• Boost – это сообщество и Web-сайт для разработки бесплатных библиотек на C++ с открытыми исходными текстами, подвергающихся публичному обсуждению. Boost оказывает немалое влияние на процедуру стандартизации C++.</p>
<p>• Boost предоставляет реализацию многих компонентов TR1, но – кроме того – и множество других библиотек.</p>
</section></section><section><title><p>Приложение А</p>
<p>За пределами «Эффективного использования C++»</p>
</title><p>В книгу «Эффективное использование C++» вошло то, что я считаю наиболее важными рекомендациями для практикующих программистов на C++. Если вы интересуетесь дополнительными возможностями повысить эффективность своей работы, я рекомендую ознакомиться с другими моими книгами: «Наиболее эффективное использование C++» и «Эффективное использование STL».</p>
<p>В книгу «Наиболее эффективное использование C++» включены дополнительные рекомендации и подробно рассмотрены такие темы, как эффективность и программирование с учетом исключений. Кроме того, в ней описываются такие важные приемы программирования на C++, как «интеллектуальные» указатели, подсчет ссылок и прокси-объекты.</p>
<p>«Эффективное использование STL» – это тоже набор рекомендаций, организованный подобно «Эффективному использованию C++», но основное внимание в ней уделено применению стандартной библиотеки шаблонов.</p>
<p>Содержание обеих книг приведено ниже.</p>
<subtitle><emphasis><strong>Наиболее эффективное использование C++</strong></emphasis></subtitle><p><strong>Основы</strong></p>
<p>Параграф 1: Различайте указатели и ссылки</p>
<p>Параграф 2: Предпочитайте приведение типов в стиле C++</p>
<p>Параграф 3: Никогда не используйте полиморфизм в массивах</p>
<p>Параграф 4: Избегайте неоправданных конструкторов по умолчанию</p>
<p><strong>Операторы</strong></p>
<p>Параграф 5: Опасайтесь определяемых пользователем функций преобразования типов</p>
<p>Параграф 6: Различайте префиксную и постфиксную формы операторов инкремента и декремента</p>
<p>Параграф 7: Никогда не перегружайте «&amp;&amp;», «||» или «,»</p>
<p>Параграф 8: Различайте значение операторов new и delete</p>
<p><strong>Исключения</strong></p>
<p>Параграф 9: Чтобы избежать утечки ресурсов, используйте деструкторы</p>
<p>Параграф 10: Не допускайте утечки ресурсов в конструкторах</p>
<p>Параграф 11: Не распространяйте обработку исключений за пределы деструктора</p>
<p>Параграф 12: Отличайте генерацию исключения от передачи параметра или вызова виртуальной функции</p>
<p>Параграф 13: Перехватывайте исключения, передаваемые по ссылке</p>
<p>Параграф 14: Разумно используйте спецификации исключений</p>
<p>Параграф 15: Оценивайте затраты на обработку исключений</p>
<p><strong>Эффективность</strong></p>
<p>Параграф 16: Не забывайте о правиле «80–20»</p>
<p>Параграф 17: Используйте отложенные вычисления</p>
<p>Параграф 18: Снижайте затраты на ожидаемые вычисления</p>
<p>Параграф 19: Изучите причины возникновения временных объектов</p>
<p>Параграф 20: Облегчайте оптимизацию возвращаемого значения</p>
<p>Параграф 21: Используйте перегрузку, чтобы избежать неявного преобразования типов</p>
<p>Параграф 22: По возможности применяйте оператор присваивания вместо отдельного оператора</p>
<p>Параграф 23: Используйте разные библиотеки</p>
<p>Параграф 24: Учитывайте затраты, связанные с виртуальными функциями, множественным наследованием, виртуальными базовыми классами и RTTI</p>
<p><strong>Приемы</strong></p>
<p>Параграф 25: Делайте виртуальными конструкторы и функции, не являющиеся членами класса</p>
<p>Параграф 26: Ограничивайте числа объектов в классе</p>
<p>Параграф 27: В зависимости от ситуации требуйте или запрещайте размещать объекты в куче</p>
<p>Параграф 28: Используйте интеллектуальные указатели</p>
<p>Параграф 29: Используйте подсчет ссылок</p>
<p>Параграф 30: Применяйте прокси-классы</p>
<p>Параграф 31: Создавайте функции, виртуальные по отношению более чем к одному объекту</p>
<p><strong>Разное</strong></p>
<p>Параграф 32: Программируйте, заглядывая в будущее</p>
<p>Параграф 33: Делайте нетерминальные классы абстрактными</p>
<p>Параграф 34: Умейте использовать C++ и C в одной программе</p>
<p>Параграф 35: Ознакомьтесь со стандартом языка</p>
<subtitle><emphasis><strong>Эффективное использование STL</strong></emphasis></subtitle><p><strong>Глава 1: Контейнеры</strong></p>
<p>Параграф 1: Проявляйте здравый смысл при выборе контейнера</p>
<p>Параграф 2: Остерегайтесь иллюзий относительно контейнерно-независимого кода</p>
<p>Параграф 3: Делайте копирование объектов в контейнерах дешевым и корректным</p>
<p>Параграф 4: Вызывайте функцию empty вместо сравнения size() с нулем</p>
<p>Параграф 5: Предпочитайте функции, работающие с диапазонами, их одноэлементным аналогам</p>
<p>Параграф 6: Обращайте внимание на неприятные особенности синтаксического анализа в C++</p>
<p>Параграф 7: При использовании контейнеров, хранящих указатели, выделенные new, не забывайте вызвать delete перед уничтожением контейнера</p>
<p>Параграф 8: Никогда не помещайте объекты типа auto_ptr в контейнеры</p>
<p>Параграф 9: Тщательно выбирайте способ очистки</p>
<p>Параграф 10: Помните о соглашениях и ограничениях распределителей памяти</p>
<p>Параграф 11: О правильном применении специализированных распределителей памяти</p>
<p>Параграф 12: О реалистических ожиданиях относительно потоковой безопасности STL-контейнеров</p>
<p><strong>Глава 2: vector и string</strong></p>
<p>Параграф 13: Предпочитайте vector и string динамически выделенным массивам</p>
<p>Параграф 14: Используйте reserve для избежания ненужных операций перераспределения памяти</p>
<p>Параграф 15: Учитывайте различия в реализациях string</p>
<p>Параграф 16: Как передавать vector и string унаследованным программным интерфейсам</p>
<p>Параграф 17: Используйте «swap-трюк» для сокращения избыточной емкости</p>
<p>Параграф 18: Избегайте применять vector&lt;bool&gt;</p>
<p><strong>Глава 3: Ассоциативные контейнеры</strong></p>
<p>Параграф 19: Разберитесь, чем равенство отличается от эквивалентности</p>
<p>Параграф 20: Специфицируйте способ сравнения для ассоциативных контейнеров, содержащих указатели</p>
<p>Параграф 21: Позаботьтесь о том, чтобы функции сравнения возвращали false для равных значений</p>
<p>Параграф 22: Избегайте модификации ключей «по месту» в контейнерах set и multiset</p>
<p>Параграф 23: Рассмотрите замену ассоциативных контейнеров отсортированными векторами</p>
<p>Параграф 24: Тщательно выбирайте между map::operator[] и map::insert, когда важна эффективность.</p>
<p>Параграф 25: Ознакомьтесь с нестандартными кэшированными контейнерами</p>
<p><strong>Глава 4: Итераторы</strong></p>
<p>Параграф 26: Старайтесь использовать iterator вместо const_iterator, reverse_iterator и const_reverse_iterator</p>
<p>Параграф 27: Используйте distance и advance для преобразования const_iterator в iterator</p>
<p>Параграф 28: Научитесь использовать базовый iterator, соответствующий reverse_iterator</p>
<p>Параграф 29: Подумайте о применении istreambuf_iterator для посимвольного ввода</p>
<p><strong>Глава 5: Алгоритмы</strong></p>
<p>Параграф 30: Обеспечивайте достаточно большие целевые диапазоны при копировании</p>
<p>Параграф 31: Изучите различные варианты сортировки</p>
<p>Параграф 32: После вызова алгоритма remove или ему подобного не забывайте вызвать алгоритм erase, если действительно хотите что-то удалить</p>
<p>Параграф 33: Будьте осторожны при использовании алгоритма remove и ему подобных для контейнеров, содержащих указатели</p>
<p>Параграф 34: Не забывайте, что некоторые алгоритмы ожидают отсортированных диапазонов</p>
<p>Параграф 35: Реализуйте простое независимое от регистра сравнение строк с помощью алгоритмов mismatch или lexicographical_compare</p>
<p>Параграф 36: Разберитесь, как правильно реализовать алгоритм copy_if</p>
<p>Параграф 37: Используйте accumulate или for_each для суммирования диапазонов</p>
<p><strong>Глава 6: Функторы, функторные классы, функции и т. п.</strong></p>
<p>Параграф 38: Проектируйте классы-функторы для передачи по значению</p>
<p>Параграф 39: Делайте предикаты свободными функциями</p>
<p>Параграф 40: Делайте классы-функторы адаптируемыми</p>
<p>Параграф 41: Зачем нужны ptr_fun, mem_fun и mem_fun_ref</p>
<p>Параграф 42: Убедитесь, что less&lt;T&gt; означает operator&lt;</p>
<p><strong>Глава 7: Программирование с использованием STL</strong></p>
<p>Параграф 43: Предпочитайте вызовы алгоритмов вручную написанным циклам</p>
<p>Параграф 44: Предпочитайте функции-члены алгоритмам с теми же именами</p>
<p>Параграф 45: О различиях между count, find, binary_search, lower_bound, upper_bound и equal_range.</p>
<p>Параграф 46: Рассмотрите применение функциональных объектов вместо функций в качестве параметров алгоритмов</p>
<p>Параграф 47: Избегайте создания кода «только для записи»</p>
<p>Параграф 48: Всегда включайте необходимые заголовочные файлы</p>
<p>Параграф 49: Научитесь понимать диагностические сообщения компилятора, касающиеся STL</p>
<p>Параграф 50: Посещайте Web-сайты, посвященные STL</p>
</section><section><title><p>Приложение В</p>
<p>Соответствие правил во втором и третьем изданиях</p>
</title><p>Третье издание «Эффективного использования C++» во многом отличается от второго, так как содержит много новой информации. Однако большая часть материала из второго издания осталась и в третьем, хотя часто и в измененной форме или последовательности. В приведенной ниже таблице показано, в каких правилах третьего издания можно найти информацию из второго издания, и наоборот.</p>
<p>В таблице приведено соответствие <emphasis>информации,</emphasis> но не текст. Например, идеи из правила 39 второго издания («Избегайте приведения типов вниз по иерархии наследования») теперь перенесены в правило 27 («Не злоупотребляйте приведением типов»), несмотря на то что текст и примеры в третьем издании совершенно новые. Вот более содержательный пример: во втором издании есть правило 18 («Стремитесь к таким интерфейсам классов, которые будут полными и минимальными»). Одним из основных выводов этого правила было то, что функции, которым не нужен специальный доступ к закрытым частям класса, не должны быть его членами. В третьем издании тот же вывод обосновывается другими (более серьезными) причинами, поэтому правилу 18 соответствует в третьем издании правило 23 («Предпочитайте функциям-членам функции, не являющиеся ни членами, ни друзьями класса»), хотя единственное, что объединяет эти два правила, – общность выводов.</p>
<subtitle><strong>Второе издание в третьем</strong></subtitle><image l:href="#i_013.png"/><empty-line/><subtitle><strong>Третье издание во втором</strong></subtitle><image l:href="#i_014.png"/></section></body><body name="notes"><title><p>Примечания</p>
</title><section id="n_1"><title><p>1</p>
</title><p>Имеется русский перевод: Саттер Герб. Решение сложных задач на C++. Издательский дом «Вильямс», 2002 (Прим. науч. ред.).</p>
</section><section id="n_2"><title><p>2</p>
</title><p>Имеется русский перевод: Паттерны проектирования. СПб.: Питер (Прим. науч. ред.).</p>
</section><section id="n_3"><title><p>3</p>
</title><p>Более подробную информацию о функции unexpected вы можете найти, воспользовавшись своим любимым поисковым сервисом или в полном руководстве по языку C++ (возможно, стоит поискать информацию о функции set_unexpected, которая специфицирует unexpected).</p>
</section><section xmlns:l="http://www.w3.org/1999/xlink" id="n_4"><title><p>4</p>
</title><p>В начале 2005 года, когда писалась настоящая книга, этот документ еще не был завершен, и его URL может измениться. Поэтому я рекомендую узнавать о его текущем адресе на странице <a l:href="http://aristeia.com/EC3E/TR1_info.html">http://aristeia.com/EC3E/TR1_info.html</a>. Этот URL не изменится.</p>
</section></body><binary content-type="image/png" id="i_001.png">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</binary><binary content-type="image/png" id="i_002.png">iVBORw0KGgoAAAANSUhEUgAAAHUAAABhCAMAAADfnR4DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADBQTFRFmZmZQEBA4ODgAAAAzc3N8fHxZWVlLCwso6OjwMDAcnJysrKyUVFRgICAjo6O////xQxTvAAAAypJREFUeNrsmeuW4yAIgBUVRUXf/20XtZe025nTNBOzZzb86LQZ8BNE1KjqEaJO6i+mmkmi9QN1jot8Uk/qSf1GnFK0mhq1CH/VZHkDS4TrfWVba8IvWsS33P2QWmP7sIzBjaAhg4SNlFZKgTwBFbseKVcwdLskOkm5BRUKFreC6ppCYFdJi5nLtrooj4AyEbWGkjxBUQSvbQ0t7qgqZE8LqkWQR+5NKjJne7W1MsTcvHP5OXbUzPVFE1oqOLOM8LDHN6nBhtaE1dhEYPHvESvtP516eTryVi+1fLf370eY+NL75+TAhZu0pFIfXP+Xr6uyqY3ZGBL5YLpNGlzo8JJatQwDP0S4Z2R9b1yLz6GlU6iArHqCuti+pG7KKsaWJEph1Em00VXlpUeOMZIewZfYUjOLolVW1yZH8PRFvl1ibF8Z6OeCYSdURMjT67BCjHCudCf1pH67TdlOPeScY9dLNukDK9h2knTG44Yi9qmdScbNpjpZ2XScTS2+uesmU3Pb23g1l2q7m8HPpeYxpD7NpIKxl1ozk5rzI31EXQW3JxXM9ZyIeJ+/XnsTdqTeA2tvk6d3JBi7H9Xck0hf97ojnUvejRpM4avkq7PpUp13o/I4cpn+B+3jmrDz20t6NWs47019UZiigelU1Y5Z06ke9q1Nr8d1xVrwg766Q6j1CKojd8C4emNgvq/HUIHp12aT/idy+BdTrTnE1+1UtV6iUZ/Iw1ldTxEpJAe8DaGTelIPodqsC82mJtnlWj+bqm9qUBgcQb93sOPygXgcla1smiANpQI/QL1tEaxOlFEnQG6XJ80yKkp5HCEpRiXPAxLlsp3qCsd+z9ivlNorn3ZxN66tegu9V0rT2MY8dHRbDrd7ReIR0iU1tOJKd7aEoB9r42bqGL9SoTeVltT24+rrhVqoCWym9vQNodZ2BQb+Sm2LVn8XEpdUwO8OHyuoOScKPWWi1tjd0yllzFApSzJl6Q1wltC2Y3vq2ml7hJ3ieyt9dF1R0G/rrEwckHi6HtdxgRk4uZ+uiMQH1GGW+Tqf+nV+nivdSb1SaYqUJ+o0OZ46W/4n6h8BBgCb8lNhHF4swwAAAABJRU5ErkJggg==</binary><binary content-type="image/png" id="i_003.png">iVBORw0KGgoAAAANSUhEUgAAAQkAAABjCAMAAAC/rgXeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADBQTFRFAgAE////M3Kot3U5CCRpZjIYotjx7cqYent60vf6++W7/vzfcq3Y7P7+zp5tw+bxDXxRKwAABFJJREFUeNrsm9uaoyAQhAmKoCC+/9tuV4NGnexG8+3MuklxEU9I4KcPxDLGsMzlxoJCEiRBEiRBEiRBEiRBEt9LYmiMaYO9RWy71QU5sTnW4qWR9J4kZGghONP2Nx9cO20u7Y6VWw5vSiI2mHf57OUg72yg+WoTt9GbNL4jicFYjMtjdLGOPGaxkdDL1oTiMThj2lSNKD1yrzTXCtPcgNyvDaBtrXQZhI9IbMZVSCA+iL/Y/ia9t7KXwEhcqHDak5DqqGTFpAxqyeW5AZCxGWcGV1u6Ngnx/RAmJTEtZpJNkjnFTDvxnNFLHfOYhGtD7nIno9X72m7bwIgGGtw0OPXBq5JwaUQ+UNMvNpF1xBhXPZaxOX260Y0PvQMXpWYJIHHaNwCnK/dLrfG6cULnqUbMMnL/1SZkp5/j557EEDoEhnb0roSc6WsDUyMJKlTLu2oWVecOkkUH+HgI3ahxAmck4FXvzrqVKY1wEhtSv0vDcrLeh4gxN3APNF6/xT3IRRdaWXlYru10zQQDlkEi0qUeGaCGfl11BWdnN1mPaGgCGtAsrBlmaWBOPnAa36DSVZLH+dX2vuPxUK3HC5Lxt/d/wO8OMbdwyWXYT5OAT5mWJPirnCRIgiRIYmnrP9aE/yqJ/88OSIIkSIIkSIIkSOJTSMTp3UnE+nj7meYxuG96tnMdEt7hoe5zVVVQvLl3FCXhgKo6dFchERvprX/yRH7TkgqiASIHHpTbDtKBq4riLLLeBiHRWJlxOT1mqaaPOWWLwOBd1VbvPJr9mVIJ1XFNv++MAPuSTeTU+9AftwnIIapv+CJ0dNLnFn006S6yyl6AzASVSJovJIwqJTf1HFfE6mU6qtq6chut1CHk2CDt9vGMAPsSiSEHOx23NcgaoctJ1S5MndX5FyAmFT2sQf+bqqaofiofRQSA0xSRXk/dA2xVW1cmAcnJpz56VVvlvlMC7Gtx4nnUMjt/0qRQxiJ9nKSbWUnkOWNguJODQBTxqTgWEk6fgA/jpgtm/45PVo1qmiX9/pwA+5pNuNSkMzYh5iDz0JW5kJnq1SYmJWFVEE0aJ4ap9hwTvLEJvbDq/qy2rmVHcVifVZtE50bfD2cE2FdIRPQidMdJwDdV9MxLnGhTo66hfqtvJGW4+VQsKOgbKh6RAVWrbGpW417U1vvXVNk1jQLc6l48I8C+QEK+KJUOHraJUKTVOXcgllvpZYam3KhYOpWVVZoNH2aSgQNjGBdxdpU6FrX1bhNulR/Kew4nBNifWU/EPxxtBdGlh+MzjfTUSvOAAPsZv8COCLAfQeKQAMtf5SRBEiRBEiRBEiRBEiRBEiRBEiRBEiRBEiRBEiRBEg8LFLGYN8LNp9pEDB1EQtoEFKtsR5JAyVf5c+i/9g5v/VX+MfxvSQCDtz1JZM0d7koOwvUESZAESZAESZDE5Ujwn7NvUUiCJEiCJEiCJEiCJEiCJL6BBEspvwQYAIm4gYoau589AAAAAElFTkSuQmCC</binary><binary content-type="image/png" id="i_004.png">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</binary><binary content-type="image/png" id="i_005.png">iVBORw0KGgoAAAANSUhEUgAAAV4AAAEBCAMAAAAHLT0KAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADBQTFRF////AwAGN3S0wIJR88uSgFdTkcrsGTJp+uS2ueb3/vvb4fz9gYeC26lxYqbXYCIWDo47ZQAAEApJREFUeNrsnYuWoyoQRVVEEXz8/9/eOsVDY4w3maRntZnDms4YHwjbssA6GKqa6QdTVVdMP5aIl3iJl4l4iZd4mYiXeImXiXgvgtebuu67/G0afnOx2+5qeP1SN2apZyy6blqa8FvL7IbW9sO18PqpnoMwlnK3CPX0v9U+xAwkNTe85/Dr8S49ytjWsyxN4wjrmGJQrQ9+WhLwuGQHt6RtA77fmBKcjG6psNB5mz6QZovs5OB+lC+6a1c59UrhIPNWQUox1lvJm34cx7UonZbTpqVWFpqhShk0OU/Bn/Pcnq+4GtnWtLhzT2ocM+/tvDnx83jd0qT/2lgQ8RKtqZtxkZJonWDYcn4s1V279KP+C2bpd8Yz2VoISOWkSnMwqLCUqB9t3Tg5fob9zXKWftAPeKVRvdJd5oMUoMNOa13ShRJy+0LpfYez9J2XQo2ypBdQTyy85BPruvV8G4PA2eRKntS4Qqlkodmc+CW8IeFFbZxFlWDL6uZ8qyVLe011Jwt+aQYDOnde2vS65yDlGKYaRauQjeSG1VIZuSrA1OBP+HeVx/aDzPVLv3UFHpdMspjXQskhMwo8qGsTDAITWWE1vqjj08po7uV8G++y9MK0Hc5qXOE4+QoXmk/8Al6rzkHy0WLEwsSTyZ1l030Vt1W418QIG2yMvnB7ryTvMIOpNJFTwhvaWF1Bg8Ms/EMT89ie+CbzCftOyw1e7A58pVBy19o6Op2miqdKhRqUS7o1U42Gcr5b7xBrcFbjaH+bba/0HKJB3BgRKgwLxDZYTL6WlVxnB1sJXlvDcXevGDgHMX+x0F4ssN/ghQvUPOVP7jbkZ7J1H2Sutu+294eWp4rHpUL5IbTpts/bcqFCmyqTrbdCZcTv7q1XjABQT2qcjnDduu0VvM4ml+Thf+CuxMWoH5zl5sImdWq1OjXcenCPUjdzh7dV32tr9ZoD8h3E8fWjwQLcgTjiGZ6sm0bsEH1hE+4zRyM0Y/UGxaQuUIpSCiUNYPSq6ifRWq6FwhWGOxY7RrWi/0vnu/G9nWTXndXYt3EBHitt+4PHCtx5ZtG2w0TPiHYUn6NtutRqwp/Z2MKkFnnTEiffoK1aP1eaa262ZxQPh8Iz1PO0aclLI73JvF3iRz2H+zu5FEpcIVbNdz0HFOqm5xCJOLNjoz0HcDytse6G3Ndt7z0UtzeNoxRVPxPElx4E0h0mpnh66OuZx0L5D3VTw1mNj078O2IO3qj5OXuNZy2GdIiXiXiJl3iZiJd4iZeJeImXeJmIl3iJl4l4iZeJeH8hXpNHXUzL/P5ZnT0bwTY1/xpet2q17Q1e92cj/dqzw75IM3oSr1mZTju8ZxdlqPwtKT8E78Ljw5xSN793dOan8GKcUWjT8AW/dHFdbxvgdba3cfCcLFg7p6WbYVcOo8oaa+NoMGu7ytull6VRjNPZKeWQtkFD78Vn6KLrvx4v1N1yD8f6eh0mCN8Lm4y3sDiHELLdtc2tCw1uGbwNHsywu8PYpy6YLg3VklVlmw5skksQB3oM/4BzMGN2gm0cnNok6jFFvDY8csRi5rJC8OpFCvErjgJeNXTJsGxLVy+mpfsH8LrSSYh4o9fNziH6jUK0Xayt7/EC2gQHIl5iwFcT8TbJcZdtW7z+X7BeZzvbZdBDtl60cgrC2y1escJwYL1i21ZsMwR1Ie3GetPtULYhw1Cu5vfj9doYdZueQ/G96hEiA12UHgJs2psD5yB+NebiumTMVfS91ep7sW1rvd/T8X2I12HQubTm86af6rTnsKBHYfsxtvytuAkd1tbrqpWvHNuB4qLDua2OpsZwxyaYBqN+U0cjbZMraOvoJNaL+v39Xr+ack6hejSs7ekUTte3X9Ptffqh2P9Fb+i+Z6AfQzrES7xMxEu8xMv0abwTuv54c8c2m6e6+NSWnzzud3+2H/YwwnD954un8OZ+/jRvHlcnfSEaz7VmPt79NK3hsRNx4vIPGCd4s7KwjeO25QWzGGF3c3UvCLVPWC4iZ0/sdfXI5CO8G2XBG0gSzR70Gl64xVl2n2x8kRpvtZl+0QsTQxN4I3xJeWL3IQUpYvBhqsfFptf6rh7ceRzSKcpCFdZ7dCU5lXV3N7cGJ6sqRdEQZQMs0yVnmj6GHHlIkTLJJgjiQaW2kFZe3Ts8xltis1uoqwRp8pIfuzuPma7AnHysrsC3uEVffdw4h7hoSrBez5nw9l+LNysLW497b70HrfsWr7/Bu6rMG+UnLhZzTXZuvhtve2i9ZcknvP6g2Xdb6zX31rvrOaRFPdPOev3UfLH1HuAtdhx7q+p3/fDIeqV9098HwVHFln30yTDRbtOJcPHnaobspaNJz9VX4l2VhQFPDjqWQZ4qpL1vEkz1lVGJvDGxsrvAiQIGhI8q/jYW9I4+vb5ttXswWc00qLyhmU+LrI8/9HX58TrPPbUlsRFtfdg9DWQh8nb3Z04dDnb2u2t8ceN9J+bgft4tuvDv4mUiXuIlXibiJV7iPUxZrTD9+giR1IrxICRLteIlvCksiKdZX0KEGg5wY2e6B7ufJ6oVe7XCj2GN4RQhwTyMmJ0lqhVHasVqayVUuMdLteIZ6z1WK9YwQAkVHjoHqhX/h/cw3rsGxItaYU7D6VQrHuE9UitWueHUetedqVY8brT31uunVYc/wUu14jnr3eGNfjcFCUtv9cx6qVa8oFY4tPbl1cv0Ngu6ADPViree2lZFIoQnngaoVnwg5kC1giEd4iVeJuIlXuJl+vt4N2pF+S0AvlvxKbzl3Ypu8zs3fLfiPbxH71asMgPfrXgr5vBYrUi/CsB3K96x3mO1Ysr15rsVb+I9Vitcxsp3K97Ee6RWVCW+y3cr3sJ7/G5Ftkm+W/EB692rFeMmws13K97qORyoFfGnIzNLvlvxsae2g/cn+G7FD8ccqFYwpEO8xMtEvMRLvEzES7xMxEu8xMtEvMRLvEzES7y7QnxL+qV4v8ZWiZd4iZd4iZd4iZd4iZd4/79Y3tR1Hj9c+akj3k8Wy9m6GZdaBz61w7Q0xPvJYhkh6z2G+rVLvbFj4v1EsXycaXOqZ7/004hB736Kz/J98NOSgMclO7glbcPC7dSwcDJ6ffT4zlv5kFtD02yxtxzTjzUup+zaVc48yhwXupEy1c8MNP7VeN0S5ztdmlS5OfuLHnP39uO46IjVGkvCa+lH/SdupJ937yYt9Sg7NZiFfRyEXTNgXOsouQ1G9vagKzv1g36sXsncZS6bOuzUXd162+hs5b8WtXE6/LcVW1ar9u0odLp4EfzUS53lMjRexw/fmZZRD4M5vvsg16Pu4s0huWG1mKyAg+E2FsZZvNJB5pOyrpvrO4clO4dWmzf9BF6wSvd2F9dWlb7O5RcxRuG01HtXHb3DHORYTNqreGVPHIzXwMRFyGG2l0xh4yaduDvIXNYufbs89RLC78Y7RXeQjAjVdWJGs4P1ChF8dNmFtIIgCIHgAq4LXMHG/4phjmrsXj2t4nXFevt4R8ifU3LeJOseDjKfcOHa5frWu3bMpL4N/KSYlSBqscroJrRW6h4t7tYJ7rFDc7TH2yKnMR4bXWswFseJ79VmCu4a+XbTGBs65C6+5D5zuT6zH+unplW/xGOFvqqJBjuodwxGew74HK3tYuMOW/bqL8TElnrnHHLPoYHfjd2HIXUFaoGnwOseO80wznnXc9hm3i7xo56vj/cu+dsZodNrHK+9EZBev0u3fcbkH2UTPlqPfyXmkN6C+dmfMGBIhxEz4iVe4iVe4iVe4iVe4r0GXjcT758UK0UK5OHf1ggV6qScbVxYRQP5sCm0UyINaacctURgUT40lJu35cxllcYVtgFGDUrMU40YZZI0MFlPKgHiEbXVOHBUMjbbLmW9kBYQrtIAy6hRqhZxHGHoVtEgqhWqM0RFouxUFUVCdp+D/uxG2daOGlfT4LnutOGL3E291JK5reOJIVeM2Mlbjd5pTDQqGeu2a+F1kdWMAG5X+bZuvEYZEW1dRQNocfrzaEWRyDuFokhoBF5juus2lz7aOgaTtz4GgkYzdEEPdBrc9RMuYtDTVUUTgZKxbrsWXugDCa/+gJwKMiEGugWv7fUXYFprVdwsikTCAeJZkUjbcnw8bkPubpk1tl65mwA5vEO82w0uI84SFZB4ESWHsMok67bL4c3WW6MWt9Zba8Xx04tRdVsViY2FFutVxyEmZ2+tt3IhKg97650NjLqF/IMd4v2TrLfCL+WFomS4su1aTRskBPG7zaBCLsLe6mjtEkWdGVqCGCeECKlhUSTWnaasSMi2OQrIeVtoo/oAU46Z73yv/I3d0uuNom0cDotuvFGXW5SMddu18KJh1kZcTGO56znMSTRwqJqAK4rE2jvIisRsUs+hD7c9h/QTbIsKErc9B7k1avQIZogfs8dh+JXLIfYcoKEUJWPdds1+b5IW9Geh/INj/P2XnSLhD3b8n7RTR/YpvFiP34nXGwz+eD2bv6JIXB+vSzchH4oZcyBe4iVe4iVe4iVe4iVe4iVe4iVe4iVe4iVe4iVe4iVe4v09ePNsnZNdxyek2TrHgykJX5ut8/HET6/NqnNZvGW2znkz/6BScWNnuke7n6XNFJQn82q9NK3OxfAezda5zh1XJtI0D2eMO8f7TNFemjDuSngfzNa5AZ1rvsf71GydE/ZJ83jlKbvgUvSNzH7s0zCGl2TnS1nv8WydK95ySx86h/+drVOcQ55sK/kJ+J2AD7/MPs2C+tKkW9fCezjf4XpPl9k6zel0ko9m68xT1hZX7cqkkh6bEnPTfC3eo9k6n7TeFe+j2To3TVu8ZOnCmS4ekr++MODiUniPZ+ssS/4E7zOzdW7wHlpvXPnSdJKXs94DvMWaytzyZ9b7eLZOdQ5xTFm6Gnq91Peu1vt4Avur9xwOZuuUp4qlL0MTTZqQU1bNfzBbZ9vrrN7Sz8i7l56DrJfuw1y9OM33dZ/acisfNuMUTx6pwisj1AIGn5fl9frqKbp/Au+x+/jxYX5+qP5dvAzpEC/xEi/xEi/xEu9hymoFHgpyZ4lqxafwFrWi00DlhgrVij/Ge6RWpABuRbXizZjDsVqxBmqpVrxlvcdqxWTzb3FSrXgP72G8t3IZK9WKN/EeqRUrTqoVb+E9ViuyTVKt+ID17vD6Max9UaoVb/UcDtQK9APWxwqqFR97agsH+gPVip+NOVCtYEiHeImXeImXeImXeP8+3iI/eEO14uN4t8OnS42pVryH90Ct8KbLeKlWvBVzOFQr2iZrQVQr3rPeI7VCjNdn66Va8R7eg3hvigFHqlQr3sN7p1Z4SAnmGetd8VKteFqt8OIubZoWlGrF+9Z7LwaFkJ0D1Yq3eg5HagWolEltqVZ87KmNasXfjzlQrWBIh3iJl3iJl3iJl3iJl3iJl3iJl3iJ97RY35J+J97vTcRLvMTLRLzES7xMxEu8xMtEvMRLvEzES7xMxEu8X4OX6QfTfwIMACol4u15Pr4wAAAAAElFTkSuQmCC</binary><binary content-type="image/png" id="i_006.png">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</binary><binary content-type="image/png" id="i_007.png">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</binary><binary content-type="image/png" id="i_008.png">iVBORw0KGgoAAAANSUhEUgAAAP8AAABsCAMAAACSJJQVAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADBQTFRFQEBA39/fzMzMgICAAAAAo6OjZWVlmZmZ8fHxLy8vVFRUcnJywMDAsrKyjo6O////KVZqpwAABAhJREFUeNrsne2WoyAMQIFI+Nb3f9tNora6O92pPR3bKcmPKYoI14QIihkz9S1G+ZX/OVKHkyS9KX86R2Wg/Mqv/Mqv/Mr/q/it478NbZf81kAxXB/GLvkz694sif74XWAbqNMUMRTkjclDQc870BZEypoiZRX7kfwxufU4IhUfYFdjSMD5tJkpy6b4kfYfwWS+BIGxQZTsaiziGaQ8TGMTQPep97/Ih5TVGYQSwigJwfZ+SsiS7Qfye7dir/xVfABvsROYYr6zNb+T34zs/hkUZ1sXM49Z9pBrsNw3xCvE9on85OARSOMOyce1TDZuEQuMlIgYAUd2enQnoH2f6f//U9D3Pf4Ptmt+MFh0/qf8yq/8yq/8XfHHD+Lv/P1fdMcFB3+8kH1P/kckJXxtA17LXwc39MyfwvxcoFP+Nlgygdgtv6HOH4fWK38d2JOPKXbKj7PvH3yf/HGYb+SQ++RfuePgeuS/Oj7EHvmv0xg32A75h+vAJ+X++MMAF8mvM4CX8ZvdlBb6HP9Pr57+KL/yK7/yK7/yH5u72775hzeTejY/uHeSDGfzh+mdBE/n953zO+VXfuVXfuVXfuVXfuVXfuV/FX/unN8ov/L3yw+d8wflV/5H+eEBGfCBQve9M3D1uJT0QKG68A/mHLnzIb057aXByn+Skd7Lf9JikKr8yq/8yv9L+e3NDwdsrfFV/B5vhrd6Cv9YEJycqN5cNtxCdo/xt5ToRn2rnfetU4b6g/zoOEDQtxYCD/JLUJZ4S4Ov52+SV0dqZF2WoNjqptjE3iv4aHf8DkI8zC/nn1zBIg2OUAp4qgg5PA+/97YACJH3OFjCVQXEsWHb8FvKCs/mzxcaG8KsDhdMKI2/JELvajFbfgiuYj3Kb41lfNoqHJ2LwxHZtNV/FHamTnTtDW2NdKBLdaP/yFHeWn4yv/nKHJe1CHPwnLzh96KPfIif+r/EX5qD1NFF8NLqcW//ZHxcUgI3cV1lo/j5Z5QW7KY8P8W/7Mz/9P88ry53x/Qf2aLjHIrK7Dr9mgwYgjxxCXWpS3LClt/Moazac/l3vuUvfvMvf5PFQfGo/+NedjnbRoVLhWL6045f9I9b/i+i2D2BX3oVebWv+Ofq/Ya/ynHxuP8rF09LlYldSYweqdDOriHs+Bu1a9z1fyvF7JPtn07r68geJwAk4KoD/84BxMbaOJ4WuWeDwGcZsdYxH9B/zbKSjAs38v/i0CuWOUEpShIE0G+jZrpMfYuKiEpK5athyeazfNDkqHiB+OzxT2xBdGtX07bXT+JdkPvg8iG+HOWDO238F2rf4//v3kF9Mr9D/Dasrc7/lF/5lf/t+Os5ci+/gVMEL/zv9ZFCMWfJpP//Rvn7lj8CDADqSuiDrUOxZwAAAABJRU5ErkJggg==</binary><binary content-type="image/png" id="i_009.png">iVBORw0KGgoAAAANSUhEUgAAAQYAAABsCAMAAAC/8+yGAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADBQTFRFQEBAmZmZ4eHhAAAAZWVlzc3No6OjLS0tgICA8vLycnJysrKywMDAUVFRjo6O////uDMQkQAABJVJREFUeNrsnQ176ioMgIGG7wD//99eElqt90xXu+nOGcnjM2sFDG8TCFUy1US6KEEgGP5yDHp5o/zFGN6nVhAMgkEwCAbBIBjmwOCnxWC9Ukt/fEME+E9jCKy5mtwpdhgCAJ1xUKFmSLE1EyBp7iGgCQF/L4ZoWHO7cwrlWkot52ago8iJziEo0/LvHiLV7UH/G2xD3UKklwND+f0zxT0MCkgKWQrqeTHAtcjMGJA52DgFhgAKXH/O0A+g9hqhaWi2mM4hQap9xuiuAZAlmJY1hWAQDIJBMAgGwSAYBMNcGOQ7TL6tYk+IXsKZavbvxXBKyhJO1/09GMwSvGBoqTSvp8cQPbbqp8fgOoK4uMkxRHaI5CfH4Ba6+RiXPDcGn7ZxcmYMeTHrrBlnxlC2yAlgYgxmNQYyizgvhnS1AV+nxWCW67f32cdZMYSbhTPOisFpFl/4yU69tOp90eerCgbBIBgEg2AQDIJBMAgGwSAYBIMCwSAYBINgEAx3BAQDSRAMgkEwCAbBIBgEg2AQDIJBMPwIhvAqOX1TzOIZgXKqGq4YFvUa8ad/u+uXN2+oYAwvMlI8jwHf50ooGASDYBAM/zqGsJ9NjzfkzHdhsFcNLLhTGAyewRAAYnMA/AO/nY7uDt28dhmG8CuFX8BgFxVaVJ5DTLv/9e2dOA0eYTCwLAqfx7BmZoGjke+W6GrkxQr4dacYH/RBhpjnMcQ0YpSnQDCGqJvRwx0sbrUx5KEd9n4iGYqp1QxTrZeIcMVgEHmzCUaNzbElb6VNrxvZfh5gCKYl1zJynpjVEXRKIVJ/NVDasdzfS5AyK+ABPvCXjoEsYROVnxwboNUyElk5PQwrgrMZaFdV0VaD7y3qYG0iVK4krXXvduVeURdRF2rIFI9JZad3pa1WOmH6BANGSJRA6Hqpia4t/bjzaZb0tJR1rNZH1gC3UavPT2GoreS8Do7DPtnhTde3stcoSgDHJXO7cQN16yjdgrCSlrvSbdue9gAD5pzTmlZs7eOaZK2xQXDzwG+X+xjSn+G735Ybn4T5wxoimGT1rmNl5/zjoAIv4tJjDMgODvvSlzKPMIQQtVE7x7+MV2Pi6L4W/TXr2B1rWP7f26SPybCG0N25YP4Dg9/Mop/UlfdZm2MYdqWPYOhr725AaYchhjHob5cfbwbsOxhUq3sIIT43NtD+sZr2aQC5V6S3UbFPZYoGiTFoHMOwK30Ig+oIStn3kTIxRhobdHeGSnrmYSZxK2I+miniZa8DxCdnCr6NYhfLxulDIF/us4Erqo/gFlRhc80l91OZjSNjIJ1zL01DlglBdS9oVoHBYqjVS2lNLdbPMNAIOxyOM4ohTXwpgVGV4qmEmi9LgjVBJfYDsB/HDTGQayTzdNzAWSE5J6S5mrLtn2xs3F30mDWO1yY71sGs6QjW9Af0HGOvQy1spY3FtcWvBNP6SBRwiSJreHLjz7E1RT6fqOCb1hSHdn2+dGlVQ4L4kxgsANgfx2Csbe2nrUEW2oJBMMyAAV8j9fRXYh7C2wQuGF4lp60B1DulyT90enxDSzBMKf8JMAAbbhwDhVRa7wAAAABJRU5ErkJggg==</binary><binary content-type="image/png" id="i_010.png">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</binary><binary content-type="image/png" id="i_011.png">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</binary><binary content-type="image/png" id="i_012.png">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</binary><binary content-type="image/png" id="i_013.png">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</binary><binary content-type="image/png" id="i_014.png">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</binary><binary content-type="image/jpeg" id="cover.jpg">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WWtWw0/82cMOLTaLHDYx/vY4731vyan1u9j6XO2MZZV/grf31lLc131/nPwtytOKqHyP/9b0rq2EeodKzMBr/Tdl0W0CwiQ02MdVv2y3dt3LzIf4kcsCP2xXp/wB/wDSy9YSSU+UD/Ellj/vYr/7YP8A6XSd/iSy3CD1iv8A7YP/AKWXq6SSnyln+JTMZx1es/HHP/pdbn1R+oTvqj1K/q+Z1Kq2g4z6XTX6QbufVb6jrH2vb/gV3SjZW22t1b9WvBa6DGh8wkKvVXkySWWz6udOGtgfa8tLXOc46y71d+xsVsfvH02NRGdC6exrWgWHba68F1r3E2Ojc5+5/wCl+j9C71GJ1Q/eP+L/AOhLbl2H2/8AoLoJjwVlV/VrprHbibX/ANaxwP8AJ99fp2e1vs+n/wAYj4vR8HCtdkY7X+oazWd9j3iCd/8AhXP/ADmokQ6SJ/wf/QlAy6gfb/6C+LHNy7sOnFuudZRRrSx53bJAa5tTne9lft/m/wCbQltUM+qR6ZW19lozjRDrZt2+sWudu9IVOZsZbsq/4pYknw7fj4La4xX83L5v3f8AnuVwS4r9wbfvf81//9n/7RfIUGhvdG9zaG9wIDMuMAA4QklNBCUAAAAAABAAAAAAAAAAAAAAAAAAAAAAOEJJTQPtAAAAAAAQASwAAAABAAIBLAAAAAEAAjhCSU0EJgAAAAAADgAAAAAAAAAAAAA/gAAAOEJJTQQNAAAAAAAEAAAAHjhCSU0EGQAAAAAABAAAAB44QklNA/MAAAAAAAkAAAAAAAAAAAEAOEJJTQQKAAAAAAABAAA4QklNJxAAAAAAAAoAAQAAAAAAAAACOEJJTQP1AAAAAABIAC9mZgABAGxmZgAGAAAAAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAABAC0AAAAGAAAAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAADhCSU0ECAAAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4AAAAAAAQAAAAAOEJJTQQaAAAAAAM7AAAA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CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0ndyc/Pv/bAEMAAgEBAgEBAgICAgICAgIDBQMDAwMDBgQEAwUHBgcHBwYHBwgJCwkICAoIBwcKDQoKCwwMDAwHCQ4PDQwOCwwMDP/bAEMBAgICAwMDBgMDBgwIBwgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDP/AABEIAfIBXgMBEQACEQEDEQH/xAAeAAEAAQQDAQEAAAAAAAAAAAAABwYICQoBBAUCA//EAGMQAAEDAwIDBAQICAcJCwoHAAECAwQABQYHEQgSIQkTMUEUIlFhChUyOHF2sbQWIzNCUoGRoRckV2Jy0dMZGiUmQ4KTlLMYNDZTVGOSo6TB8Cc1dIOWorLS4fFEZGaEhrXC/8QAHgEBAAAHAQEBAAAAAAAAAAAAAAIDBAUGBwgBCQr/xABLEQABAwIEAwMJBAYHBwUBAQABAAIDBBEFEiExBkFRImFxBxMUMjWBkaGyFXJzsSNCUmLB8AgWFzNUgtEkJVOS0uHxJjQ2osJjQ//aAAwDAQACEQMRAD8Az+URKIlESiJREoiURKIlESiJREoiURKIlESiJREoiURKIlESiJREoiURKIlESiJREoiURKIlESiJREoiURKIo040vmdas/U2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8p9XHH53EYBlz5SWabC5sCTci45hZ5W+Tmlkf5uhlObLms7xsNQBYGx5Fftph2DGFv6tZ9ZrpqbIyA6fsQnTBajotbd2VNgd9F5pPM73LZklKCoIV6g33BPSKs8qFQ2CKRsGQS37V81gH2dppcga7jU9EpPJzTmeRjpsxjt2bZb3bca3NgT3cljg1W0qyHRDUS74nldrfs2Q2KSqJOhu7EsuJ8dlAlKkkEEKSSFAggkGtu0VbDVwNqad2ZjhcFaqrqKWkndTzNs5psQqeqqVItuyuI12IlESiJREoiURKIlESiJREoiURKIlESiJREoiURKIlESiJREoiURKIlESiJREoiURKIlESiJREoiURKIlEUacaXzOtWfqbePuL1XbAPadN+Iz6grZjXs+f7jvpKw39lPjkmwcKWUzLbl2nmHZDk1w/wAHXa4yQb1aSyyQlxllSkIUk8rgG6wCpaQR1Fba4+xSD7XjjkZJI2IdprdGOza2J1PTYaLWvBWHS/Zj3scxhkJs4+s22lwNuvNXNZnglq1BzrNF5nrJic+FqDGg2y8mPOaanC2wS463GjyEyCEkyG1uhxSe8IeSnchSSMKgxxtPFGynpXAxlzhfUFztMzhl/ZsMoNtLrLJMJdNK+SapaQ8NB5ENGtgc37Vzci+tl+bVih2/VHIMof1hwdp7ILDHsN0EZ+MDKTEK0w5HV5xHetIZACe6LalKSsj1khPsuOMdTspxTPsxxc299M3rN0aDZx53uBp1ujwlzZnzGob2mhptbXL6rtSRcDlax3Vjfa16TO49lON5OnPLNnEeah61qdYuzE6Y0ttXehboZabQlK+8PLsD1QrrW0/J3jMNQyWkbEY3CztiBbbS7nE203I32WtOPsJkhMdUZA8Hs7gnrrYAa6qzytmrW627K4jXYiURKIlESiJREoiURKIlESiJREoiURKIlESiJREoiURKIlESiJREoiURKIlESiJREoiURKIlESiJREoiURRpxpfM61Z+pt4+4vVdsA9p034jPqCtmNez5/uO+krVcSkKbRuAfVHiPdXYwXKT3EONlz3aR+an9gooc7uqciR+an9gomc9UCQnwAH0Ci8Lid1zReLbsriNdiJREoiURKIlESiJREoiURKIlESiJREoiURKIlESiJREoiURKIlESiJREoiURKIlESiJREoiURKIlESiJRFGnGl8zrVn6m3j7i9V2wD2nTfiM+oK2Y17Pn+476StV1H5NH9EfZXYwXKD/WK5ooUoiURKIv/Z</binary></FictionBook>
